------- FILE c:\Users\seany\Documents\irata\0087_Irata.78b.asm LEVEL 1 PASS 3
      1  28000 ????						; MACRO.H
      2  28000 ????
      3  28000 ????						; Based on the 2600 macro.h file.
      4  28000 ????						; Macros irrelevant to the 7800 have been removed, and the sleep macro 
      5  28000 ????						; has been adapted to give accurate results on the 7800.
      6  28000 ????
      7  28000 ????						; Version 1.0 2019/12/11 (based on the 2600 Version 1.05, 13/NOVEMBER/2003)
      8  28000 ????
      9  28000 ????						; Available macros...
     10  28000 ????						;   SLEEP n		 - sleep for n cycles
     11  28000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     12  28000 ????
     13  28000 ????						;-------------------------------------------------------------------------------
     14  28000 ????						; SLEEP duration
     15  28000 ????						; Original author: Thomas Jentzsch
     16  28000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     17  28000 ????						; useful for code where precise timing is required.
     18  28000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     19  28000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     20  28000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     21  28000 ????
     22  28000 ????				       MAC	sleep
     23  28000 ????			    .CYCLES    SET	{1}
     24  28000 ????
     25  28000 ????				       IF	.CYCLES < 2
     26  28000 ????				       ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     27  28000 ????				       ERR
     28  28000 ????				       ENDIF
     29  28000 ????
     30  28000 ????				       IF	.CYCLES & 1
     31  28000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     32  28000 ????				       nop	$80
     33  28000 ????				       ELSE
     34  28000 ????				       bit	$80
     35  28000 ????				       ENDIF
     36  28000 ????			    .CYCLES    SET	.CYCLES - 3
     37  28000 ????				       ENDIF
     38  28000 ????
     39  28000 ????				       REPEAT	.CYCLES / 2
     40  28000 ????				       nop
     41  28000 ????				       REPEND
     42  28000 ????				       ENDM		;usage: SLEEP n (n>1)
     43  28000 ????
     44  28000 ????
     45  28000 ????						;-------------------------------------------------------------------------------
     46  28000 ????						; FRACSLEEP duration
     47  28000 ????						; Based on Thomas Jentzsch's SLEEP macro, but takes cycles*2 to allow for
     48  28000 ????						; 7800 based 0.5 cycle sleep.
     49  28000 ????
     50  28000 ????				       MAC	fracsleep
     51  28000 ????			    .CYCLES    SET	{1}
     52  28000 ????
     53  28000 ????				       IF	.CYCLES < 4
     54  28000 ????				       ECHO	"MACRO ERROR: 'FRACSLEEP': Duration must be > 4"
     55  28000 ????				       ERR
     56  28000 ????				       ENDIF
     57  28000 ????				       IF	.CYCLES = 5
     58  28000 ????				       ECHO	"MACRO ERROR: 'FRACSLEEP': Duration = 5 is impossible"
     59  28000 ????				       ERR
     60  28000 ????				       ENDIF
     61  28000 ????
     62  28000 ????				       IF	.CYCLES & 1
     63  28000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     64  28000 ????				       nop	$0	; TIA access is 3.5 cycles
     65  28000 ????				       ELSE
     66  28000 ????				       bit	$0	; TIA access is 3.5 cycles
     67  28000 ????				       ENDIF
     68  28000 ????			    .CYCLES    SET	.CYCLES - 7
     69  28000 ????				       ENDIF
     70  28000 ????
     71  28000 ????				       IF	.CYCLES & 2
     72  28000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     73  28000 ????				       nop	$80
     74  28000 ????				       ELSE
     75  28000 ????				       bit	$80
     76  28000 ????				       ENDIF
     77  28000 ????			    .CYCLES    SET	.CYCLES - 6
     78  28000 ????				       ENDIF
     79  28000 ????
     80  28000 ????				       REPEAT	.CYCLES / 4
     81  28000 ????				       nop
     82  28000 ????				       REPEND
     83  28000 ????				       ENDM		;usage: FRACSLEEP n (n>1)
     84  28000 ????
     85  28000 ????
     86  28000 ????						;-------------------------------------------------------
     87  28000 ????						; SET_POINTER
     88  28000 ????						; Original author: Manuel Rotschkar
     89  28000 ????						;
     90  28000 ????						; Sets a 2 byte RAM pointer to an absolute address.
     91  28000 ????						;
     92  28000 ????						; Usage: SET_POINTER pointer, address
     93  28000 ????						; Example: SET_POINTER SpritePTR, SpriteData
     94  28000 ????						;
     95  28000 ????						; Note: Alters the accumulator, NZ flags
     96  28000 ????						; IN 1: 2 byte RAM location reserved for pointer
     97  28000 ????						; IN 2: absolute address
     98  28000 ????
     99  28000 ????				       MAC	set_pointer
    100  28000 ????			    .POINTER   SET	{1}
    101  28000 ????			    .ADDRESS   SET	{2}
    102  28000 ????
    103  28000 ????				       LDA	#<.ADDRESS	; Get Lowbyte of Address
    104  28000 ????				       STA	.POINTER	; Store in pointer
    105  28000 ????				       LDA	#>.ADDRESS	; Get Hibyte of Address
    106  28000 ????				       STA	.POINTER+1	; Store in pointer+1
    107  28000 ????
    108  28000 ????				       ENDM
    109  28000 ????
    110  28000 ????						; EOF
    111  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
    112  28000 ????
    113  28000 ????						; 7800MACRO.H
    114  28000 ????
    115  28000 ????						;-------------------------------------------------------
    116  28000 ????						; BOXCOLLISIONCHECK
    117  28000 ????						; author: Mike Saarna
    118  28000 ????						;
    119  28000 ????						; A general bounding box collision check. compares 2 rectangles of differing size
    120  28000 ????						; and shape for overlap. Carry is set for collision detected, clear for none.
    121  28000 ????						; 
    122  28000 ????						; Usage: BOXCOLLISIONCHECK x1var,y1var,w1var,h1var,x2var,y2var,w2var,h2var
    123  28000 ????						;
    124  28000 ????
    125  28000 ????				       MAC	boxcollisioncheck
    126  28000 ????			    .boxx1     SET	{1}
    127  28000 ????			    .boxy1     SET	{2}
    128  28000 ????			    .boxw1     SET	{3}
    129  28000 ????			    .boxh1     SET	{4}
    130  28000 ????			    .boxx2     SET	{5}
    131  28000 ????			    .boxy2     SET	{6}
    132  28000 ????			    .boxw2     SET	{7}
    133  28000 ????			    .boxh2     SET	{8}
    134  28000 ????
    135  28000 ????			    .DoXCollisionCheck
    136  28000 ????				       lda	.boxx1	;3
    137  28000 ????				       cmp	.boxx2	;2
    138  28000 ????				       bcs	.X1isbiggerthanX2	;2/3
    139  28000 ????			    .X2isbiggerthanX1
    140  28000 ????				       adc	#.boxw1	;2
    141  28000 ????				       cmp	.boxx2	;3
    142  28000 ????				       bcs	.DoYCollisionCheck	;3/2
    143  28000 ????				       bcc	.noboxcollision	;3
    144  28000 ????			    .X1isbiggerthanX2
    145  28000 ????				       clc		;2
    146  28000 ????				       sbc	#.boxw2	;2
    147  28000 ????				       cmp	.boxx2	;3
    148  28000 ????				       bcs	.noboxcollision	;3/2
    149  28000 ????			    .DoYCollisionCheck
    150  28000 ????				       lda	.boxy1	;3
    151  28000 ????				       cmp	.boxy2	;3
    152  28000 ????				       bcs	.Y1isbiggerthanY2	;3/2
    153  28000 ????			    .Y2isbiggerthanY1
    154  28000 ????				       adc	#.boxh1	;2
    155  28000 ????				       cmp	.boxy2	;3
    156  28000 ????				       jmp	.checkdone	;6 
    157  28000 ????			    .Y1isbiggerthanY2
    158  28000 ????				       clc		;2
    159  28000 ????				       sbc	#.boxh2	;2
    160  28000 ????				       cmp	.boxy2	;3
    161  28000 ????				       bcs	.noboxcollision	;3/2
    162  28000 ????			    .boxcollision
    163  28000 ????				       sec		;2
    164  28000 ????				       .byte	$24	; hardcoded "BIT [clc opcode]", used to skip over the following clc
    165  28000 ????			    .noboxcollision
    166  28000 ????				       clc		;2
    167  28000 ????			    .checkdone
    168  28000 ????
    169  28000 ????				       ENDM
    170  28000 ????
    171  28000 ????						; QBOXCOLLISIONCHECK
    172  28000 ????						; author: unknown
    173  28000 ????						;
    174  28000 ????						; A general bounding box collision check. compares 2 rectangles of differing size
    175  28000 ????						; and shape for overlap. Carry is CLEAR for collision detected, SET for none.
    176  28000 ????						; 
    177  28000 ????						; Usage: QBOXCOLLISIONCHECK x1var,y1var,w1var,h1var,x2var,y2var,w2var,h2var
    178  28000 ????						;
    179  28000 ????				       MAC	qboxcollisioncheck
    180  28000 ????			    .boxx1     SET	{1}
    181  28000 ????			    .boxy1     SET	{2}
    182  28000 ????			    .boxw1     SET	{3}
    183  28000 ????			    .boxh1     SET	{4}
    184  28000 ????			    .boxx2     SET	{5}
    185  28000 ????			    .boxy2     SET	{6}
    186  28000 ????			    .boxw2     SET	{7}
    187  28000 ????			    .boxh2     SET	{8}
    188  28000 ????
    189  28000 ????				       lda	.boxx2
    190  28000 ????				       clc
    191  28000 ????				       adc	#.boxw2
    192  28000 ????				       sbc	.boxx1
    193  28000 ????				       cmp	#.boxw1+.boxw2-1
    194  28000 ????				       bcs	.qboxcollisiondone
    195  28000 ????						;if we're here, carry is clear
    196  28000 ????				       lda	.boxy2
    197  28000 ????				       adc	#.boxh2
    198  28000 ????				       sbc	.boxy1
    199  28000 ????				       cmp	#.boxh1+.boxh2-1
    200  28000 ????			    .qboxcollisiondone
    201  28000 ????				       rol		; temp for testing - invert carry...
    202  28000 ????				       eor	#1
    203  28000 ????				       ror
    204  28000 ????				       ENDM
    205  28000 ????
    206  28000 ????
    207  28000 ????				       MAC	median3
    208  28000 ????
    209  28000 ????						; A median filter (for smoothing paddle jitter)
    210  28000 ????						;   this macro takes the current paddle value, compares it to historic
    211  28000 ????						;   values, and replaces the current paddle value with the median.
    212  28000 ????						; 
    213  28000 ????						; called as:  MEDIAN3 STORAGE CURRENT
    214  28000 ????						;    where STORAGE points to 3 consecutive bytes of memory. The first 2
    215  28000 ????						;	  must be dedicated to this MEDIAN filter. The last 1 is a temp.
    216  28000 ????						;    where CURRENT is memory holding the new value you wish to compare to
    217  28000 ????						;	  the previous values, and update with the median value.
    218  28000 ????						;
    219  28000 ????						; returns: CURRENT (modified to contain median value)
    220  28000 ????						;
    221  28000 ????						; author: Mike Saarna (aka RevEng)
    222  28000 ????
    223  28000 ????			    .MedianBytes SET	{1}
    224  28000 ????			    .NewValue  SET	{2}
    225  28000 ????
    226  28000 ????				       lda	#0
    227  28000 ????				       ldy	.NewValue
    228  28000 ????				       sty	.MedianBytes+2	; put the new value in the most "recent" slot
    229  28000 ????
    230  28000 ????						; build an index from relative size comparisons between our 3 values.
    231  28000 ????				       cpy	.MedianBytes
    232  28000 ????				       rol
    233  28000 ????				       cpy	.MedianBytes+1
    234  28000 ????				       rol
    235  28000 ????				       ldy	.MedianBytes
    236  28000 ????				       cpy	.MedianBytes+1
    237  28000 ????				       rol
    238  28000 ????				       tay
    239  28000 ????
    240  28000 ????				       ldx	MedianOrderLUT,y	; convert the size-comparison index to an index to the median value
    241  28000 ????				       lda	.MedianBytes,x
    242  28000 ????				       sta	.NewValue	; we replace the new value memory with the median value
    243  28000 ????
    244  28000 ????						; then shift values from "newer" bytes to "older" bytes, leaving the 
    245  28000 ????						; newest byte (.MedianBytes+2) empty for next time.
    246  28000 ????				       lda	.MedianBytes+1
    247  28000 ????				       sta	.MedianBytes
    248  28000 ????				       lda	.MedianBytes+2
    249  28000 ????				       sta	.MedianBytes+1
    250  28000 ????				       ifnconst	MedianOrderLUT
    251  28000 ????				       jmp	MedianOrderLUTend
    252  28000 ????			    MedianOrderLUT		; converts our "comparison index" to an index to the median value
    253  28000 ????				       .byte	0	; 0  B2 < B0 < B1
    254  28000 ????				       .byte	1	; 1  B2 < B1 < B0
    255  28000 ????				       .byte	2	; 2   impossible 
    256  28000 ????				       .byte	2	; 3  B1 < B2 < B0
    257  28000 ????				       .byte	2	; 4  B0 < B2 < B1
    258  28000 ????				       .byte	2	; 5   impossible 
    259  28000 ????				       .byte	1	; 6  B0 < B1 < B2
    260  28000 ????				       .byte	0	; 7  B1 < B0 < B2
    261  28000 ????			    MedianOrderLUTend
    262  28000 ????				       endif
    263  28000 ????				       ENDM
    264  28000 ????
    265  28000 ????				       MAC	plotsprite
    266  28000 ????
    267  28000 ????						; A macro version of the plotsprite command. 
    268  28000 ????						; This trades off rom space for speed.
    269  28000 ????						; It also doesn't check if the visible screen is displayed or not.
    270  28000 ????						; It has no training wheels. It is all rusty sharp edges.
    271  28000 ????
    272  28000 ????			    .GFXLabel  SET	{1}	; constant
    273  28000 ????			    .Palette   SET	{2}	; constant/variable MACARG2CONST
    274  28000 ????			    .SpriteX   SET	{3}	; constant/variable MACARG3CONST
    275  28000 ????			    .SpriteY   SET	{4}	; constant/variable MACARG4CONST
    276  28000 ????			    .ByteOffset SET	{5}	; constant/variable MACARG5CONST
    277  28000 ????
    278  28000 ????				       if	MACARG4CONST = 0
    279  28000 ????				       lda	.SpriteY
    280  28000 ????				       else
    281  28000 ????				       lda	#.SpriteY
    282  28000 ????				       endif
    283  28000 ????
    284  28000 ????				       lsr
    285  28000 ????				       lsr
    286  28000 ????				       asr	#%11111110	; ensure carry is clear
    287  28000 ????				       if	WZONEHEIGHT = 16
    288  28000 ????				       asr	#%11111110	; ensure carry is clear
    289  28000 ????				       endif
    290  28000 ????
    291  28000 ????				       tax
    292  28000 ????
    293  28000 ????				       cpx	#WZONECOUNT
    294  28000 ????				       bcs	.PLOTSPRITEnext
    295  28000 ????						; carry is clear
    296  28000 ????
    297  28000 ????				       ifconst	VSCROLL
    298  28000 ????				       ldy	Xx3,x
    299  28000 ????				       lda	DLLMEM+11,y
    300  28000 ????				       else		; !VSCROLL
    301  28000 ????				       lda	DLPOINTL,x	; Get pointer to DL that this sprite starts in
    302  28000 ????				       endif
    303  28000 ????				       ifconst	DOUBLEBUFFER
    304  28000 ????				       adc	doublebufferdloffset
    305  28000 ????				       endif		; DOUBLEBUFFER
    306  28000 ????				       sta	dlpnt
    307  28000 ????				       ifconst	VSCROLL
    308  28000 ????				       lda	DLLMEM+10,y
    309  28000 ????				       else		; !VSCROLL
    310  28000 ????				       lda	DLPOINTH,x
    311  28000 ????				       endif		; !VSCROLL
    312  28000 ????				       ifconst	DOUBLEBUFFER
    313  28000 ????				       adc	#0
    314  28000 ????				       endif		; DOUBLEBUFFER
    315  28000 ????				       sta	dlpnt+1
    316  28000 ????
    317  28000 ????				       ldy	dlend,x	; find the next new object position in this zone
    318  28000 ????
    319  28000 ????				       ifconst	.ByteOffset
    320  28000 ????
    321  28000 ????				       if	MACARG5CONST = 1
    322  28000 ????				       lda	#.ByteOffset
    323  28000 ????				       else
    324  28000 ????				       lda	.ByteOffset
    325  28000 ????				       endif
    326  28000 ????				       ifconst	DOUBLEBUFFER
    327  28000 ????				       if	{1}_width = 1
    328  28000 ????				       clc
    329  28000 ????				       endif
    330  28000 ????				       endif
    331  28000 ????				       if	{1}_width = 2
    332  28000 ????				       asl
    333  28000 ????				       endif
    334  28000 ????				       if	{1}_width = 3
    335  28000 ????				       asl
    336  28000 ????				       if	MACARG5CONST = 1
    337  28000 ????				       adc	#.ByteOffset
    338  28000 ????				       else
    339  28000 ????				       adc	.ByteOffset
    340  28000 ????				       endif
    341  28000 ????				       endif
    342  28000 ????				       if	{1}_width = 4
    343  28000 ????				       asl
    344  28000 ????				       asl
    345  28000 ????				       endif
    346  28000 ????				       if	{1}_width = 5
    347  28000 ????				       asl
    348  28000 ????				       asl
    349  28000 ????				       if	MACARG5CONST = 1
    350  28000 ????				       adc	#.ByteOffset
    351  28000 ????				       else
    352  28000 ????				       adc	.ByteOffset
    353  28000 ????				       endif
    354  28000 ????				       endif
    355  28000 ????				       if	{1}_width = 6
    356  28000 ????				       asl
    357  28000 ????				       if	MACARG5CONST = 1
    358  28000 ????				       adc	#.ByteOffset
    359  28000 ????				       else
    360  28000 ????				       adc	.ByteOffset
    361  28000 ????				       endif
    362  28000 ????				       asl
    363  28000 ????				       endif
    364  28000 ????				       if	{1}_width = 7
    365  28000 ????				       asl
    366  28000 ????				       if	MACARG5CONST = 1
    367  28000 ????				       adc	#.ByteOffset
    368  28000 ????				       else
    369  28000 ????				       adc	.ByteOffset
    370  28000 ????				       endif
    371  28000 ????				       asl
    372  28000 ????				       if	MACARG5CONST = 1
    373  28000 ????				       adc	#.ByteOffset
    374  28000 ????				       else
    375  28000 ????				       adc	.ByteOffset
    376  28000 ????				       endif
    377  28000 ????				       endif
    378  28000 ????				       if	{1}_width = 8
    379  28000 ????				       asl
    380  28000 ????				       asl
    381  28000 ????				       asl
    382  28000 ????				       endif
    383  28000 ????				       if	{1}_width = 9
    384  28000 ????				       asl
    385  28000 ????				       asl
    386  28000 ????				       asl
    387  28000 ????				       if	MACARG5CONST = 1
    388  28000 ????				       adc	#.ByteOffset
    389  28000 ????				       else
    390  28000 ????				       adc	.ByteOffset
    391  28000 ????				       endif
    392  28000 ????				       endif
    393  28000 ????				       if	{1}_width = 10
    394  28000 ????				       asl
    395  28000 ????				       asl
    396  28000 ????				       if	MACARG5CONST = 1
    397  28000 ????				       adc	#.ByteOffset
    398  28000 ????				       else
    399  28000 ????				       adc	.ByteOffset
    400  28000 ????				       endif
    401  28000 ????				       asl
    402  28000 ????				       endif
    403  28000 ????				       if	{1}_width = 11
    404  28000 ????				       asl
    405  28000 ????				       asl
    406  28000 ????				       if	MACARG5CONST = 1
    407  28000 ????				       adc	#.ByteOffset
    408  28000 ????				       else
    409  28000 ????				       adc	.ByteOffset
    410  28000 ????				       endif
    411  28000 ????				       asl
    412  28000 ????				       if	MACARG5CONST = 1
    413  28000 ????				       adc	#.ByteOffset
    414  28000 ????				       else
    415  28000 ????				       adc	.ByteOffset
    416  28000 ????				       endif
    417  28000 ????				       endif
    418  28000 ????				       if	{1}_width = 12
    419  28000 ????				       asl
    420  28000 ????				       if	MACARG5CONST = 1
    421  28000 ????				       adc	#.ByteOffset
    422  28000 ????				       else
    423  28000 ????				       adc	.ByteOffset
    424  28000 ????				       endif
    425  28000 ????				       asl
    426  28000 ????				       asl
    427  28000 ????				       endif
    428  28000 ????				       if	{1}_width = 13
    429  28000 ????				       asl
    430  28000 ????				       if	MACARG5CONST = 1
    431  28000 ????				       adc	#.ByteOffset
    432  28000 ????				       else
    433  28000 ????				       adc	.ByteOffset
    434  28000 ????				       endif
    435  28000 ????				       asl
    436  28000 ????				       asl
    437  28000 ????				       if	MACARG5CONST = 1
    438  28000 ????				       adc	#.ByteOffset
    439  28000 ????				       else
    440  28000 ????				       adc	.ByteOffset
    441  28000 ????				       endif
    442  28000 ????
    443  28000 ????				       endif
    444  28000 ????				       if	{1}_width = 14
    445  28000 ????				       asl
    446  28000 ????				       if	MACARG5CONST = 1
    447  28000 ????				       adc	#.ByteOffset
    448  28000 ????				       else
    449  28000 ????				       adc	.ByteOffset
    450  28000 ????				       endif
    451  28000 ????				       asl
    452  28000 ????				       if	MACARG5CONST = 1
    453  28000 ????				       adc	#.ByteOffset
    454  28000 ????				       else
    455  28000 ????				       adc	.ByteOffset
    456  28000 ????				       endif
    457  28000 ????				       asl
    458  28000 ????				       endif
    459  28000 ????				       if	{1}_width = 15
    460  28000 ????				       asl
    461  28000 ????				       if	MACARG5CONST = 1
    462  28000 ????				       adc	#.ByteOffset
    463  28000 ????				       else
    464  28000 ????				       adc	.ByteOffset
    465  28000 ????				       endif
    466  28000 ????				       asl
    467  28000 ????				       if	MACARG5CONST = 1
    468  28000 ????				       adc	#.ByteOffset
    469  28000 ????				       else
    470  28000 ????				       adc	.ByteOffset
    471  28000 ????				       endif
    472  28000 ????				       asl
    473  28000 ????				       if	MACARG5CONST = 1
    474  28000 ????				       adc	#.ByteOffset
    475  28000 ????				       else
    476  28000 ????				       adc	.ByteOffset
    477  28000 ????				       endif
    478  28000 ????				       endif
    479  28000 ????				       if	{1}_width = 16
    480  28000 ????				       asl
    481  28000 ????				       asl
    482  28000 ????				       asl
    483  28000 ????				       asl
    484  28000 ????				       endif
    485  28000 ????				       adc	#<.GFXLabel	; carry is clear via previous asl or asr
    486  28000 ????				       else
    487  28000 ????				       lda	#<.GFXLabel	; carry is clear via previous asl or asr
    488  28000 ????				       endif		; .ByteOffset
    489  28000 ????				       sta	(dlpnt),y	; #1 - low byte object address
    490  28000 ????
    491  28000 ????				       iny
    492  28000 ????
    493  28000 ????				       lda	#({1}_mode | %01000000)
    494  28000 ????				       sta	(dlpnt),y	; #2 - graphics mode , indirect
    495  28000 ????
    496  28000 ????				       iny
    497  28000 ????
    498  28000 ????				       if	MACARG4CONST = 0
    499  28000 ????				       lda	.SpriteY
    500  28000 ????				       else
    501  28000 ????				       lda	#.SpriteY
    502  28000 ????				       endif
    503  28000 ????				       and	#(WZONEHEIGHT - 1)
    504  28000 ????				       cmp	#1	; clear carry if our sprite is just in this zone
    505  28000 ????				       ora	#>.GFXLabel
    506  28000 ????				       sta	(dlpnt),y	; #3 - hi byte object address
    507  28000 ????
    508  28000 ????				       iny
    509  28000 ????
    510  28000 ????				       if	MACARG2CONST = 1
    511  28000 ????				       lda	#({1}_width_twoscompliment | (.Palette * 32))
    512  28000 ????				       else
    513  28000 ????				       lda	#({1}_width_twoscompliment)
    514  28000 ????				       ora	.Palette
    515  28000 ????				       endif
    516  28000 ????				       sta	(dlpnt),y	; #4 - palette|width
    517  28000 ????
    518  28000 ????				       iny
    519  28000 ????
    520  28000 ????				       if	MACARG3CONST = 1
    521  28000 ????				       lda	#.SpriteX
    522  28000 ????				       else
    523  28000 ????				       lda	.SpriteX
    524  28000 ????				       endif
    525  28000 ????				       sta	(dlpnt),y	; #5 - x object position
    526  28000 ????
    527  28000 ????				       iny
    528  28000 ????				       sty	dlend,x
    529  28000 ????
    530  28000 ????				       ifconst	ALWAYSTERMINATE
    531  28000 ????				       iny
    532  28000 ????				       lda	#0
    533  28000 ????				       sta	(dlpnt),y
    534  28000 ????				       endif
    535  28000 ????
    536  28000 ????				       bcc	.PLOTSPRITEend
    537  28000 ????
    538  28000 ????			    .PLOTSPRITEnext
    539  28000 ????				       inx		; next zone
    540  28000 ????
    541  28000 ????				       cpx	#WZONECOUNT
    542  28000 ????				       bcs	.PLOTSPRITEend
    543  28000 ????						; carry is clear
    544  28000 ????
    545  28000 ????				       ifconst	VSCROLL
    546  28000 ????				       ldy	Xx3,x
    547  28000 ????				       lda	DLLMEM+11,y
    548  28000 ????				       else		; !VSCROLL
    549  28000 ????				       lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
    550  28000 ????				       endif		; !VSCROLL
    551  28000 ????				       ifconst	DOUBLEBUFFER
    552  28000 ????				       adc	doublebufferdloffset
    553  28000 ????				       endif		; DOUBLEBUFFER
    554  28000 ????				       sta	dlpnt
    555  28000 ????				       ifconst	VSCROLL
    556  28000 ????				       lda	DLLMEM+10,y
    557  28000 ????				       else		; !VSCROLL
    558  28000 ????				       lda	DLPOINTH,x
    559  28000 ????				       endif		; !VSCROLL
    560  28000 ????				       ifconst	DOUBLEBUFFER
    561  28000 ????				       adc	#0
    562  28000 ????				       endif		; DOUBLEBUFFER
    563  28000 ????				       sta	dlpnt+1
    564  28000 ????
    565  28000 ????				       ldy	dlend,x	; find the next new object position in this zone
    566  28000 ????
    567  28000 ????				       ifconst	.ByteOffset
    568  28000 ????
    569  28000 ????				       if	MACARG5CONST = 1
    570  28000 ????				       lda	#.ByteOffset
    571  28000 ????				       else
    572  28000 ????				       lda	.ByteOffset
    573  28000 ????				       endif
    574  28000 ????				       if	{1}_width = 1
    575  28000 ????				       clc
    576  28000 ????				       endif
    577  28000 ????				       if	{1}_width = 2
    578  28000 ????				       asl		; carry clear
    579  28000 ????				       endif
    580  28000 ????				       if	{1}_width = 3
    581  28000 ????				       asl		; carry clear
    582  28000 ????				       if	MACARG5CONST = 1
    583  28000 ????				       adc	#.ByteOffset
    584  28000 ????				       else
    585  28000 ????				       adc	.ByteOffset
    586  28000 ????				       endif
    587  28000 ????				       endif
    588  28000 ????				       if	{1}_width = 4
    589  28000 ????				       asl		; carry clear
    590  28000 ????				       asl
    591  28000 ????				       endif
    592  28000 ????				       if	{1}_width = 5
    593  28000 ????				       asl		; carry clear
    594  28000 ????				       asl
    595  28000 ????				       if	MACARG5CONST = 1
    596  28000 ????				       adc	#.ByteOffset
    597  28000 ????				       else
    598  28000 ????				       adc	.ByteOffset
    599  28000 ????				       endif
    600  28000 ????				       endif
    601  28000 ????				       if	{1}_width = 6
    602  28000 ????				       asl		; carry clear
    603  28000 ????				       if	MACARG5CONST = 1
    604  28000 ????				       adc	#.ByteOffset
    605  28000 ????				       else
    606  28000 ????				       adc	.ByteOffset
    607  28000 ????				       endif
    608  28000 ????				       asl
    609  28000 ????				       endif
    610  28000 ????				       if	{1}_width = 7
    611  28000 ????				       asl		; carry clear
    612  28000 ????				       if	MACARG5CONST = 1
    613  28000 ????				       adc	#.ByteOffset
    614  28000 ????				       else
    615  28000 ????				       adc	.ByteOffset
    616  28000 ????				       endif
    617  28000 ????				       asl
    618  28000 ????				       endif
    619  28000 ????				       if	{1}_width = 8
    620  28000 ????				       asl		; carry clear
    621  28000 ????				       asl
    622  28000 ????				       asl
    623  28000 ????				       endif
    624  28000 ????				       if	{1}_width = 9
    625  28000 ????				       asl		; carry clear
    626  28000 ????				       asl
    627  28000 ????				       asl
    628  28000 ????				       if	MACARG5CONST = 1
    629  28000 ????				       adc	#.ByteOffset
    630  28000 ????				       else
    631  28000 ????				       adc	.ByteOffset
    632  28000 ????				       endif
    633  28000 ????				       endif
    634  28000 ????				       if	{1}_width = 10
    635  28000 ????				       asl		; carry clear
    636  28000 ????				       asl
    637  28000 ????				       if	MACARG5CONST = 1
    638  28000 ????				       adc	#.ByteOffset
    639  28000 ????				       else
    640  28000 ????				       adc	.ByteOffset
    641  28000 ????				       endif
    642  28000 ????				       asl
    643  28000 ????				       endif
    644  28000 ????				       if	{1}_width = 11
    645  28000 ????				       asl		; carry clear
    646  28000 ????				       asl
    647  28000 ????				       if	MACARG5CONST = 1
    648  28000 ????				       adc	#.ByteOffset
    649  28000 ????				       else
    650  28000 ????				       adc	.ByteOffset
    651  28000 ????				       endif
    652  28000 ????				       asl
    653  28000 ????				       if	MACARG5CONST = 1
    654  28000 ????				       adc	#.ByteOffset
    655  28000 ????				       else
    656  28000 ????				       adc	.ByteOffset
    657  28000 ????				       endif
    658  28000 ????				       endif
    659  28000 ????				       if	{1}_width = 12
    660  28000 ????				       asl		; carry clear
    661  28000 ????				       if	MACARG5CONST = 1
    662  28000 ????				       adc	#.ByteOffset
    663  28000 ????				       else
    664  28000 ????				       adc	.ByteOffset
    665  28000 ????				       endif
    666  28000 ????				       asl
    667  28000 ????				       asl
    668  28000 ????				       endif
    669  28000 ????				       if	{1}_width = 13
    670  28000 ????				       asl		; carry clear
    671  28000 ????				       if	MACARG5CONST = 1
    672  28000 ????				       adc	#.ByteOffset
    673  28000 ????				       else
    674  28000 ????				       adc	.ByteOffset
    675  28000 ????				       endif
    676  28000 ????				       asl
    677  28000 ????				       asl
    678  28000 ????				       if	MACARG5CONST = 1
    679  28000 ????				       adc	#.ByteOffset
    680  28000 ????				       else
    681  28000 ????				       adc	.ByteOffset
    682  28000 ????				       endif
    683  28000 ????				       endif
    684  28000 ????				       if	{1}_width = 14
    685  28000 ????				       asl		; carry clear
    686  28000 ????				       if	MACARG5CONST = 1
    687  28000 ????				       adc	#.ByteOffset
    688  28000 ????				       else
    689  28000 ????				       adc	.ByteOffset
    690  28000 ????				       endif
    691  28000 ????				       asl
    692  28000 ????				       if	MACARG5CONST = 1
    693  28000 ????				       adc	#.ByteOffset
    694  28000 ????				       else
    695  28000 ????				       adc	.ByteOffset
    696  28000 ????				       endif
    697  28000 ????				       asl
    698  28000 ????				       endif
    699  28000 ????				       if	{1}_width = 15
    700  28000 ????				       asl
    701  28000 ????				       if	MACARG5CONST = 1
    702  28000 ????				       adc	#.ByteOffset
    703  28000 ????				       else
    704  28000 ????				       adc	.ByteOffset
    705  28000 ????				       endif
    706  28000 ????				       asl
    707  28000 ????				       if	MACARG5CONST = 1
    708  28000 ????				       adc	#.ByteOffset
    709  28000 ????				       else
    710  28000 ????				       adc	.ByteOffset
    711  28000 ????				       endif
    712  28000 ????				       asl
    713  28000 ????				       if	MACARG5CONST = 1
    714  28000 ????				       adc	#.ByteOffset
    715  28000 ????				       else
    716  28000 ????				       adc	.ByteOffset
    717  28000 ????				       endif
    718  28000 ????				       endif
    719  28000 ????				       if	{1}_width = 16
    720  28000 ????				       asl
    721  28000 ????				       asl
    722  28000 ????				       asl
    723  28000 ????				       asl
    724  28000 ????				       endif
    725  28000 ????				       adc	#<.GFXLabel
    726  28000 ????				       else
    727  28000 ????				       lda	#<.GFXLabel
    728  28000 ????				       endif		; .ByteOffset
    729  28000 ????
    730  28000 ????				       sta	(dlpnt),y	; #1 - low byte object address
    731  28000 ????
    732  28000 ????				       iny
    733  28000 ????
    734  28000 ????				       lda	#({1}_mode | %01000000)
    735  28000 ????				       sta	(dlpnt),y	; #2 - graphics mode , indirect
    736  28000 ????
    737  28000 ????				       iny
    738  28000 ????
    739  28000 ????				       if	MACARG4CONST = 0
    740  28000 ????				       lda	.SpriteY
    741  28000 ????				       else
    742  28000 ????				       lda	#.SpriteY
    743  28000 ????				       endif
    744  28000 ????				       and	#(WZONEHEIGHT - 1)
    745  28000 ????				       ora	#>(.GFXLabel - (WZONEHEIGHT * 256))	; start in the dma hole
    746  28000 ????				       sta	(dlpnt),y	; #3 - hi byte object address
    747  28000 ????
    748  28000 ????				       iny
    749  28000 ????
    750  28000 ????				       if	MACARG2CONST = 1
    751  28000 ????				       lda	#({1}_width_twoscompliment | (.Palette * 32))
    752  28000 ????				       else
    753  28000 ????				       lda	#({1}_width_twoscompliment)
    754  28000 ????				       ora	.Palette
    755  28000 ????				       endif
    756  28000 ????				       sta	(dlpnt),y	; #4 - palette|width
    757  28000 ????
    758  28000 ????				       iny
    759  28000 ????
    760  28000 ????				       if	MACARG3CONST = 1
    761  28000 ????				       lda	#.SpriteX
    762  28000 ????				       else
    763  28000 ????				       lda	.SpriteX
    764  28000 ????				       endif
    765  28000 ????				       sta	(dlpnt),y	; #5 - x object position
    766  28000 ????
    767  28000 ????				       iny
    768  28000 ????				       sty	dlend,x
    769  28000 ????
    770  28000 ????				       ifconst	ALWAYSTERMINATE
    771  28000 ????				       iny
    772  28000 ????				       lda	#0
    773  28000 ????				       sta	(dlpnt),y
    774  28000 ????				       endif
    775  28000 ????
    776  28000 ????			    .PLOTSPRITEend
    777  28000 ????				       ENDM
    778  28000 ????
    779  28000 ????				       MAC	plotsprite4
    780  28000 ????
    781  28000 ????						; A macro version of plotsprite. (with 4 byte objects)
    782  28000 ????						; This trades off rom space for speed.
    783  28000 ????						; It also doesn't check if the visible screen is displayed or not.
    784  28000 ????						; It has no training wheels. It is all rusty sharp edges.
    785  28000 ????
    786  28000 ????			    .GFXLabel  SET	{1}
    787  28000 ????			    .Palette   SET	{2}	; constant
    788  28000 ????			    .SpriteX   SET	{3}	; variable
    789  28000 ????			    .SpriteY   SET	{4}	; variable
    790  28000 ????			    .ByteOffset SET	{5}	; variable 
    791  28000 ????
    792  28000 ????				       if	MACARG4CONST = 0
    793  28000 ????				       lda	.SpriteY
    794  28000 ????				       else
    795  28000 ????				       lda	#.SpriteY
    796  28000 ????				       endif
    797  28000 ????				       lsr
    798  28000 ????				       lsr
    799  28000 ????				       asr	#%11111110	; ensure carry is clear
    800  28000 ????				       if	WZONEHEIGHT = 16
    801  28000 ????				       asr	#%11111110	; ensure carry is clear
    802  28000 ????				       endif
    803  28000 ????
    804  28000 ????				       tax
    805  28000 ????
    806  28000 ????				       cpx	#WZONECOUNT
    807  28000 ????				       bcs	.PLOTSPRITEnext
    808  28000 ????						; carry is clear
    809  28000 ????				       ifconst	VSCROLL
    810  28000 ????				       ldy	Xx3,x
    811  28000 ????				       lda	DLLMEM+11,y
    812  28000 ????				       else		; !VSCROLL
    813  28000 ????				       lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
    814  28000 ????				       endif		; !VSCROLL
    815  28000 ????				       ifconst	DOUBLEBUFFER
    816  28000 ????				       adc	doublebufferdloffset
    817  28000 ????				       endif		; DOUBLEBUFFER
    818  28000 ????				       sta	dlpnt
    819  28000 ????				       ifconst	VSCROLL
    820  28000 ????				       lda	DLLMEM+10,y
    821  28000 ????				       else		; !VSCROLL
    822  28000 ????				       lda	DLPOINTH,x
    823  28000 ????				       endif		; !VSCROLL
    824  28000 ????				       ifconst	DOUBLEBUFFER
    825  28000 ????				       adc	#0
    826  28000 ????				       endif		; DOUBLEBUFFER
    827  28000 ????				       sta	dlpnt+1
    828  28000 ????
    829  28000 ????				       ldy	dlend,x	; find the next new object position in this zone
    830  28000 ????
    831  28000 ????				       ifconst	.ByteOffset
    832  28000 ????
    833  28000 ????				       if	MACARG5CONST = 1
    834  28000 ????				       lda	#.ByteOffset
    835  28000 ????				       else
    836  28000 ????				       lda	.ByteOffset
    837  28000 ????				       endif
    838  28000 ????				       ifconst	DOUBLEBUFFER
    839  28000 ????				       if	{1}_width = 1
    840  28000 ????				       clc
    841  28000 ????				       endif
    842  28000 ????				       endif
    843  28000 ????				       if	{1}_width = 2
    844  28000 ????				       asl
    845  28000 ????				       endif
    846  28000 ????				       if	{1}_width = 3
    847  28000 ????				       asl
    848  28000 ????				       if	MACARG5CONST = 1
    849  28000 ????				       adc	#.ByteOffset
    850  28000 ????				       else
    851  28000 ????				       adc	.ByteOffset
    852  28000 ????				       endif
    853  28000 ????				       endif
    854  28000 ????				       if	{1}_width = 4
    855  28000 ????				       asl
    856  28000 ????				       asl
    857  28000 ????				       endif
    858  28000 ????				       if	{1}_width = 5
    859  28000 ????				       asl
    860  28000 ????				       asl
    861  28000 ????				       if	MACARG5CONST = 1
    862  28000 ????				       adc	#.ByteOffset
    863  28000 ????				       else
    864  28000 ????				       adc	.ByteOffset
    865  28000 ????				       endif
    866  28000 ????				       endif
    867  28000 ????				       if	{1}_width = 6
    868  28000 ????				       asl
    869  28000 ????				       if	MACARG5CONST = 1
    870  28000 ????				       adc	#.ByteOffset
    871  28000 ????				       else
    872  28000 ????				       adc	.ByteOffset
    873  28000 ????				       endif
    874  28000 ????
    875  28000 ????				       asl
    876  28000 ????				       endif
    877  28000 ????				       if	{1}_width = 7
    878  28000 ????				       asl
    879  28000 ????				       if	MACARG5CONST = 1
    880  28000 ????				       adc	#.ByteOffset
    881  28000 ????				       else
    882  28000 ????				       adc	.ByteOffset
    883  28000 ????				       endif
    884  28000 ????				       asl
    885  28000 ????				       if	MACARG5CONST = 1
    886  28000 ????				       adc	#.ByteOffset
    887  28000 ????				       else
    888  28000 ????				       adc	.ByteOffset
    889  28000 ????				       endif
    890  28000 ????				       endif
    891  28000 ????				       if	{1}_width = 8
    892  28000 ????				       asl
    893  28000 ????				       asl
    894  28000 ????				       asl
    895  28000 ????				       endif
    896  28000 ????				       if	{1}_width = 9
    897  28000 ????				       asl
    898  28000 ????				       asl
    899  28000 ????				       asl
    900  28000 ????				       if	MACARG5CONST = 1
    901  28000 ????				       adc	#.ByteOffset
    902  28000 ????				       else
    903  28000 ????				       adc	.ByteOffset
    904  28000 ????				       endif
    905  28000 ????				       endif
    906  28000 ????				       if	{1}_width = 10
    907  28000 ????				       asl
    908  28000 ????				       asl
    909  28000 ????				       if	MACARG5CONST = 1
    910  28000 ????				       adc	#.ByteOffset
    911  28000 ????				       else
    912  28000 ????				       adc	.ByteOffset
    913  28000 ????				       endif
    914  28000 ????				       asl
    915  28000 ????				       endif
    916  28000 ????				       if	{1}_width = 11
    917  28000 ????				       asl
    918  28000 ????				       asl
    919  28000 ????				       if	MACARG5CONST = 1
    920  28000 ????				       adc	#.ByteOffset
    921  28000 ????				       else
    922  28000 ????				       adc	.ByteOffset
    923  28000 ????				       endif
    924  28000 ????				       asl
    925  28000 ????				       if	MACARG5CONST = 1
    926  28000 ????				       adc	#.ByteOffset
    927  28000 ????				       else
    928  28000 ????				       adc	.ByteOffset
    929  28000 ????				       endif
    930  28000 ????				       endif
    931  28000 ????				       if	{1}_width = 12
    932  28000 ????				       asl
    933  28000 ????				       if	MACARG5CONST = 1
    934  28000 ????				       adc	#.ByteOffset
    935  28000 ????				       else
    936  28000 ????				       adc	.ByteOffset
    937  28000 ????				       endif
    938  28000 ????				       asl
    939  28000 ????				       asl
    940  28000 ????				       endif
    941  28000 ????				       if	{1}_width = 13
    942  28000 ????				       asl
    943  28000 ????				       if	MACARG5CONST = 1
    944  28000 ????				       adc	#.ByteOffset
    945  28000 ????				       else
    946  28000 ????				       adc	.ByteOffset
    947  28000 ????				       endif
    948  28000 ????				       asl
    949  28000 ????				       asl
    950  28000 ????				       if	MACARG5CONST = 1
    951  28000 ????				       adc	#.ByteOffset
    952  28000 ????				       else
    953  28000 ????				       adc	.ByteOffset
    954  28000 ????				       endif
    955  28000 ????				       endif
    956  28000 ????				       if	{1}_width = 14
    957  28000 ????				       asl
    958  28000 ????				       if	MACARG5CONST = 1
    959  28000 ????				       adc	#.ByteOffset
    960  28000 ????				       else
    961  28000 ????				       adc	.ByteOffset
    962  28000 ????				       endif
    963  28000 ????				       asl
    964  28000 ????				       if	MACARG5CONST = 1
    965  28000 ????				       adc	#.ByteOffset
    966  28000 ????				       else
    967  28000 ????				       adc	.ByteOffset
    968  28000 ????				       endif
    969  28000 ????				       asl
    970  28000 ????				       endif
    971  28000 ????				       if	{1}_width = 15
    972  28000 ????				       asl
    973  28000 ????				       if	MACARG5CONST = 1
    974  28000 ????				       adc	#.ByteOffset
    975  28000 ????				       else
    976  28000 ????				       adc	.ByteOffset
    977  28000 ????				       endif
    978  28000 ????				       asl
    979  28000 ????				       if	MACARG5CONST = 1
    980  28000 ????				       adc	#.ByteOffset
    981  28000 ????				       else
    982  28000 ????				       adc	.ByteOffset
    983  28000 ????				       endif
    984  28000 ????				       asl
    985  28000 ????				       if	MACARG5CONST = 1
    986  28000 ????				       adc	#.ByteOffset
    987  28000 ????				       else
    988  28000 ????				       adc	.ByteOffset
    989  28000 ????				       endif
    990  28000 ????				       endif
    991  28000 ????				       if	{1}_width = 16
    992  28000 ????				       asl
    993  28000 ????				       asl
    994  28000 ????				       asl
    995  28000 ????				       asl
    996  28000 ????				       endif
    997  28000 ????				       adc	#<.GFXLabel	; carry is clear via previous asl or asr
    998  28000 ????				       else
    999  28000 ????				       lda	#<.GFXLabel	; carry is clear via previous asl or asr
   1000  28000 ????				       endif		; .ByteOffset
   1001  28000 ????				       sta	(dlpnt),y	; #1 - low byte object address
   1002  28000 ????
   1003  28000 ????				       iny
   1004  28000 ????
   1005  28000 ????				       if	MACARG2CONST = 1
   1006  28000 ????				       lda	#({1}_width_twoscompliment | (.Palette * 32))
   1007  28000 ????				       else
   1008  28000 ????				       lda	#({1}_width_twoscompliment)
   1009  28000 ????				       ora	.Palette
   1010  28000 ????				       endif
   1011  28000 ????				       sta	(dlpnt),y	; #2 - palette|width
   1012  28000 ????
   1013  28000 ????				       iny
   1014  28000 ????				       if	MACARG4CONST = 0
   1015  28000 ????				       lda	.SpriteY
   1016  28000 ????				       else
   1017  28000 ????				       lda	#.SpriteY
   1018  28000 ????				       endif
   1019  28000 ????				       and	#(WZONEHEIGHT - 1)
   1020  28000 ????				       cmp	#1	; clear carry if our sprite is just in this zone
   1021  28000 ????				       ora	#>.GFXLabel
   1022  28000 ????				       sta	(dlpnt),y	; #3 - hi byte object address
   1023  28000 ????
   1024  28000 ????				       iny
   1025  28000 ????				       if	MACARG3CONST = 1
   1026  28000 ????				       lda	#.SpriteX
   1027  28000 ????				       else
   1028  28000 ????				       lda	.SpriteX
   1029  28000 ????				       endif
   1030  28000 ????				       sta	(dlpnt),y	; #4 - x object position
   1031  28000 ????
   1032  28000 ????				       iny
   1033  28000 ????				       sty	dlend,x
   1034  28000 ????
   1035  28000 ????				       ifconst	ALWAYSTERMINATE
   1036  28000 ????				       iny
   1037  28000 ????				       lda	#0
   1038  28000 ????				       sta	(dlpnt),y
   1039  28000 ????				       endif
   1040  28000 ????
   1041  28000 ????				       bcc	.PLOTSPRITEend
   1042  28000 ????
   1043  28000 ????			    .PLOTSPRITEnext
   1044  28000 ????				       inx		; next zone
   1045  28000 ????
   1046  28000 ????				       cpx	#WZONECOUNT
   1047  28000 ????				       bcs	.PLOTSPRITEend
   1048  28000 ????						; carry is clear
   1049  28000 ????				       ifconst	VSCROLL
   1050  28000 ????				       ldy	Xx3,x
   1051  28000 ????				       lda	DLLMEM+11,y
   1052  28000 ????				       else		; !VSCROLL
   1053  28000 ????				       lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
   1054  28000 ????				       endif		; !VSCROLL
   1055  28000 ????				       ifconst	DOUBLEBUFFER
   1056  28000 ????				       adc	doublebufferdloffset
   1057  28000 ????				       endif		; DOUBLEBUFFER
   1058  28000 ????				       sta	dlpnt
   1059  28000 ????				       ifconst	VSCROLL
   1060  28000 ????				       lda	DLLMEM+10,y
   1061  28000 ????				       else		; !VSCROLL
   1062  28000 ????				       lda	DLPOINTH,x
   1063  28000 ????				       endif		; !VSCROLL
   1064  28000 ????				       ifconst	DOUBLEBUFFER
   1065  28000 ????				       adc	#0
   1066  28000 ????				       endif		; DOUBLEBUFFER
   1067  28000 ????				       sta	dlpnt+1
   1068  28000 ????
   1069  28000 ????				       ldy	dlend,x	; find the next new object position in this zone
   1070  28000 ????
   1071  28000 ????				       ifconst	.ByteOffset
   1072  28000 ????
   1073  28000 ????				       if	MACARG5CONST = 1
   1074  28000 ????				       lda	#.ByteOffset
   1075  28000 ????				       else
   1076  28000 ????				       lda	.ByteOffset
   1077  28000 ????				       endif
   1078  28000 ????				       if	{1}_width = 1
   1079  28000 ????				       clc
   1080  28000 ????				       endif
   1081  28000 ????				       if	{1}_width = 2
   1082  28000 ????				       asl		; carry clear
   1083  28000 ????				       endif
   1084  28000 ????				       if	{1}_width = 3
   1085  28000 ????				       asl		; carry clear
   1086  28000 ????				       if	MACARG5CONST = 1
   1087  28000 ????				       adc	#.ByteOffset
   1088  28000 ????				       else
   1089  28000 ????				       adc	.ByteOffset
   1090  28000 ????				       endif
   1091  28000 ????				       endif
   1092  28000 ????				       if	{1}_width = 4
   1093  28000 ????				       asl		; carry clear
   1094  28000 ????				       asl
   1095  28000 ????				       endif
   1096  28000 ????				       if	{1}_width = 5
   1097  28000 ????				       asl		; carry clear
   1098  28000 ????				       asl
   1099  28000 ????				       if	MACARG5CONST = 1
   1100  28000 ????				       adc	#.ByteOffset
   1101  28000 ????				       else
   1102  28000 ????				       adc	.ByteOffset
   1103  28000 ????				       endif
   1104  28000 ????				       endif
   1105  28000 ????				       if	{1}_width = 6
   1106  28000 ????				       asl		; carry clear
   1107  28000 ????				       if	MACARG5CONST = 1
   1108  28000 ????				       adc	#.ByteOffset
   1109  28000 ????				       else
   1110  28000 ????				       adc	.ByteOffset
   1111  28000 ????				       endif
   1112  28000 ????
   1113  28000 ????				       asl
   1114  28000 ????				       endif
   1115  28000 ????				       if	{1}_width = 7
   1116  28000 ????				       asl		; carry clear
   1117  28000 ????				       if	MACARG5CONST = 1
   1118  28000 ????				       adc	#.ByteOffset
   1119  28000 ????				       else
   1120  28000 ????				       adc	.ByteOffset
   1121  28000 ????				       endif
   1122  28000 ????				       asl
   1123  28000 ????				       endif
   1124  28000 ????				       if	{1}_width = 8
   1125  28000 ????				       asl		; carry clear
   1126  28000 ????				       asl
   1127  28000 ????				       asl
   1128  28000 ????				       endif
   1129  28000 ????				       if	{1}_width = 9
   1130  28000 ????				       asl		; carry clear
   1131  28000 ????				       asl
   1132  28000 ????				       asl
   1133  28000 ????				       if	MACARG5CONST = 1
   1134  28000 ????				       adc	#.ByteOffset
   1135  28000 ????				       else
   1136  28000 ????				       adc	.ByteOffset
   1137  28000 ????				       endif
   1138  28000 ????				       endif
   1139  28000 ????				       if	{1}_width = 10
   1140  28000 ????				       asl		; carry clear
   1141  28000 ????				       asl
   1142  28000 ????				       if	MACARG5CONST = 1
   1143  28000 ????				       adc	#.ByteOffset
   1144  28000 ????				       else
   1145  28000 ????				       adc	.ByteOffset
   1146  28000 ????				       endif
   1147  28000 ????				       asl
   1148  28000 ????				       endif
   1149  28000 ????				       if	{1}_width = 11
   1150  28000 ????				       asl		; carry clear
   1151  28000 ????				       asl
   1152  28000 ????				       if	MACARG5CONST = 1
   1153  28000 ????				       adc	#.ByteOffset
   1154  28000 ????				       else
   1155  28000 ????				       adc	.ByteOffset
   1156  28000 ????				       endif
   1157  28000 ????				       asl
   1158  28000 ????				       if	MACARG5CONST = 1
   1159  28000 ????				       adc	#.ByteOffset
   1160  28000 ????				       else
   1161  28000 ????				       adc	.ByteOffset
   1162  28000 ????				       endif
   1163  28000 ????				       endif
   1164  28000 ????				       if	{1}_width = 12
   1165  28000 ????				       asl		; carry clear
   1166  28000 ????				       if	MACARG5CONST = 1
   1167  28000 ????				       adc	#.ByteOffset
   1168  28000 ????				       else
   1169  28000 ????				       adc	.ByteOffset
   1170  28000 ????				       endif
   1171  28000 ????				       asl
   1172  28000 ????				       asl
   1173  28000 ????				       endif
   1174  28000 ????				       if	{1}_width = 13
   1175  28000 ????				       asl		; carry clear
   1176  28000 ????				       if	MACARG5CONST = 1
   1177  28000 ????				       adc	#.ByteOffset
   1178  28000 ????				       else
   1179  28000 ????				       adc	.ByteOffset
   1180  28000 ????				       endif
   1181  28000 ????				       asl
   1182  28000 ????				       asl
   1183  28000 ????				       if	MACARG5CONST = 1
   1184  28000 ????				       adc	#.ByteOffset
   1185  28000 ????				       else
   1186  28000 ????				       adc	.ByteOffset
   1187  28000 ????				       endif
   1188  28000 ????				       endif
   1189  28000 ????				       if	{1}_width = 14
   1190  28000 ????				       asl		; carry clear
   1191  28000 ????				       if	MACARG5CONST = 1
   1192  28000 ????				       adc	#.ByteOffset
   1193  28000 ????				       else
   1194  28000 ????				       adc	.ByteOffset
   1195  28000 ????				       endif
   1196  28000 ????				       asl
   1197  28000 ????				       if	MACARG5CONST = 1
   1198  28000 ????				       adc	#.ByteOffset
   1199  28000 ????				       else
   1200  28000 ????				       adc	.ByteOffset
   1201  28000 ????				       endif
   1202  28000 ????				       asl
   1203  28000 ????				       endif
   1204  28000 ????				       if	{1}_width = 15
   1205  28000 ????				       asl
   1206  28000 ????				       if	MACARG5CONST = 1
   1207  28000 ????				       adc	#.ByteOffset
   1208  28000 ????				       else
   1209  28000 ????				       adc	.ByteOffset
   1210  28000 ????				       endif
   1211  28000 ????				       asl
   1212  28000 ????				       if	MACARG5CONST = 1
   1213  28000 ????				       adc	#.ByteOffset
   1214  28000 ????				       else
   1215  28000 ????				       adc	.ByteOffset
   1216  28000 ????				       endif
   1217  28000 ????				       asl
   1218  28000 ????				       if	MACARG5CONST = 1
   1219  28000 ????				       adc	#.ByteOffset
   1220  28000 ????				       else
   1221  28000 ????				       adc	.ByteOffset
   1222  28000 ????				       endif
   1223  28000 ????				       endif
   1224  28000 ????				       if	{1}_width = 16
   1225  28000 ????				       asl
   1226  28000 ????				       asl
   1227  28000 ????				       asl
   1228  28000 ????				       asl
   1229  28000 ????				       endif
   1230  28000 ????				       adc	#<.GFXLabel
   1231  28000 ????				       else
   1232  28000 ????				       lda	#<.GFXLabel
   1233  28000 ????				       endif		; .ByteOffset
   1234  28000 ????				       sta	(dlpnt),y	; #1 - low byte object address
   1235  28000 ????
   1236  28000 ????				       iny
   1237  28000 ????				       if	MACARG2CONST = 1
   1238  28000 ????				       lda	#({1}_width_twoscompliment | (.Palette * 32))
   1239  28000 ????				       else
   1240  28000 ????				       lda	#({1}_width_twoscompliment)
   1241  28000 ????				       ora	.Palette
   1242  28000 ????				       endif
   1243  28000 ????
   1244  28000 ????				       sta	(dlpnt),y	; #2 - palette|width
   1245  28000 ????
   1246  28000 ????				       iny
   1247  28000 ????				       if	MACARG4CONST = 0
   1248  28000 ????				       lda	.SpriteY
   1249  28000 ????				       else
   1250  28000 ????				       lda	#.SpriteY
   1251  28000 ????				       endif
   1252  28000 ????				       and	#(WZONEHEIGHT - 1)
   1253  28000 ????				       ora	#>(.GFXLabel - (WZONEHEIGHT * 256))	; start in the dma hole
   1254  28000 ????				       sta	(dlpnt),y	; #3 - hi byte object address
   1255  28000 ????
   1256  28000 ????				       iny
   1257  28000 ????				       if	MACARG3CONST = 1
   1258  28000 ????				       lda	#.SpriteX
   1259  28000 ????				       else
   1260  28000 ????				       lda	.SpriteX
   1261  28000 ????				       endif
   1262  28000 ????				       sta	(dlpnt),y	; #4 - x object position
   1263  28000 ????
   1264  28000 ????				       iny
   1265  28000 ????				       sty	dlend,x
   1266  28000 ????
   1267  28000 ????				       ifconst	ALWAYSTERMINATE
   1268  28000 ????				       iny
   1269  28000 ????				       lda	#0
   1270  28000 ????				       sta	(dlpnt),y
   1271  28000 ????				       endif
   1272  28000 ????
   1273  28000 ????			    .PLOTSPRITEend
   1274  28000 ????				       ENDM
   1275  28000 ????
   1276  28000 ????				       MAC	scrollsetup
   1277  28000 ????
   1278  28000 ????						; If vertical scrolling is enabled...
   1279  28000 ????						;   * Fills the DLs with hidden masking sprites.
   1280  28000 ????						; Adds blank sprites to the DLs to fill the screen.
   1281  28000 ????						; If horizontal scrolling is enabled...
   1282  28000 ????						;   * Adds another blank DL off-screen
   1283  28000 ????
   1284  28000 ????						; {1} - constant - the first dl of the scrolling area
   1285  28000 ????						; {2} - symbol   - blank tile label
   1286  28000 ????
   1287  28000 ????						; *** clear the saved dl ending for scrolling zones...
   1288  28000 ????				       ldx	#{1}
   1289  28000 ????				       lda	#0
   1290  28000 ????			    .scrollcleardls
   1291  28000 ????				       sta	dlend,x
   1292  28000 ????				       inx
   1293  28000 ????				       cpx	#WZONECOUNT
   1294  28000 ????				       bne	.scrollcleardls
   1295  28000 ????
   1296  28000 ????				       ifconst	VSCROLL
   1297  28000 ????						; *** adjust the ending for our mask dl to allow for mask objects...
   1298  28000 ????				       dex
   1299  28000 ????				       lda	#(maskscrollspriteend-maskscrollsprite)
   1300  28000 ????				       sta	dlend,x
   1301  28000 ????
   1302  28000 ????						; *** Add 4x dma masking objects to last zone...
   1303  28000 ????				       ldx	#(maskscrollspriteend-maskscrollsprite-1)
   1304  28000 ????			    .scrollpopulateloop1
   1305  28000 ????				       lda	maskscrollsprite,x
   1306  28000 ????				       sta	LASTZONEADDRESS+0,x
   1307  28000 ????				       ifconst	DOUBLEBUFFER
   1308  28000 ????				       sta	LASTZONEADDRESS+0+DOUBLEBUFFEROFFSET,x
   1309  28000 ????				       endif		; DOUBLEBUFFER
   1310  28000 ????				       dex
   1311  28000 ????				       bpl	.scrollpopulateloop1
   1312  28000 ????				       inx		; x=0
   1313  28000 ????				       stx	finescrolly
   1314  28000 ????				       endif		; VSCROLL
   1315  28000 ????
   1316  28000 ????						; *** Add blank sprite-tile objects to the scrolling zones...
   1317  28000 ????			    PLOTSP4    =	1	; ensure we use 4 byte sprites
   1318  28000 ????
   1319  28000 ????						; convert byte width of the sprit to coordinate width...
   1320  28000 ????				       if	{2}_mode = 0	; ### 160A, 320A, 320D
   1321  28000 ????			    .scrollXWIDTH SET	({2}_width * 4)	; 4x 160-mode pixels per byte
   1322  28000 ????				       else		; ### 160B, 320B, 320C
   1323  28000 ????			    .scrollXWIDTH SET	({2}_width * 2)	; 2x 160-mode pixels per byte
   1324  28000 ????				       endif
   1325  28000 ????
   1326  28000 ????						; figure out how many sprites we need to fill a screen width...
   1327  28000 ????			    .scrollSPRITECOuNT SET	((160+.scrollXWIDTH-1)/.scrollXWIDTH)
   1328  28000 ????				       ifconst	HSCROLL
   1329  28000 ????			    .scrollSPRITECOuNT SET	(.scrollSPRITECOuNT+1)
   1330  28000 ????				       endif		; HSCROLL
   1331  28000 ????
   1332  28000 ????						; setup plotsprite4 parameters...
   1333  28000 ????				       lda	#<{2}
   1334  28000 ????				       sta	temp1
   1335  28000 ????				       lda	#>{2}
   1336  28000 ????				       sta	temp2
   1337  28000 ????				       lda	#{2}_width_twoscompliment
   1338  28000 ????				       sta	temp3	; width
   1339  28000 ????
   1340  28000 ????				       lda	#{1}
   1341  28000 ????				       asl
   1342  28000 ????				       asl
   1343  28000 ????				       asl
   1344  28000 ????				       if	WZONEHEIGHT
   1345  28000 ????				       asl
   1346  28000 ????				       endif
   1347  28000 ????				       sta	temp5	; Y
   1348  28000 ????			    .scrollpopulateloop2
   1349  28000 ????				       lda	#0
   1350  28000 ????				       sta	temp4	; X
   1351  28000 ????			    .scrollpopulateloop3
   1352  28000 ????				       jsr	skipplotsprite4wait
   1353  28000 ????				       lda	temp4	; X
   1354  28000 ????				       clc
   1355  28000 ????				       adc	#.scrollXWIDTH
   1356  28000 ????				       sta	temp4	; X
   1357  28000 ????				       cmp	#(.scrollSPRITECOuNT*.scrollXWIDTH)
   1358  28000 ????				       bne	.scrollpopulateloop3
   1359  28000 ????				       lda	temp5	; Y
   1360  28000 ????				       clc
   1361  28000 ????				       adc	#WZONEHEIGHT
   1362  28000 ????				       sta	temp5	; Y
   1363  28000 ????				       cmp	#((WZONECOUNT*WZONEHEIGHT)+WZONEHEIGHT)
   1364  28000 ????				       bne	.scrollpopulateloop2
   1365  28000 ????				       ENDM
   1366  28000 ????
   1367  28000 ????				       MAC	sizeof
   1368  28000 ????
   1369  28000 ????						; echoes the size difference between the current address and the
   1370  28000 ????						; a label that was passed as an argument. This is a quick way to
   1371  28000 ????						; determine the size of a structure.
   1372  28000 ????
   1373  28000 ????			    .NAME      SETSTR	{1}
   1374  28000 ????				       echo	" The Size of",.NAME,"is:",[* - {1}]d,[* - {2}]d,"bytes."
   1375  28000 ????				       ENDM
   1376  28000 ????
   1377  28000 ????						;
   1378  28000 ????						; speakjet.inc
   1379  28000 ????						;
   1380  28000 ????						;
   1381  28000 ????						; AtariVox Speech Synth Driver
   1382  28000 ????						;
   1383  28000 ????						; By Alex Herbert, 2004
   1384  28000 ????						;
   1385  28000 ????
   1386  28000 ????
   1387  28000 ????
   1388  28000 ????
   1389  28000 ????						; Constants
   1390  28000 ????
   1391  28000 ????
   1392  28000 ????		00 01	    SERIAL_OUTMASK equ	$01
   1393  28000 ????		00 02	    SERIAL_RDYMASK equ	$02
   1394  28000 ????
   1395  28000 ????
   1396  28000 ????
   1397  28000 ????						; Macros
   1398  28000 ????
   1399  28000 ????				       mac	spkout
   1400  28000 ????
   1401  28000 ????						; check buffer-full status
   1402  28000 ????				       lda	SWCHA
   1403  28000 ????				       and	#SERIAL_RDYMASK
   1404  28000 ????				       beq	.speech_done
   1405  28000 ????
   1406  28000 ????						; get next speech byte
   1407  28000 ????				       ldy	#$00
   1408  28000 ????				       lda	(speech_addr),y
   1409  28000 ????
   1410  28000 ????						; invert data and check for end of string
   1411  28000 ????				       eor	#$ff
   1412  28000 ????						;sta BACKGRND ; debug - uncomment to flash the background color with vox data
   1413  28000 ????				       beq	.speech_done
   1414  28000 ????				       sta	{1}
   1415  28000 ????
   1416  28000 ????						; increment speech pointer
   1417  28000 ????				       inc	speech_addr
   1418  28000 ????				       bne	.incaddr_skip
   1419  28000 ????				       inc	speech_addr+1
   1420  28000 ????			    .incaddr_skip
   1421  28000 ????
   1422  28000 ????						; output byte as serial data
   1423  28000 ????
   1424  28000 ????				       sec		; start bit
   1425  28000 ????			    .byteout_loop
   1426  28000 ????						; put carry flag into bit 0 of SWACNT, preserving other bits
   1427  28000 ????				       lda	SWACNT	; 4
   1428  28000 ????				       and	#$fe	; 2 6
   1429  28000 ????				       adc	#$00	; 2 8
   1430  28000 ????				       sta	SWACNT	; 4 12
   1431  28000 ????
   1432  28000 ????						; 10 bits sent? (1 start bit, 8 data bits, 1 stop bit)
   1433  28000 ????				       cpy	#$09	; 2 14
   1434  28000 ????				       beq	.speech_done	; 2 16
   1435  28000 ????				       iny		; 2 18
   1436  28000 ????
   1437  28000 ????						; the 7800 is 1.5x faster than the 2600. Waste more cycles here
   1438  28000 ????						; to match the original baud rate...
   1439  28000 ????						;ldx	  #$07 ; 2600
   1440  28000 ????				       ldx	#$0D
   1441  28000 ????
   1442  28000 ????			    .delay_loop
   1443  28000 ????				       dex		; 
   1444  28000 ????				       bne	.delay_loop	; 36 54
   1445  28000 ????
   1446  28000 ????						; shift next data bit into carry
   1447  28000 ????				       lsr	{1}	; 5 59
   1448  28000 ????
   1449  28000 ????						; and loop (branch always taken)
   1450  28000 ????				       bpl	.byteout_loop	; 3 62 cycles for loop
   1451  28000 ????
   1452  28000 ????			    .speech_done
   1453  28000 ????
   1454  28000 ????				       endm
   1455  28000 ????
   1456  28000 ????
   1457  28000 ????				       mac	speak
   1458  28000 ????
   1459  28000 ????				       lda	#<{1}
   1460  28000 ????				       sta	speech_addr
   1461  28000 ????				       lda	#>{1}
   1462  28000 ????				       sta	speech_addr+1
   1463  28000 ????
   1464  28000 ????				       endm
   1465  28000 ????
   1466  28000 ????
   1467  28000 ????
   1468  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
   1469  28000 ????
   1470  28000 ????				       processor	6502
   1471  28000 ????
------- FILE 7800basic.h LEVEL 2 PASS 3
      0  28000 ????				       include	"7800basic.h"
      1  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  28000 ????
      3  28000 ????				       processor	6502
------- FILE 7800.h LEVEL 3 PASS 3
      0  28000 ????				       include	"7800.h"
      1  28000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  28000 ????
      3  28000 ????						; 7800.h
      4  28000 ????						; Version 1.0, 2019/12/13
      5  28000 ????
      6  28000 ????						; This file defines hardware registers and memory mapping for the
      7  28000 ????						; Atari 7800. It is distributed as a companion machine-specific support package
      8  28000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  28000 ????						; available at https://github.com/dasm-assembler/dasm
     10  28000 ????
     11  28000 ????
     12  28000 ????						; ******************** 7800 Hardware Addresses ***************************
     13  28000 ????						;
     14  28000 ????						;	 MEMORY MAP USAGE OF THE 7800
     15  28000 ????						;
     16  28000 ????						;	  00 -   1F	TIA REGISTERS
     17  28000 ????						;	  20 -   3F	MARIA REGISTERS
     18  28000 ????						;	  40 -   FF	RAM block 0 (zero page)
     19  28000 ????						;	 100 -  11F	TIA   (mirror of 0000-001f)
     20  28000 ????						;	 120 -  13F	MARIA (mirror of 0020-003f)
     21  28000 ????						;	 140 -  1FF	RAM block 1 (stack)
     22  28000 ????						;	 200 -  21F	TIA   (mirror of 0000-001f)
     23  28000 ????						;	 220 -  23F	MARIA (mirror of 0020-003f)
     24  28000 ????						;	 240 -  27F	???
     25  28000 ????						;	 280 -  2FF	RIOT I/O ports and timers
     26  28000 ????						;	 300 -  31F	TIA   (mirror of 0000-001f)
     27  28000 ????						;	 320 -  33F	MARIA (mirror of 0020-003f)
     28  28000 ????						;	 340 -  3FF	???
     29  28000 ????						;	 400 -  47F	unused address space
     30  28000 ????						;	 480 -  4FF	RIOT RAM
     31  28000 ????						;	 500 -  57F	unused address space
     32  28000 ????						;	 580 -  5FF	RIOT RAM (mirror of 0480-04ff)
     33  28000 ????						;	 600 - 17FF	unused address space
     34  28000 ????						;	1800 - 203F	RAM
     35  28000 ????						;	2040 - 20FF	RAM block 0 (mirror of 0000-001f)
     36  28000 ????						;	2100 - 213F	RAM
     37  28000 ????						;	2140 - 21FF	RAM block 1 (mirror of 0140-01ff)
     38  28000 ????						;	2200 - 27FF	RAM
     39  28000 ????						;	2800 - 2FFF	unavailable to external devices (bios bus-conflict)
     40  28000 ????						;	3000 - 3FFF	unused address space
     41  28000 ????						;	4000 - FF7F	potential cartridge address space
     42  28000 ????						;	FF80 - FFF9	RESERVED FOR ENCRYPTION
     43  28000 ????						;	FFFA - FFFF	6502 VECTORS
     44  28000 ????
     45  28000 ????
     46  28000 ????						;****** 00-1F ********* TIA REGISTERS ******************
     47  28000 ????
     48  28000 ????		00 01	    INPTCTRL   =	$01	;Input control. In same address space as TIA. write-only
     49  28000 ????		00 01	    VBLANK     =	$01	;VBLANK. D7=1:dump paddle caps to ground.     write-only
     50  28000 ????		00 02	    _WSYNC     =	$02	;Wait for HSync			       write-only
     51  28000 ????		00 03	    _RSYNC     =	$03	;Reset HSync				       write-only
     52  28000 ????		00 08	    INPT0      =	$08	;Paddle Control Input 0		       read-only
     53  28000 ????		00 09	    INPT1      =	$09	;Paddle Control Input 1		       read-only
     54  28000 ????		00 0a	    INPT2      =	$0A	;Paddle Control Input 2		       read-only
     55  28000 ????		00 0b	    INPT3      =	$0B	;Paddle Control Input 3		       read-only
     56  28000 ????
     57  28000 ????						; ** some common alternate names for INPT0/1/2/3
     58  28000 ????		00 08	    INPT4B     =	$08	;Joystick 0 Fire 1			       read-only
     59  28000 ????		00 09	    INPT4A     =	$09	;Joystick 0 Fire 1			       read-only
     60  28000 ????		00 0a	    INPT5B     =	$0A	;Joystick 1 Fire 0			       read-only
     61  28000 ????		00 0b	    INPT5A     =	$0B	;Joystick 1 Fire 1			       read-only
     62  28000 ????		00 08	    INPT4R     =	$08	;Joystick 0 Fire 1			       read-only
     63  28000 ????		00 09	    INPT4L     =	$09	;Joystick 0 Fire 1			       read-only
     64  28000 ????		00 0a	    INPT5R     =	$0A	;Joystick 1 Fire 0			       read-only
     65  28000 ????		00 0b	    INPT5L     =	$0B	;Joystick 1 Fire 1			       read-only
     66  28000 ????
     67  28000 ????		00 0c	    INPT4      =	$0C	;Player 0 Fire Button Input		       read-only
     68  28000 ????		00 0d	    INPT5      =	$0D	;Player 1 Fire Button Input		       read-only
     69  28000 ????
     70  28000 ????		00 15	    AUDC0      =	$15	;Audio Control Channel   0		       write-only
     71  28000 ????		00 16	    AUDC1      =	$16	;Audio Control Channel   1		       write-only
     72  28000 ????		00 17	    AUDF0      =	$17	;Audio Frequency Channel 0		       write-only
     73  28000 ????		00 18	    AUDF1      =	$18	;Audio Frequency Channel 1		       write-only
     74  28000 ????		00 19	    AUDV0      =	$19	;Audio Volume Channel	  0		       write-only
     75  28000 ????		00 1a	    AUDV1      =	$1A	;Audio Volume Channel	  1		       write-only
     76  28000 ????
     77  28000 ????						;****** 20-3F ********* MARIA REGISTERS ***************
     78  28000 ????
     79  28000 ????		00 20	    BACKGRND   =	$20	;Background Color			       write-only
     80  28000 ????		00 21	    P0C1       =	$21	;Palette 0 - Color 1			       write-only
     81  28000 ????		00 22	    P0C2       =	$22	;Palette 0 - Color 2			       write-only
     82  28000 ????		00 23	    P0C3       =	$23	;Palette 0 - Color 3			       write-only
     83  28000 ????		00 24	    WSYNC      =	$24	;Wait For Sync 			       write-only
     84  28000 ????		00 25	    P1C1       =	$25	;Palette 1 - Color 1			       write-only
     85  28000 ????		00 26	    P1C2       =	$26	;Palette 1 - Color 2			       write-only
     86  28000 ????		00 27	    P1C3       =	$27	;Palette 1 - Color 3			       write-only
     87  28000 ????		00 28	    MSTAT      =	$28	;Maria Status				       read-only
     88  28000 ????		00 29	    P2C1       =	$29	;Palette 2 - Color 1			       write-only
     89  28000 ????		00 2a	    P2C2       =	$2A	;Palette 2 - Color 2			       write-only
     90  28000 ????		00 2b	    P2C3       =	$2B	;Palette 2 - Color 3			       write-only
     91  28000 ????		00 2c	    DPPH       =	$2C	;Display List List Pointer High	       write-only
     92  28000 ????		00 2d	    P3C1       =	$2D	;Palette 3 - Color 1			       write-only
     93  28000 ????		00 2e	    P3C2       =	$2E	;Palette 3 - Color 2			       write-only
     94  28000 ????		00 2f	    P3C3       =	$2F	;Palette 3 - Color 3			       write-only
     95  28000 ????		00 30	    DPPL       =	$30	;Display List List Pointer Low 	       write-only
     96  28000 ????		00 31	    P4C1       =	$31	;Palette 4 - Color 1			       write-only
     97  28000 ????		00 32	    P4C2       =	$32	;Palette 4 - Color 2			       write-only
     98  28000 ????		00 33	    P4C3       =	$33	;Palette 4 - Color 3			       write-only
     99  28000 ????		00 34	    CHARBASE   =	$34	;Character Base Address		       write-only
    100  28000 ????		00 34	    CHBASE     =	$34	;Character Base Address		       write-only
    101  28000 ????		00 35	    P5C1       =	$35	;Palette 5 - Color 1			       write-only
    102  28000 ????		00 36	    P5C2       =	$36	;Palette 5 - Color 2			       write-only
    103  28000 ????		00 37	    P5C3       =	$37	;Palette 5 - Color 3			       write-only
    104  28000 ????		00 38	    OFFSET     =	$38	;Unused - Store zero here		       write-only
    105  28000 ????		00 39	    P6C1       =	$39	;Palette 6 - Color 1			       write-only
    106  28000 ????		00 3a	    P6C2       =	$3A	;Palette 6 - Color 2			       write-only
    107  28000 ????		00 3b	    P6C3       =	$3B	;Palette 6 - Color 3			       write-only
    108  28000 ????		00 3c	    CTRL       =	$3C	;Maria Control Register		       write-only
    109  28000 ????		00 3d	    P7C1       =	$3D	;Palette 7 - Color 1			       write-only
    110  28000 ????		00 3e	    P7C2       =	$3E	;Palette 7 - Color 2			       write-only
    111  28000 ????		00 3f	    P7C3       =	$3F	;Palette 7 - Color 3			       write-only
    112  28000 ????
    113  28000 ????
    114  28000 ????						;****** 280-2FF ******* PIA PORTS AND TIMERS ************
    115  28000 ????
    116  28000 ????		02 80	    SWCHA      =	$280	;P0+P1 Joystick Directional Input	       read-write
    117  28000 ????		02 81	    CTLSWA     =	$281	;I/O Control for SCHWA 		       read-write
    118  28000 ????		02 81	    SWACNT     =	$281	;VCS name for above			       read-write
    119  28000 ????		02 82	    SWCHB      =	$282	;Console Switches			       read-write
    120  28000 ????		02 83	    CTLSWB     =	$283	;I/O Control for SCHWB 		       read-write
    121  28000 ????		02 83	    SWBCNT     =	$283	;VCS name for above			       read-write
    122  28000 ????		02 84	    INTIM      =	$284	;Interval Timer Read			       read-only
    123  28000 ????		02 85	    TIMINT     =	$285	;Interval Timer Interrupt		       read-only
    124  28000 ????
    125  28000 ????		02 94	    TIM1T      =	$294	;Set 1    CLK Interval (838   nsec/interval)  write-only
    126  28000 ????		02 95	    TIM8T      =	$295	;Set 8    CLK Interval (6.7   usec/interval)  write-only
    127  28000 ????		02 96	    TIM64T     =	$296	;Set 64   CLK Interval (63.6  usec/interval)  write-only
    128  28000 ????		02 97	    T1024T     =	$297	;Set 1024 CLK Interval (858.2 usec/interval)  write-only
    129  28000 ????		02 9e	    TIM64TI    =	$29E	;Interrupt timer 64T			       write-only
    130  28000 ????
    131  28000 ????						;XM
    132  28000 ????		04 70	    XCTRL      =	$470	; 7=YM2151 6=RAM@6k 5=RAM@4k 4=pokey@450 3=hsc 2=cart 1=RoF_bank1 0=RoF_bank2
    133  28000 ????		04 70	    XCTRL1     =	$470
    134  28000 ????		04 78	    XCTRL2     =	$478
    135  28000 ????		04 7c	    XCTRL3     =	$47c
    136  28000 ????		04 71	    XCTRL4     =	$471
    137  28000 ????		04 72	    XCTRL5     =	$472
    138  28000 ????
    139  28000 ????						; Pokey register relative locations, since its base may be different
    140  28000 ????						; depending on the hardware.
    141  28000 ????		00 00	    PAUDF0     =	$0	; extra audio channels and frequencies
    142  28000 ????		00 01	    PAUDC0     =	$1
    143  28000 ????		00 02	    PAUDF1     =	$2
    144  28000 ????		00 03	    PAUDC1     =	$3
    145  28000 ????		00 04	    PAUDF2     =	$4
    146  28000 ????		00 05	    PAUDC2     =	$5
    147  28000 ????		00 06	    PAUDF3     =	$6
    148  28000 ????		00 07	    PAUDC3     =	$7
    149  28000 ????		00 08	    PAUDCTL    =	$8	; Audio Control
    150  28000 ????		00 09	    PSTIMER    =	$9
    151  28000 ????		00 0a	    PRANDOM    =	$A	; 17 bit polycounter pseudo random
    152  28000 ????		00 0f	    PSKCTL     =	$F	; Serial Port control
------- FILE 7800basic.h
------- FILE 7800basic_variable_redefs.h LEVEL 3 PASS 3
      0  28000 ????				       include	"7800basic_variable_redefs.h"
      1  28000 ????						; This file contains variable mapping and other information for the current project.
      2  28000 ????
      3  28000 ????		00 00	    missle_mode =	$00
      4  28000 ????		00 1c	    missle_width_twoscompliment =	$1c
      5  28000 ????		00 04	    missle_width =	$04
      6  28000 ????		00 00	    player_mode =	$00
      7  28000 ????		00 1c	    player_width_twoscompliment =	$1c
      8  28000 ????		00 04	    player_width =	$04
      9  28000 ????		00 00	    font_mode  =	$00
     10  28000 ????		00 0b	    font_width_twoscompliment =	$0b
     11  28000 ????		00 35	    font_width =	$35
     12  28000 ????		01 49	    starting   =	var9
     13  28000 ????
     14  28000 ????		01 48	    missle_fire_ypos =	var8
     15  28000 ????
     16  28000 ????		01 47	    missle_fire_xpos =	var7
     17  28000 ????
     18  28000 ????		01 46	    playerY    =	var6
     19  28000 ????
     20  28000 ????		01 45	    playerX    =	var5
     21  28000 ????
     22  28000 ????		01 44	    score      =	var4
     23  28000 ????
     24  28000 ????		01 43	    lives      =	var3
     25  28000 ????
     26  28000 ????		01 42	    wait       =	var2
     27  28000 ????
     28  28000 ????		01 41	    bgColor    =	var1
     29  28000 ????
     30  28000 ????		00 00	    missle_color3 =	0
     31  28000 ????		00 37	    missle_color2 =	$37
     32  28000 ????		00 0b	    missle_color1 =	$0b
     33  28000 ????		00 00	    missle_color0 =	$00
     34  28000 ????		00 0f	    player_color1 =	$0f
     35  28000 ????		00 00	    player_color0 =	$00
     36  28000 ????		00 0f	    font_color1 =	$0f
     37  28000 ????		00 00	    font_color0 =	$00
     38  28000 ????		00 08	    bankswitchmode =	8
     39  28000 ????		00 01	    ROM128K    =	1
     40  28000 ????		00 01	    plotvalueonscreen =	1
     41  28000 ????		00 10	    ZONEHEIGHT =	16
     42  28000 ????		00 01	    NTSC       =	1
     43  28000 ????		00 01	    collisionwrap =	1
------- FILE 7800basic.h
      6  28000 ????
      7  28000 ????						;************ 7800 overall RAM map **************
      8  28000 ????
      9  28000 ????						;	   40-FF	 zero page RAM
     10  28000 ????						;	  140-1FF	 RAM (stack)
     11  28000 ????						;	 1800-203F	 RAM
     12  28000 ????						;	 2100-213F	 RAM
     13  28000 ????						;	 2200-27FF	 RAM
     14  28000 ????
     15  28000 ????						;************ 7800basic RAM usage map **************
     16  28000 ????
     17  28000 ????						;	   40-FF	 numerous defines, listed below
     18  28000 ????						;	  140-1FF	 RAM (stack)
     19  28000 ????
     20  28000 ????						;	 1800-187F	 DLL  (1800-18DF with page flipping enabled)
     21  28000 ????						;	 1880-1FFF	 DLs  (18E0-1FFF with page flipping enabled)
     22  28000 ????
     23  28000 ????						;	 2000-203F	 Reserved
     24  28000 ????						;	 2100-213F	 Reserved
     25  28000 ????						;	 2200-27FF	 Free
     26  28000 ????
     27  28000 ????		1f e0	    eeprombuffer =	$1FE0
     28  28000 ????		18 00	    DLLMEM     =	$1800
     29  28000 ????		00 70	    DBOFFSET   =	$70	; $E0 length DL is /2 for double-buffering
     30  28000 ????
     31  28000 ????			   -	       ifconst	PLOTVALUEPAGE
     32  28000 ????			   -VALBUFFER  =	(PLOTVALUEPAGE*256)
     33  28000 ????				       else
     34  28000 ????		20 00	    VALBUFFER  =	$2000	; to $203F  ** never let VALBUFFER straddle pages
     35  28000 ????				       endif
     36  28000 ????
     37  28000 ????
     38  28000 ????		21 00	    pausestate =	$2100
     39  28000 ????		21 01	    dlzero     =	$2101	; zero to force end of $2100 DL, which we use in vblank and overscan
     40  28000 ????		21 02	    sINPT1     =	$2102	; save register for joy button joy0
     41  28000 ????		21 03	    sINPT3     =	$2103	; save register for joy button joy1
     42  28000 ????		21 04	    currentbank =	$2104
     43  28000 ????
     44  28000 ????		21 05	    currentrambank =	$2105
     45  28000 ????		21 06	    charactermode =	$2106
     46  28000 ????		21 07	    sCTRL      =	$2107
     47  28000 ????		21 08	    pokeydetected =	$2108
     48  28000 ????		21 09	    paldetected =	$2109
     49  28000 ????		21 0a	    avoxdetected =	$210A
     50  28000 ????		21 0b	    sCHARBASE  =	$210B	; save register for CHARBASE
     51  28000 ????
     52  28000 ????		21 0c	    hsdevice   =	$210C
     53  28000 ????		21 0d	    hsdifficulty =	$210D
     54  28000 ????		21 0e	    hserror    =	$210E
     55  28000 ????		21 0f	    hsgameslot =	$210F
     56  28000 ????		21 10	    hsnewscoreline =	$2110
     57  28000 ????		21 11	    hsnewscorerank =	$2111
     58  28000 ????		21 12	    HSRAMTable =	$2112	; to $212F (30 bytes) Format: III*5, SSS*5
     59  28000 ????		21 12	    HSRAMInitials =	$2112	; see above
     60  28000 ????		21 21	    HSRAMScores =	$2121	; see above
     61  28000 ????
     62  28000 ????		21 31	    sSWCHA     =	$2131
     63  28000 ????						; reserved	 = $2132
     64  28000 ????
     65  28000 ????		21 33	    hsdisplaymode =	$2133
     66  28000 ????		21 34	    gamedifficulty =	$2134
     67  28000 ????		21 35	    hsinitialpos =	$2135
     68  28000 ????		21 36	    hsinitialhold =	$2136
     69  28000 ????		21 37	    hscursorx  =	$2137
     70  28000 ????		21 38	    hsjoydebounce =	$2138
     71  28000 ????		21 39	    hsswcha    =	$2139
     72  28000 ????		21 3a	    hsinpt1    =	$213A
     73  28000 ????		21 3b	    hscolorchaseindex =	$213B
     74  28000 ????		21 3c	    visibleDLLstart =	$213C
     75  28000 ????		21 3d	    overscanDLLstart =	$213D
     76  28000 ????		21 3e	    frameslost =	$213E
     77  28000 ????		21 3f	    hsreturn   =	$213F
     78  28000 ????
     79  28000 ????
     80  28000 ????		00 40	    rand       =	$40
     81  28000 ????		00 41	    rand16     =	$41
     82  28000 ????		00 42	    temp1      =	$42
     83  28000 ????		00 43	    temp2      =	$43
     84  28000 ????		00 44	    temp3      =	$44
     85  28000 ????		00 45	    temp4      =	$45
     86  28000 ????		00 46	    temp5      =	$46
     87  28000 ????		00 47	    temp6      =	$47
     88  28000 ????		00 48	    temp7      =	$48
     89  28000 ????		00 49	    temp8      =	$49
     90  28000 ????		00 4a	    temp9      =	$4a
     91  28000 ????
     92  28000 ????		00 4b	    pokeybase  =	$4b
     93  28000 ????		00 4b	    pokeybaselo =	$4b
     94  28000 ????		00 4c	    pokeybasehi =	$4c
     95  28000 ????
     96  28000 ????		00 4d	    visibleover =	$4d
     97  28000 ????
     98  28000 ????		00 4e	    sfx1pointlo =	$4e
     99  28000 ????		00 4f	    sfx2pointlo =	$4f
    100  28000 ????		00 50	    sfx1pointhi =	$50
    101  28000 ????		00 51	    sfx2pointhi =	$51
    102  28000 ????
    103  28000 ????		00 52	    sfx1priority =	$52
    104  28000 ????		00 53	    sfx2priority =	$53
    105  28000 ????		00 54	    sfx1poffset =	$54
    106  28000 ????		00 55	    sfx2poffset =	$55
    107  28000 ????
    108  28000 ????		00 56	    sfx1frames =	$56
    109  28000 ????		00 57	    sfx2frames =	$57
    110  28000 ????		00 58	    sfx1tick   =	$58
    111  28000 ????		00 59	    sfx2tick   =	$59
    112  28000 ????
    113  28000 ????		00 5a	    tempmath   =	$5a
    114  28000 ????
    115  28000 ????		00 5b	    pokey1pointlo =	$5b
    116  28000 ????		00 5c	    pokey1pointhi =	$5c
    117  28000 ????		00 5d	    pokey2pointlo =	$5d
    118  28000 ????		00 5e	    pokey2pointhi =	$5e
    119  28000 ????		00 5f	    pokey3pointlo =	$5f
    120  28000 ????		00 60	    pokey3pointhi =	$60
    121  28000 ????		00 61	    pokey4pointlo =	$61
    122  28000 ????		00 62	    pokey4pointhi =	$62
    123  28000 ????
    124  28000 ????		00 63	    dlpnt      =	$63	; to $64
    125  28000 ????		00 65	    dlend      =	$65	; to $81 - for 29 possible visible dll entries
    126  28000 ????		00 82	    dlendsave  =	$82	; to $9e - for 29 possible visible dll entries
    127  28000 ????
    128  28000 ????		00 9f	    speech_addr =	$9f
    129  28000 ????		00 a0	    speech_addr_hi =	$a0
    130  28000 ????
    131  28000 ????		00 a1	    HSGameTableLo =	$a1
    132  28000 ????		00 a2	    HSGameTableHi =	$a2
    133  28000 ????		00 a3	    HSVoxHi    =	$a3
    134  28000 ????		00 a4	    HSVoxLo    =	$a4
    135  28000 ????
    136  28000 ????						;channel pointers
    137  28000 ????
    138  28000 ????		00 a5	    songchannel1layer1lo =	$a5
    139  28000 ????		00 a6	    songchannel2layer1lo =	$a6
    140  28000 ????		00 a7	    songchannel3layer1lo =	$a7
    141  28000 ????		00 a8	    songchannel4layer1lo =	$a8
    142  28000 ????
    143  28000 ????		00 a9	    songchannel1layer2lo =	$a9
    144  28000 ????		00 aa	    songchannel2layer2lo =	$aA
    145  28000 ????		00 ab	    songchannel3layer2lo =	$aB
    146  28000 ????		00 ac	    songchannel4layer2lo =	$aC
    147  28000 ????
    148  28000 ????		00 ad	    songchannel1layer3lo =	$aD
    149  28000 ????		00 ae	    songchannel2layer3lo =	$aE
    150  28000 ????		00 af	    songchannel3layer3lo =	$aF
    151  28000 ????		00 b0	    songchannel4layer3lo =	$b0
    152  28000 ????
    153  28000 ????		00 b1	    songchannel1layer1hi =	$b1
    154  28000 ????		00 b2	    songchannel2layer1hi =	$b2
    155  28000 ????		00 b3	    songchannel3layer1hi =	$b3
    156  28000 ????		00 b4	    songchannel4layer1hi =	$b4
    157  28000 ????
    158  28000 ????		00 b5	    songchannel1layer2hi =	$b5
    159  28000 ????		00 b6	    songchannel2layer2hi =	$b6
    160  28000 ????		00 b7	    songchannel3layer2hi =	$b7
    161  28000 ????		00 b8	    songchannel4layer2hi =	$b8
    162  28000 ????
    163  28000 ????		00 b9	    songchannel1layer3hi =	$b9
    164  28000 ????		00 ba	    songchannel2layer3hi =	$bA
    165  28000 ????		00 bb	    songchannel3layer3hi =	$bB
    166  28000 ????		00 bc	    songchannel4layer3hi =	$bC
    167  28000 ????
    168  28000 ????		00 bd	    songdatalo =	$bd
    169  28000 ????		00 be	    songdatahi =	$be
    170  28000 ????
    171  28000 ????		00 bf	    inactivechannelcount =	$bf
    172  28000 ????
    173  28000 ????		00 c0	    songchannel1transpose =	$c0
    174  28000 ????		00 c1	    songchannel2transpose =	$c1
    175  28000 ????		00 c2	    songchannel3transpose =	$c2
    176  28000 ????		00 c3	    songchannel4transpose =	$c3
    177  28000 ????
    178  28000 ????		00 c4	    songstackindex =	$c4
    179  28000 ????
    180  28000 ????		00 c5	    songchannel1instrumentlo =	$c5
    181  28000 ????		00 c6	    songchannel2instrumentlo =	$c6
    182  28000 ????		00 c7	    songchannel3instrumentlo =	$c7
    183  28000 ????		00 c8	    songchannel4instrumentlo =	$c8
    184  28000 ????
    185  28000 ????		00 c9	    songchannel1instrumenthi =	$c9
    186  28000 ????		00 ca	    songchannel2instrumenthi =	$ca
    187  28000 ????		00 cb	    songchannel3instrumenthi =	$cb
    188  28000 ????		00 cc	    songchannel4instrumenthi =	$cc
    189  28000 ????
    190  28000 ????		00 cd	    sfx1notedata =	$cd
    191  28000 ????		00 ce	    sfx2notedata =	$ce
    192  28000 ????
    193  28000 ????		00 cf	    songloops  =	$cf
    194  28000 ????
    195  28000 ????		00 d0	    songpointerlo =	$D0
    196  28000 ????		00 d1	    songpointerhi =	$D1
    197  28000 ????
    198  28000 ????		00 d2	    voxlock    =	$D2
    199  28000 ????		00 d3	    voxqueuesize =	$D3
    200  28000 ????
    201  28000 ????		00 d4	    vblankroutines =	$D4
    202  28000 ????
    203  28000 ????		00 d5	    doublebufferstate =	$D5
    204  28000 ????		00 d6	    doublebufferdloffset =	$D6
    205  28000 ????		00 d7	    doublebufferbufferdirty =	$D7
    206  28000 ????
    207  28000 ????		00 d8	    inttemp1   =	$D8
    208  28000 ????		00 d9	    inttemp2   =	$D9
    209  28000 ????		00 da	    inttemp3   =	$DA
    210  28000 ????		00 db	    inttemp4   =	$DB
    211  28000 ????		00 dc	    inttemp5   =	$DC
    212  28000 ????		00 dd	    inttemp6   =	$DD
    213  28000 ????
    214  28000 ????		00 de	    sfxschedulelock =	$DE
    215  28000 ????		00 df	    sfxschedulemissed =	$DF
    216  28000 ????		00 e0	    sfxinstrumentlo =	$E0
    217  28000 ????		00 e1	    sfxinstrumenthi =	$E1
    218  28000 ????		00 e2	    sfxpitchoffset =	$E2
    219  28000 ????		00 e3	    sfxnoteindex =	$E3
    220  28000 ????
    221  28000 ????						; reserved = $E4
    222  28000 ????						; reserved = $E5
    223  28000 ????
    224  28000 ????		00 e6	    A	       =	$e6
    225  28000 ????		00 e6	    a	       =	$e6
    226  28000 ????		00 e7	    B	       =	$e7
    227  28000 ????		00 e7	    b	       =	$e7
    228  28000 ????		00 e8	    C	       =	$e8
    229  28000 ????		00 e8	    c	       =	$e8
    230  28000 ????		00 e9	    D	       =	$e9
    231  28000 ????		00 e9	    d	       =	$e9
    232  28000 ????		00 ea	    E	       =	$ea
    233  28000 ????		00 ea	    e	       =	$ea
    234  28000 ????		00 eb	    F	       =	$eb
    235  28000 ????		00 eb	    f	       =	$eb
    236  28000 ????		00 ec	    G	       =	$ec
    237  28000 ????		00 ec	    g	       =	$ec
    238  28000 ????		00 ed	    H	       =	$ed
    239  28000 ????		00 ed	    h	       =	$ed
    240  28000 ????		00 ee	    I	       =	$ee
    241  28000 ????		00 ee	    i	       =	$ee
    242  28000 ????		00 ef	    J	       =	$ef
    243  28000 ????		00 ef	    j	       =	$ef
    244  28000 ????		00 f0	    K	       =	$f0
    245  28000 ????		00 f0	    k	       =	$f0
    246  28000 ????		00 f1	    L	       =	$f1
    247  28000 ????		00 f1	    l	       =	$f1
    248  28000 ????		00 f2	    M	       =	$f2
    249  28000 ????		00 f2	    m	       =	$f2
    250  28000 ????		00 f3	    N	       =	$f3
    251  28000 ????		00 f3	    n	       =	$f3
    252  28000 ????		00 f4	    O	       =	$f4
    253  28000 ????		00 f4	    o	       =	$f4
    254  28000 ????		00 f5	    P	       =	$f5
    255  28000 ????		00 f5	    p	       =	$f5
    256  28000 ????		00 f6	    Q	       =	$f6
    257  28000 ????		00 f6	    q	       =	$f6
    258  28000 ????		00 f7	    R	       =	$f7
    259  28000 ????		00 f7	    r	       =	$f7
    260  28000 ????		00 f8	    S	       =	$f8
    261  28000 ????		00 f8	    s	       =	$f8
    262  28000 ????		00 f9	    T	       =	$f9
    263  28000 ????		00 f9	    t	       =	$f9
    264  28000 ????		00 fa	    U	       =	$fa
    265  28000 ????		00 fa	    u	       =	$fa
    266  28000 ????		00 fb	    V	       =	$fb
    267  28000 ????		00 fb	    v	       =	$fb
    268  28000 ????		00 fc	    W	       =	$fc
    269  28000 ????		00 fc	    w	       =	$fc
    270  28000 ????		00 fd	    X	       =	$fd
    271  28000 ????		00 fd	    x	       =	$fd
    272  28000 ????		00 fe	    Y	       =	$fe
    273  28000 ????		00 fe	    y	       =	$fe
    274  28000 ????		00 ff	    Z	       =	$ff
    275  28000 ????		00 ff	    z	       =	$ff
    276  28000 ????
    277  28000 ????						; var0-var99 variables use the top of the stack
    278  28000 ????		01 40	    var0       =	$140
    279  28000 ????		01 41	    var1       =	$141
    280  28000 ????		01 42	    var2       =	$142
    281  28000 ????		01 43	    var3       =	$143
    282  28000 ????		01 44	    var4       =	$144
    283  28000 ????		01 45	    var5       =	$145
    284  28000 ????		01 46	    var6       =	$146
    285  28000 ????		01 47	    var7       =	$147
    286  28000 ????		01 48	    var8       =	$148
    287  28000 ????		01 49	    var9       =	$149
    288  28000 ????		01 4a	    var10      =	$14a
    289  28000 ????		01 4b	    var11      =	$14b
    290  28000 ????		01 4c	    var12      =	$14c
    291  28000 ????		01 4d	    var13      =	$14d
    292  28000 ????		01 4e	    var14      =	$14e
    293  28000 ????		01 4f	    var15      =	$14f
    294  28000 ????		01 50	    var16      =	$150
    295  28000 ????		01 51	    var17      =	$151
    296  28000 ????		01 52	    var18      =	$152
    297  28000 ????		01 53	    var19      =	$153
    298  28000 ????		01 54	    var20      =	$154
    299  28000 ????		01 55	    var21      =	$155
    300  28000 ????		01 56	    var22      =	$156
    301  28000 ????		01 57	    var23      =	$157
    302  28000 ????		01 58	    var24      =	$158
    303  28000 ????		01 59	    var25      =	$159
    304  28000 ????		01 5a	    var26      =	$15a
    305  28000 ????		01 5b	    var27      =	$15b
    306  28000 ????		01 5c	    var28      =	$15c
    307  28000 ????		01 5d	    var29      =	$15d
    308  28000 ????		01 5e	    var30      =	$15e
    309  28000 ????		01 5f	    var31      =	$15f
    310  28000 ????		01 60	    var32      =	$160
    311  28000 ????		01 61	    var33      =	$161
    312  28000 ????		01 62	    var34      =	$162
    313  28000 ????		01 63	    var35      =	$163
    314  28000 ????		01 64	    var36      =	$164
    315  28000 ????		01 65	    var37      =	$165
    316  28000 ????		01 66	    var38      =	$166
    317  28000 ????		01 67	    var39      =	$167
    318  28000 ????		01 68	    var40      =	$168
    319  28000 ????		01 69	    var41      =	$169
    320  28000 ????		01 6a	    var42      =	$16a
    321  28000 ????		01 6b	    var43      =	$16b
    322  28000 ????		01 6c	    var44      =	$16c
    323  28000 ????		01 6d	    var45      =	$16d
    324  28000 ????		01 6e	    var46      =	$16e
    325  28000 ????		01 6f	    var47      =	$16f
    326  28000 ????		01 70	    var48      =	$170
    327  28000 ????		01 71	    var49      =	$171
    328  28000 ????		01 72	    var50      =	$172
    329  28000 ????		01 73	    var51      =	$173
    330  28000 ????		01 74	    var52      =	$174
    331  28000 ????		01 75	    var53      =	$175
    332  28000 ????		01 76	    var54      =	$176
    333  28000 ????		01 77	    var55      =	$177
    334  28000 ????		01 78	    var56      =	$178
    335  28000 ????		01 79	    var57      =	$179
    336  28000 ????		01 7a	    var58      =	$17a
    337  28000 ????		01 7b	    var59      =	$17b
    338  28000 ????		01 7c	    var60      =	$17c
    339  28000 ????		01 7d	    var61      =	$17d
    340  28000 ????		01 7e	    var62      =	$17e
    341  28000 ????		01 7f	    var63      =	$17f
    342  28000 ????		01 80	    var64      =	$180
    343  28000 ????		01 81	    var65      =	$181
    344  28000 ????		01 82	    var66      =	$182
    345  28000 ????		01 83	    var67      =	$183
    346  28000 ????		01 84	    var68      =	$184
    347  28000 ????		01 85	    var69      =	$185
    348  28000 ????		01 86	    var70      =	$186
    349  28000 ????		01 87	    var71      =	$187
    350  28000 ????		01 88	    var72      =	$188
    351  28000 ????		01 89	    var73      =	$189
    352  28000 ????		01 8a	    var74      =	$18a
    353  28000 ????		01 8b	    var75      =	$18b
    354  28000 ????		01 8c	    var76      =	$18c
    355  28000 ????		01 8d	    var77      =	$18d
    356  28000 ????		01 8e	    var78      =	$18e
    357  28000 ????		01 8f	    var79      =	$18f
    358  28000 ????		01 90	    var80      =	$190
    359  28000 ????		01 91	    var81      =	$191
    360  28000 ????		01 92	    var82      =	$192
    361  28000 ????		01 93	    var83      =	$193
    362  28000 ????		01 94	    var84      =	$194
    363  28000 ????		01 95	    var85      =	$195
    364  28000 ????		01 96	    var86      =	$196
    365  28000 ????		01 97	    var87      =	$197
    366  28000 ????		01 98	    var88      =	$198
    367  28000 ????		01 99	    var89      =	$199
    368  28000 ????		01 9a	    var90      =	$19a
    369  28000 ????		01 9b	    var91      =	$19b
    370  28000 ????		01 9c	    var92      =	$19c
    371  28000 ????		01 9d	    var93      =	$19d
    372  28000 ????		01 9e	    var94      =	$19e
    373  28000 ????		01 9f	    var95      =	$19f
    374  28000 ????		01 a0	    var96      =	$1a0
    375  28000 ????		01 a1	    var97      =	$1a1
    376  28000 ????		01 a2	    var98      =	$1a2
    377  28000 ????		01 a3	    var99      =	$1a3
    378  28000 ????
    379 U01c3 ????				      SEG.U	"7800basicRAM"
    380 U01a4					      ORG	$1A4
    381 U01a4
    382 U01a4							; MAX allocation locations are in comments...
    383 U01a4		       00	   framecounter DS	1	; $1A4
    384 U01a5		       00	   countdownseconds DS	1	; $1A5
    385 U01a6		       00 00 00    score0     DS	3	; $1A6 $1A7 $1A8
    386 U01a9		       00 00 00    score1     DS	3	; $1A9 $1AA $1AB
    387 U01ac		       00	   pausebuttonflag DS	1	; $1AC
    388 U01ad		       00	   valbufend  DS	1	; $1AD
    389 U01ae		       00	   valbufendsave DS	1	; $1AE
    390 U01af		       00	   finescrollx DS	1	; $1AF
    391 U01b0		       00	   finescrolly DS	1	; $1B0
    392 U01b1		       00	   joybuttonmode DS	1	; $1B1 ; track joysticks that were changed to one-button mode
    393 U01b2		       00	   interruptindex DS	1	; $1B2
    394 U01b3
    395 U01b3				  -	      ifconst	DOUBLEBUFFER
    396 U01b3				  -doublebufferminimumframetarget DS	1	; $1B3
    397 U01b3				  -doublebufferminimumframeindex DS	1	; $1B4
    398 U01b3					      endif
    399 U01b3
    400 U01b3		       00	   pausedisable DS	1	; $1B5
    401 U01b4		       00	   XCTRL1s    DS	1	; $1B6
    402 U01b5
    403 U01b5				  -	      ifconst	AVOXVOICE
    404 U01b5				  -avoxenable DS	1	; $1B7
    405 U01b5				  -tempavox   DS	1	; $1B8
    406 U01b5					      endif
    407 U01b5
    408 U01b5				  -	      ifconst	MUSICTRACKER
    409 U01b5				  -songtempo  DS	1	; $1B9
    410 U01b5				  -songtick   DS	1	; $1BA
    411 U01b5				  -
    412 U01b5				  -songchannel1layer1loops DS	1	; $1BB
    413 U01b5				  -songchannel2layer1loops DS	1	; $1BC
    414 U01b5				  -songchannel3layer1loops DS	1	; $1BD
    415 U01b5				  -songchannel4layer1loops DS	1	; $1BE
    416 U01b5				  -
    417 U01b5				  -songchannel1layer2loops DS	1	; $1BF
    418 U01b5				  -songchannel2layer2loops DS	1	; $1C0
    419 U01b5				  -songchannel3layer2loops DS	1	; $1C1
    420 U01b5				  -songchannel4layer2loops DS	1	; $1C2
    421 U01b5				  -
    422 U01b5				  -songchannel1layer3loops DS	1	; $1C3
    423 U01b5				  -songchannel2layer3loops DS	1	; $1C4
    424 U01b5				  -songchannel3layer3loops DS	1	; $1C5
    425 U01b5				  -songchannel4layer3loops DS	1	; $1C6
    426 U01b5				  -
    427 U01b5				  -songchannel1busywait DS	1	; $1C7
    428 U01b5				  -songchannel2busywait DS	1	; $1C8
    429 U01b5				  -songchannel3busywait DS	1	; $1C9
    430 U01b5				  -songchannel4busywait DS	1	; $1CA
    431 U01b5				  -
    432 U01b5				  -songchannel1stackdepth DS	1	; $1CB
    433 U01b5				  -songchannel2stackdepth DS	1	; $1CC
    434 U01b5				  -songchannel3stackdepth DS	1	; $1CD
    435 U01b5				  -songchannel4stackdepth DS	1	; $1CE
    436 U01b5					      endif
    437 U01b5
    438 U01b5		       00	   palframes  DS	1
    439 U01b6		       00	   ntscslowframe DS	1
    440 U01b7		       00	   palfastframe DS	1
    441 U01b8
    442 U01b8				  -	      ifconst	MOUSESUPPORT
    443 U01b8				  -port0resolution DS	1
    444 U01b8				  -port1resolution DS	1
    445 U01b8					      else
    446 U01b8				  -	      ifconst	TRAKBALLSUPPORT
    447 U01b8				  -port0resolution DS	1
    448 U01b8				  -port1resolution DS	1
    449 U01b8					      endif
    450 U01b8					      endif
    451 U01b8
    452 U01b8		       00	   port0control DS	1
    453 U01b9		       00	   port1control DS	1
    454 U01ba
    455 U01ba							; port#control values...
    456 U01ba							;	1 = proline
    457 U01ba							;	2 = lightgun
    458 U01ba							;	3 = paddle
    459 U01ba							;	4 = trakball
    460 U01ba							;	5 = vcs joystick
    461 U01ba							;	6 = driving
    462 U01ba							;	7 = keypad
    463 U01ba							;	8 = st mouse/cx80
    464 U01ba							;	9 = amiga mouse
    465 U01ba							;     10 = atarivox
    466 U01ba
    467 U01ba							; controller 0 data...
    468 U01ba		       00	   paddleposition0 DS	1
    469 U01ba		       01 ba	   keypadmatrix0a =	paddleposition0
    470 U01ba		       01 ba	   drivingposition0 =	paddleposition0
    471 U01ba		       01 ba	   trakballx0 =	paddleposition0
    472 U01ba		       01 ba	   mousex0    =	paddleposition0
    473 U01ba		       01 ba	   lighttgunx0 =	paddleposition0
    474 U01ba		       01 ba	   snes2atari0lo =	paddleposition0
    475 U01ba		       01 ba	   mega7800data0 =	paddleposition0
    476 U01bb
    477 U01bb							; controller 1 data...
    478 U01bb		       00	   paddleposition2 DS	1
    479 U01bb		       01 bb	   keypadmatrix1a =	paddleposition2
    480 U01bb		       01 bb	   drivingposition1 =	paddleposition2
    481 U01bb		       01 bb	   trakballx1 =	paddleposition2
    482 U01bb		       01 bb	   mousex1    =	paddleposition2
    483 U01bb		       01 bb	   lightgunx1 =	paddleposition2
    484 U01bb		       01 bb	   snes2atari1lo =	paddleposition2
    485 U01bb		       01 bb	   mega7800data1 =	paddleposition2
    486 U01bc
    487 U01bc							; controller 0 altdata...
    488 U01bc		       00	   paddleposition1 DS	1
    489 U01bc		       01 bc	   keypadmatrix0b =	paddleposition1
    490 U01bc		       01 bc	   trakbally0 =	paddleposition1
    491 U01bc		       01 bc	   mousey0    =	paddleposition1
    492 U01bc		       01 bc	   lightguny0 =	paddleposition1
    493 U01bc		       01 bc	   snes2atari0hi =	paddleposition1
    494 U01bc		       01 bc	   mega7800state0 =	paddleposition1
    495 U01bd
    496 U01bd							; controller 1 altdata...
    497 U01bd		       00	   paddleposition3 DS	1
    498 U01bd		       01 bd	   keypadmatrix1b =	paddleposition3
    499 U01bd		       01 bd	   trakbally1 =	paddleposition3
    500 U01bd		       01 bd	   mousey1    =	paddleposition3
    501 U01bd		       01 bd	   lightguny1 =	paddleposition3
    502 U01bd		       01 bd	   snes2atari1hi =	paddleposition3
    503 U01bd		       01 bd	   mega7800state1 =	paddleposition3
    504 U01be
    505 U01be							; controller state save. for trakball state+dir codes, rotary position codes
    506 U01be		       00	   controller0statesave DS	1
    507 U01be		       01 be	   paddleprevious0 =	controller0statesave
    508 U01be		       01 be	   mousecodex0 =	controller0statesave
    509 U01be		       01 be	   trakballcodex0 =	controller0statesave
    510 U01be		       01 be	   keypadmatrix0c =	controller0statesave
    511 U01be		       01 be	   snesdetected0 =	controller0statesave
    512 U01bf
    513 U01bf		       00	   controller1statesave DS	1
    514 U01bf		       01 bf	   paddleprevious2 =	controller1statesave
    515 U01bf		       01 bf	   mousecodex1 =	controller1statesave
    516 U01bf		       01 bf	   trakballcodex1 =	controller1statesave
    517 U01bf		       01 bf	   keypadmatrix1c =	controller1statesave
    518 U01bf		       01 bf	   snesdetected1 =	controller1statesave
    519 U01c0
    520 U01c0		       00	   paddleprevious1 DS	1
    521 U01c0		       01 c0	   keypadmatrix0d =	paddleprevious1
    522 U01c0		       01 c0	   mousecodey0 =	paddleprevious1
    523 U01c0		       01 c0	   trakballcodey0 =	paddleprevious1
    524 U01c1
    525 U01c1		       00	   paddleprevious3 DS	1
    526 U01c1		       01 c1	   keypadmatrix1d =	paddleprevious3
    527 U01c1		       01 c1	   mousecodey1 =	paddleprevious3
    528 U01c1		       01 c1	   trakballcodey1 =	paddleprevious3
    529 U01c2
    530 U01c2				  -	      ifconst	pokeysupport
    531 U01c2				  -pokey1frames DS	1
    532 U01c2				  -pokey1tick DS	1
    533 U01c2				  -pokey2frames DS	1
    534 U01c2				  -pokey2tick DS	1
    535 U01c2				  -pokey3frames DS	1
    536 U01c2				  -pokey3tick DS	1
    537 U01c2				  -pokey4frames DS	1
    538 U01c2				  -pokey4tick DS	1
    539 U01c2				  -pokey1priority DS	1
    540 U01c2				  -pokey1offset DS	1
    541 U01c2				  -pokey2priority DS	1
    542 U01c2				  -pokey2offset DS	1
    543 U01c2				  -pokey3priority DS	1
    544 U01c2				  -pokey3offset DS	1
    545 U01c2				  -pokey4priority DS	1
    546 U01c2				  -pokey4offset DS	1
    547 U01c2					      endif
    548 U01c2
    549 U01c2				  -	      ifconst	pokeykeysupport
    550 U01c2				  -pokeylastkeycode DS	1
    551 U01c2				  -pokeykeycode DS	1
    552 U01c2				  -pokeykeydebounce DS	1
    553 U01c2					      endif
    554 U01c2
    555 U01c2				  -	      ifconst	RMT
    556 U01c2				  -rasterpause DS	1
    557 U01c2					      endif		; RMT
    558 U01c2				  -	      ifconst	RMTVOLUME
    559 U01c2				  -rmtvolume  DS	1
    560 U01c2					      endif		; RMTVOLUME
    561 U01c2				  -	      ifconst	TIAVOLUME
    562 U01c2				  -tiavolume  DS	1
    563 U01c2					      endif		; TIAVOLUME
    564 U01c2
    565 U01c2				  -	      ifconst	FOURBITFADE
    566 U01c2				  -fourbittemp1 DS	1
    567 U01c2				  -fourbitfadevalue DS	1
    568 U01c2				  -fourbittemp1int DS	1
    569 U01c2				  -fourbitfadevalueint DS	1
    570 U01c2					      endif		; FOURBITFADE
    571 U01c2
    572 U01c2				  -	      ifconst	SNES2ATARISUPPORT
    573 U01c2				  -snesport   DS	1
    574 U01c2					      endif		; SNES2ATARISUPPORT
    575 U01c2
    576 U01c2				  -	      ifconst	KEYPADSUPPORT
    577 U01c2				  -keypadcounter DS	1
    578 U01c2					      endif
    579 U01c2
    580 U01c2				  -	      ifconst	MULTIBUTTON
    581 U01c2				  -multibuttoncount0 DS	1
    582 U01c2				  -multibuttoncount1 DS	1
    583 U01c2					      endif
    584 U01c2
    585 U01c2							; see if we need an interrupthold byte...
    586 U01c2				   INTERRUPTNEEDED SET	0
    587 U01c2				  -	      ifconst	.topscreenroutine
    588 U01c2				  -INTERRUPTNEEDED SET	1
    589 U01c2					      endif
    590 U01c2				  -	      ifconst	.bottomscreenroutine
    591 U01c2				  -INTERRUPTNEEDED SET	1
    592 U01c2					      endif
    593 U01c2				  -	      ifconst	.userinterrupt
    594 U01c2				  -INTERRUPTNEEDED SET	1
    595 U01c2					      endif
    596 U01c2				  -	      if	INTERRUPTNEEDED = 1
    597 U01c2				  -interrupthold DS	1
    598 U01c2					      endif
    599 U01c2
    600 U01c2					      ifnconst	CANARYOFF
    601 U01c2		       00	   canary     DS	1
    602 U01c3					      endif
    603 U01c3
    604 U01c3				  -	      ifnconst	bankswitchmode
    605 U01c3				  -	      echo	"  stack allowance:",[($1FF - .)/2]d,"nested subroutines."
    606 U01c3					      else
   stack allowance: 20 nested subroutines.
    607 U01c3					      echo	"  stack allowance:",[($1FF - .)/3]d,"nested subroutines."
    608 U01c3					      endif
    609 U01c3					      ifnconst	CANARYOFF
   the canary is situated at: $1c2
    610 U01c3					      echo	"  the canary is situated at:",[canary]
    611 U01c3				  -	      else
    612 U01c3				  -	      echo	"  the canary is disabled."
    613 U01c3					      endif
    614 U01c3
    615 U01c3							; $1EE - $1FF reserved for stack
    616 U01c3
    617  28000 ????				       SEG	"GAME"
    618  28000 ????
------- FILE c:\Users\seany\Documents\irata\0087_Irata.78b.asm
------- FILE 7800_extravars.h LEVEL 2 PASS 3
      0  28000 ????				       include	"7800_extravars.h"
      1  28000 ????		22 00	    var100     =	$2200
      2  28000 ????		22 01	    var101     =	$2201
      3  28000 ????		22 02	    var102     =	$2202
      4  28000 ????		22 03	    var103     =	$2203
      5  28000 ????		22 04	    var104     =	$2204
      6  28000 ????		22 05	    var105     =	$2205
      7  28000 ????		22 06	    var106     =	$2206
      8  28000 ????		22 07	    var107     =	$2207
      9  28000 ????		22 08	    var108     =	$2208
     10  28000 ????		22 09	    var109     =	$2209
     11  28000 ????		22 0a	    var110     =	$220A
     12  28000 ????		22 0b	    var111     =	$220B
     13  28000 ????		22 0c	    var112     =	$220C
     14  28000 ????		22 0d	    var113     =	$220D
     15  28000 ????		22 0e	    var114     =	$220E
     16  28000 ????		22 0f	    var115     =	$220F
     17  28000 ????		22 10	    var116     =	$2210
     18  28000 ????		22 11	    var117     =	$2211
     19  28000 ????		22 12	    var118     =	$2212
     20  28000 ????		22 13	    var119     =	$2213
     21  28000 ????		22 14	    var120     =	$2214
     22  28000 ????		22 15	    var121     =	$2215
     23  28000 ????		22 16	    var122     =	$2216
     24  28000 ????		22 17	    var123     =	$2217
     25  28000 ????		22 18	    var124     =	$2218
     26  28000 ????		22 19	    var125     =	$2219
     27  28000 ????		22 1a	    var126     =	$221A
     28  28000 ????		22 1b	    var127     =	$221B
     29  28000 ????		22 1c	    var128     =	$221C
     30  28000 ????		22 1d	    var129     =	$221D
     31  28000 ????		22 1e	    var130     =	$221E
     32  28000 ????		22 1f	    var131     =	$221F
     33  28000 ????		22 20	    var132     =	$2220
     34  28000 ????		22 21	    var133     =	$2221
     35  28000 ????		22 22	    var134     =	$2222
     36  28000 ????		22 23	    var135     =	$2223
     37  28000 ????		22 24	    var136     =	$2224
     38  28000 ????		22 25	    var137     =	$2225
     39  28000 ????		22 26	    var138     =	$2226
     40  28000 ????		22 27	    var139     =	$2227
     41  28000 ????		22 28	    var140     =	$2228
     42  28000 ????		22 29	    var141     =	$2229
     43  28000 ????		22 2a	    var142     =	$222A
     44  28000 ????		22 2b	    var143     =	$222B
     45  28000 ????		22 2c	    var144     =	$222C
     46  28000 ????		22 2d	    var145     =	$222D
     47  28000 ????		22 2e	    var146     =	$222E
     48  28000 ????		22 2f	    var147     =	$222F
     49  28000 ????		22 30	    var148     =	$2230
     50  28000 ????		22 31	    var149     =	$2231
     51  28000 ????		22 32	    var150     =	$2232
     52  28000 ????		22 33	    var151     =	$2233
     53  28000 ????		22 34	    var152     =	$2234
     54  28000 ????		22 35	    var153     =	$2235
     55  28000 ????		22 36	    var154     =	$2236
     56  28000 ????		22 37	    var155     =	$2237
     57  28000 ????		22 38	    var156     =	$2238
     58  28000 ????		22 39	    var157     =	$2239
     59  28000 ????		22 3a	    var158     =	$223A
     60  28000 ????		22 3b	    var159     =	$223B
     61  28000 ????		22 3c	    var160     =	$223C
     62  28000 ????		22 3d	    var161     =	$223D
     63  28000 ????		22 3e	    var162     =	$223E
     64  28000 ????		22 3f	    var163     =	$223F
     65  28000 ????		22 40	    var164     =	$2240
     66  28000 ????		22 41	    var165     =	$2241
     67  28000 ????		22 42	    var166     =	$2242
     68  28000 ????		22 43	    var167     =	$2243
     69  28000 ????		22 44	    var168     =	$2244
     70  28000 ????		22 45	    var169     =	$2245
     71  28000 ????		22 46	    var170     =	$2246
     72  28000 ????		22 47	    var171     =	$2247
     73  28000 ????		22 48	    var172     =	$2248
     74  28000 ????		22 49	    var173     =	$2249
     75  28000 ????		22 4a	    var174     =	$224A
     76  28000 ????		22 4b	    var175     =	$224B
     77  28000 ????		22 4c	    var176     =	$224C
     78  28000 ????		22 4d	    var177     =	$224D
     79  28000 ????		22 4e	    var178     =	$224E
     80  28000 ????		22 4f	    var179     =	$224F
     81  28000 ????		22 50	    var180     =	$2250
     82  28000 ????		22 51	    var181     =	$2251
     83  28000 ????		22 52	    var182     =	$2252
     84  28000 ????		22 53	    var183     =	$2253
     85  28000 ????		22 54	    var184     =	$2254
     86  28000 ????		22 55	    var185     =	$2255
     87  28000 ????		22 56	    var186     =	$2256
     88  28000 ????		22 57	    var187     =	$2257
     89  28000 ????		22 58	    var188     =	$2258
     90  28000 ????		22 59	    var189     =	$2259
     91  28000 ????		22 5a	    var190     =	$225A
     92  28000 ????		22 5b	    var191     =	$225B
     93  28000 ????		22 5c	    var192     =	$225C
     94  28000 ????		22 5d	    var193     =	$225D
     95  28000 ????		22 5e	    var194     =	$225E
     96  28000 ????		22 5f	    var195     =	$225F
     97  28000 ????		22 60	    var196     =	$2260
     98  28000 ????		22 61	    var197     =	$2261
     99  28000 ????		22 62	    var198     =	$2262
    100  28000 ????		22 63	    var199     =	$2263
    101  28000 ????		22 64	    var200     =	$2264
    102  28000 ????		22 65	    var201     =	$2265
    103  28000 ????		22 66	    var202     =	$2266
    104  28000 ????		22 67	    var203     =	$2267
    105  28000 ????		22 68	    var204     =	$2268
    106  28000 ????		22 69	    var205     =	$2269
    107  28000 ????		22 6a	    var206     =	$226A
    108  28000 ????		22 6b	    var207     =	$226B
    109  28000 ????		22 6c	    var208     =	$226C
    110  28000 ????		22 6d	    var209     =	$226D
    111  28000 ????		22 6e	    var210     =	$226E
    112  28000 ????		22 6f	    var211     =	$226F
    113  28000 ????		22 70	    var212     =	$2270
    114  28000 ????		22 71	    var213     =	$2271
    115  28000 ????		22 72	    var214     =	$2272
    116  28000 ????		22 73	    var215     =	$2273
    117  28000 ????		22 74	    var216     =	$2274
    118  28000 ????		22 75	    var217     =	$2275
    119  28000 ????		22 76	    var218     =	$2276
    120  28000 ????		22 77	    var219     =	$2277
    121  28000 ????		22 78	    var220     =	$2278
    122  28000 ????		22 79	    var221     =	$2279
    123  28000 ????		22 7a	    var222     =	$227A
    124  28000 ????		22 7b	    var223     =	$227B
    125  28000 ????		22 7c	    var224     =	$227C
    126  28000 ????		22 7d	    var225     =	$227D
    127  28000 ????		22 7e	    var226     =	$227E
    128  28000 ????		22 7f	    var227     =	$227F
    129  28000 ????		22 80	    var228     =	$2280
    130  28000 ????		22 81	    var229     =	$2281
    131  28000 ????		22 82	    var230     =	$2282
    132  28000 ????		22 83	    var231     =	$2283
    133  28000 ????		22 84	    var232     =	$2284
    134  28000 ????		22 85	    var233     =	$2285
    135  28000 ????		22 86	    var234     =	$2286
    136  28000 ????		22 87	    var235     =	$2287
    137  28000 ????		22 88	    var236     =	$2288
    138  28000 ????		22 89	    var237     =	$2289
    139  28000 ????		22 8a	    var238     =	$228A
    140  28000 ????		22 8b	    var239     =	$228B
    141  28000 ????		22 8c	    var240     =	$228C
    142  28000 ????		22 8d	    var241     =	$228D
    143  28000 ????		22 8e	    var242     =	$228E
    144  28000 ????		22 8f	    var243     =	$228F
    145  28000 ????		22 90	    var244     =	$2290
    146  28000 ????		22 91	    var245     =	$2291
    147  28000 ????		22 92	    var246     =	$2292
    148  28000 ????		22 93	    var247     =	$2293
    149  28000 ????		22 94	    var248     =	$2294
    150  28000 ????		22 95	    var249     =	$2295
    151  28000 ????		22 96	    var250     =	$2296
    152  28000 ????		22 97	    var251     =	$2297
    153  28000 ????		22 98	    var252     =	$2298
    154  28000 ????		22 99	    var253     =	$2299
    155  28000 ????		22 9a	    var254     =	$229A
    156  28000 ????		22 9b	    var255     =	$229B
    157  28000 ????		22 9c	    var256     =	$229C
    158  28000 ????		22 9d	    var257     =	$229D
    159  28000 ????		22 9e	    var258     =	$229E
    160  28000 ????		22 9f	    var259     =	$229F
    161  28000 ????		22 a0	    var260     =	$22A0
    162  28000 ????		22 a1	    var261     =	$22A1
    163  28000 ????		22 a2	    var262     =	$22A2
    164  28000 ????		22 a3	    var263     =	$22A3
    165  28000 ????		22 a4	    var264     =	$22A4
    166  28000 ????		22 a5	    var265     =	$22A5
    167  28000 ????		22 a6	    var266     =	$22A6
    168  28000 ????		22 a7	    var267     =	$22A7
    169  28000 ????		22 a8	    var268     =	$22A8
    170  28000 ????		22 a9	    var269     =	$22A9
    171  28000 ????		22 aa	    var270     =	$22AA
    172  28000 ????		22 ab	    var271     =	$22AB
    173  28000 ????		22 ac	    var272     =	$22AC
    174  28000 ????		22 ad	    var273     =	$22AD
    175  28000 ????		22 ae	    var274     =	$22AE
    176  28000 ????		22 af	    var275     =	$22AF
    177  28000 ????		22 b0	    var276     =	$22B0
    178  28000 ????		22 b1	    var277     =	$22B1
    179  28000 ????		22 b2	    var278     =	$22B2
    180  28000 ????		22 b3	    var279     =	$22B3
    181  28000 ????		22 b4	    var280     =	$22B4
    182  28000 ????		22 b5	    var281     =	$22B5
    183  28000 ????		22 b6	    var282     =	$22B6
    184  28000 ????		22 b7	    var283     =	$22B7
    185  28000 ????		22 b8	    var284     =	$22B8
    186  28000 ????		22 b9	    var285     =	$22B9
    187  28000 ????		22 ba	    var286     =	$22BA
    188  28000 ????		22 bb	    var287     =	$22BB
    189  28000 ????		22 bc	    var288     =	$22BC
    190  28000 ????		22 bd	    var289     =	$22BD
    191  28000 ????		22 be	    var290     =	$22BE
    192  28000 ????		22 bf	    var291     =	$22BF
    193  28000 ????		22 c0	    var292     =	$22C0
    194  28000 ????		22 c1	    var293     =	$22C1
    195  28000 ????		22 c2	    var294     =	$22C2
    196  28000 ????		22 c3	    var295     =	$22C3
    197  28000 ????		22 c4	    var296     =	$22C4
    198  28000 ????		22 c5	    var297     =	$22C5
    199  28000 ????		22 c6	    var298     =	$22C6
    200  28000 ????		22 c7	    var299     =	$22C7
    201  28000 ????		22 c8	    var300     =	$22C8
    202  28000 ????		22 c9	    var301     =	$22C9
    203  28000 ????		22 ca	    var302     =	$22CA
    204  28000 ????		22 cb	    var303     =	$22CB
    205  28000 ????		22 cc	    var304     =	$22CC
    206  28000 ????		22 cd	    var305     =	$22CD
    207  28000 ????		22 ce	    var306     =	$22CE
    208  28000 ????		22 cf	    var307     =	$22CF
    209  28000 ????		22 d0	    var308     =	$22D0
    210  28000 ????		22 d1	    var309     =	$22D1
    211  28000 ????		22 d2	    var310     =	$22D2
    212  28000 ????		22 d3	    var311     =	$22D3
    213  28000 ????		22 d4	    var312     =	$22D4
    214  28000 ????		22 d5	    var313     =	$22D5
    215  28000 ????		22 d6	    var314     =	$22D6
    216  28000 ????		22 d7	    var315     =	$22D7
    217  28000 ????		22 d8	    var316     =	$22D8
    218  28000 ????		22 d9	    var317     =	$22D9
    219  28000 ????		22 da	    var318     =	$22DA
    220  28000 ????		22 db	    var319     =	$22DB
    221  28000 ????		22 dc	    var320     =	$22DC
    222  28000 ????		22 dd	    var321     =	$22DD
    223  28000 ????		22 de	    var322     =	$22DE
    224  28000 ????		22 df	    var323     =	$22DF
    225  28000 ????		22 e0	    var324     =	$22E0
    226  28000 ????		22 e1	    var325     =	$22E1
    227  28000 ????		22 e2	    var326     =	$22E2
    228  28000 ????		22 e3	    var327     =	$22E3
    229  28000 ????		22 e4	    var328     =	$22E4
    230  28000 ????		22 e5	    var329     =	$22E5
    231  28000 ????		22 e6	    var330     =	$22E6
    232  28000 ????		22 e7	    var331     =	$22E7
    233  28000 ????		22 e8	    var332     =	$22E8
    234  28000 ????		22 e9	    var333     =	$22E9
    235  28000 ????		22 ea	    var334     =	$22EA
    236  28000 ????		22 eb	    var335     =	$22EB
    237  28000 ????		22 ec	    var336     =	$22EC
    238  28000 ????		22 ed	    var337     =	$22ED
    239  28000 ????		22 ee	    var338     =	$22EE
    240  28000 ????		22 ef	    var339     =	$22EF
    241  28000 ????		22 f0	    var340     =	$22F0
    242  28000 ????		22 f1	    var341     =	$22F1
    243  28000 ????		22 f2	    var342     =	$22F2
    244  28000 ????		22 f3	    var343     =	$22F3
    245  28000 ????		22 f4	    var344     =	$22F4
    246  28000 ????		22 f5	    var345     =	$22F5
    247  28000 ????		22 f6	    var346     =	$22F6
    248  28000 ????		22 f7	    var347     =	$22F7
    249  28000 ????		22 f8	    var348     =	$22F8
    250  28000 ????		22 f9	    var349     =	$22F9
    251  28000 ????		22 fa	    var350     =	$22FA
    252  28000 ????		22 fb	    var351     =	$22FB
    253  28000 ????		22 fc	    var352     =	$22FC
    254  28000 ????		22 fd	    var353     =	$22FD
    255  28000 ????		22 fe	    var354     =	$22FE
    256  28000 ????		22 ff	    var355     =	$22FF
    257  28000 ????		23 00	    var356     =	$2300
    258  28000 ????		23 01	    var357     =	$2301
    259  28000 ????		23 02	    var358     =	$2302
    260  28000 ????		23 03	    var359     =	$2303
    261  28000 ????		23 04	    var360     =	$2304
    262  28000 ????		23 05	    var361     =	$2305
    263  28000 ????		23 06	    var362     =	$2306
    264  28000 ????		23 07	    var363     =	$2307
    265  28000 ????		23 08	    var364     =	$2308
    266  28000 ????		23 09	    var365     =	$2309
    267  28000 ????		23 0a	    var366     =	$230A
    268  28000 ????		23 0b	    var367     =	$230B
    269  28000 ????		23 0c	    var368     =	$230C
    270  28000 ????		23 0d	    var369     =	$230D
    271  28000 ????		23 0e	    var370     =	$230E
    272  28000 ????		23 0f	    var371     =	$230F
    273  28000 ????		23 10	    var372     =	$2310
    274  28000 ????		23 11	    var373     =	$2311
    275  28000 ????		23 12	    var374     =	$2312
    276  28000 ????		23 13	    var375     =	$2313
    277  28000 ????		23 14	    var376     =	$2314
    278  28000 ????		23 15	    var377     =	$2315
    279  28000 ????		23 16	    var378     =	$2316
    280  28000 ????		23 17	    var379     =	$2317
    281  28000 ????		23 18	    var380     =	$2318
    282  28000 ????		23 19	    var381     =	$2319
    283  28000 ????		23 1a	    var382     =	$231A
    284  28000 ????		23 1b	    var383     =	$231B
    285  28000 ????		23 1c	    var384     =	$231C
    286  28000 ????		23 1d	    var385     =	$231D
    287  28000 ????		23 1e	    var386     =	$231E
    288  28000 ????		23 1f	    var387     =	$231F
    289  28000 ????		23 20	    var388     =	$2320
    290  28000 ????		23 21	    var389     =	$2321
    291  28000 ????		23 22	    var390     =	$2322
    292  28000 ????		23 23	    var391     =	$2323
    293  28000 ????		23 24	    var392     =	$2324
    294  28000 ????		23 25	    var393     =	$2325
    295  28000 ????		23 26	    var394     =	$2326
    296  28000 ????		23 27	    var395     =	$2327
    297  28000 ????		23 28	    var396     =	$2328
    298  28000 ????		23 29	    var397     =	$2329
    299  28000 ????		23 2a	    var398     =	$232A
    300  28000 ????		23 2b	    var399     =	$232B
    301  28000 ????		23 2c	    var400     =	$232C
    302  28000 ????		23 2d	    var401     =	$232D
    303  28000 ????		23 2e	    var402     =	$232E
    304  28000 ????		23 2f	    var403     =	$232F
    305  28000 ????		23 30	    var404     =	$2330
    306  28000 ????		23 31	    var405     =	$2331
    307  28000 ????		23 32	    var406     =	$2332
    308  28000 ????		23 33	    var407     =	$2333
    309  28000 ????		23 34	    var408     =	$2334
    310  28000 ????		23 35	    var409     =	$2335
    311  28000 ????		23 36	    var410     =	$2336
    312  28000 ????		23 37	    var411     =	$2337
    313  28000 ????		23 38	    var412     =	$2338
    314  28000 ????		23 39	    var413     =	$2339
    315  28000 ????		23 3a	    var414     =	$233A
    316  28000 ????		23 3b	    var415     =	$233B
    317  28000 ????		23 3c	    var416     =	$233C
    318  28000 ????		23 3d	    var417     =	$233D
    319  28000 ????		23 3e	    var418     =	$233E
    320  28000 ????		23 3f	    var419     =	$233F
    321  28000 ????		23 40	    var420     =	$2340
    322  28000 ????		23 41	    var421     =	$2341
    323  28000 ????		23 42	    var422     =	$2342
    324  28000 ????		23 43	    var423     =	$2343
    325  28000 ????		23 44	    var424     =	$2344
    326  28000 ????		23 45	    var425     =	$2345
    327  28000 ????		23 46	    var426     =	$2346
    328  28000 ????		23 47	    var427     =	$2347
    329  28000 ????		23 48	    var428     =	$2348
    330  28000 ????		23 49	    var429     =	$2349
    331  28000 ????		23 4a	    var430     =	$234A
    332  28000 ????		23 4b	    var431     =	$234B
    333  28000 ????		23 4c	    var432     =	$234C
    334  28000 ????		23 4d	    var433     =	$234D
    335  28000 ????		23 4e	    var434     =	$234E
    336  28000 ????		23 4f	    var435     =	$234F
    337  28000 ????		23 50	    var436     =	$2350
    338  28000 ????		23 51	    var437     =	$2351
    339  28000 ????		23 52	    var438     =	$2352
    340  28000 ????		23 53	    var439     =	$2353
    341  28000 ????		23 54	    var440     =	$2354
    342  28000 ????		23 55	    var441     =	$2355
    343  28000 ????		23 56	    var442     =	$2356
    344  28000 ????		23 57	    var443     =	$2357
    345  28000 ????		23 58	    var444     =	$2358
    346  28000 ????		23 59	    var445     =	$2359
    347  28000 ????		23 5a	    var446     =	$235A
    348  28000 ????		23 5b	    var447     =	$235B
    349  28000 ????		23 5c	    var448     =	$235C
    350  28000 ????		23 5d	    var449     =	$235D
    351  28000 ????		23 5e	    var450     =	$235E
    352  28000 ????		23 5f	    var451     =	$235F
    353  28000 ????		23 60	    var452     =	$2360
    354  28000 ????		23 61	    var453     =	$2361
    355  28000 ????		23 62	    var454     =	$2362
    356  28000 ????		23 63	    var455     =	$2363
    357  28000 ????		23 64	    var456     =	$2364
    358  28000 ????		23 65	    var457     =	$2365
    359  28000 ????		23 66	    var458     =	$2366
    360  28000 ????		23 67	    var459     =	$2367
    361  28000 ????		23 68	    var460     =	$2368
    362  28000 ????		23 69	    var461     =	$2369
    363  28000 ????		23 6a	    var462     =	$236A
    364  28000 ????		23 6b	    var463     =	$236B
    365  28000 ????		23 6c	    var464     =	$236C
    366  28000 ????		23 6d	    var465     =	$236D
    367  28000 ????		23 6e	    var466     =	$236E
    368  28000 ????		23 6f	    var467     =	$236F
    369  28000 ????		23 70	    var468     =	$2370
    370  28000 ????		23 71	    var469     =	$2371
    371  28000 ????		23 72	    var470     =	$2372
    372  28000 ????		23 73	    var471     =	$2373
    373  28000 ????		23 74	    var472     =	$2374
    374  28000 ????		23 75	    var473     =	$2375
    375  28000 ????		23 76	    var474     =	$2376
    376  28000 ????		23 77	    var475     =	$2377
    377  28000 ????		23 78	    var476     =	$2378
    378  28000 ????		23 79	    var477     =	$2379
    379  28000 ????		23 7a	    var478     =	$237A
    380  28000 ????		23 7b	    var479     =	$237B
    381  28000 ????		23 7c	    var480     =	$237C
    382  28000 ????		23 7d	    var481     =	$237D
    383  28000 ????		23 7e	    var482     =	$237E
    384  28000 ????		23 7f	    var483     =	$237F
    385  28000 ????		23 80	    var484     =	$2380
    386  28000 ????		23 81	    var485     =	$2381
    387  28000 ????		23 82	    var486     =	$2382
    388  28000 ????		23 83	    var487     =	$2383
    389  28000 ????		23 84	    var488     =	$2384
    390  28000 ????		23 85	    var489     =	$2385
    391  28000 ????		23 86	    var490     =	$2386
    392  28000 ????		23 87	    var491     =	$2387
    393  28000 ????		23 88	    var492     =	$2388
    394  28000 ????		23 89	    var493     =	$2389
    395  28000 ????		23 8a	    var494     =	$238A
    396  28000 ????		23 8b	    var495     =	$238B
    397  28000 ????		23 8c	    var496     =	$238C
    398  28000 ????		23 8d	    var497     =	$238D
    399  28000 ????		23 8e	    var498     =	$238E
    400  28000 ????		23 8f	    var499     =	$238F
    401  28000 ????		23 90	    var500     =	$2390
    402  28000 ????		23 91	    var501     =	$2391
    403  28000 ????		23 92	    var502     =	$2392
    404  28000 ????		23 93	    var503     =	$2393
    405  28000 ????		23 94	    var504     =	$2394
    406  28000 ????		23 95	    var505     =	$2395
    407  28000 ????		23 96	    var506     =	$2396
    408  28000 ????		23 97	    var507     =	$2397
    409  28000 ????		23 98	    var508     =	$2398
    410  28000 ????		23 99	    var509     =	$2399
    411  28000 ????		23 9a	    var510     =	$239A
    412  28000 ????		23 9b	    var511     =	$239B
    413  28000 ????		23 9c	    var512     =	$239C
    414  28000 ????		23 9d	    var513     =	$239D
    415  28000 ????		23 9e	    var514     =	$239E
    416  28000 ????		23 9f	    var515     =	$239F
    417  28000 ????		23 a0	    var516     =	$23A0
    418  28000 ????		23 a1	    var517     =	$23A1
    419  28000 ????		23 a2	    var518     =	$23A2
    420  28000 ????		23 a3	    var519     =	$23A3
    421  28000 ????		23 a4	    var520     =	$23A4
    422  28000 ????		23 a5	    var521     =	$23A5
    423  28000 ????		23 a6	    var522     =	$23A6
    424  28000 ????		23 a7	    var523     =	$23A7
    425  28000 ????		23 a8	    var524     =	$23A8
    426  28000 ????		23 a9	    var525     =	$23A9
    427  28000 ????		23 aa	    var526     =	$23AA
    428  28000 ????		23 ab	    var527     =	$23AB
    429  28000 ????		23 ac	    var528     =	$23AC
    430  28000 ????		23 ad	    var529     =	$23AD
    431  28000 ????		23 ae	    var530     =	$23AE
    432  28000 ????		23 af	    var531     =	$23AF
    433  28000 ????		23 b0	    var532     =	$23B0
    434  28000 ????		23 b1	    var533     =	$23B1
    435  28000 ????		23 b2	    var534     =	$23B2
    436  28000 ????		23 b3	    var535     =	$23B3
    437  28000 ????		23 b4	    var536     =	$23B4
    438  28000 ????		23 b5	    var537     =	$23B5
    439  28000 ????		23 b6	    var538     =	$23B6
    440  28000 ????		23 b7	    var539     =	$23B7
    441  28000 ????		23 b8	    var540     =	$23B8
    442  28000 ????		23 b9	    var541     =	$23B9
    443  28000 ????		23 ba	    var542     =	$23BA
    444  28000 ????		23 bb	    var543     =	$23BB
    445  28000 ????		23 bc	    var544     =	$23BC
    446  28000 ????		23 bd	    var545     =	$23BD
    447  28000 ????		23 be	    var546     =	$23BE
    448  28000 ????		23 bf	    var547     =	$23BF
    449  28000 ????		23 c0	    var548     =	$23C0
    450  28000 ????		23 c1	    var549     =	$23C1
    451  28000 ????		23 c2	    var550     =	$23C2
    452  28000 ????		23 c3	    var551     =	$23C3
    453  28000 ????		23 c4	    var552     =	$23C4
    454  28000 ????		23 c5	    var553     =	$23C5
    455  28000 ????		23 c6	    var554     =	$23C6
    456  28000 ????		23 c7	    var555     =	$23C7
    457  28000 ????		23 c8	    var556     =	$23C8
    458  28000 ????		23 c9	    var557     =	$23C9
    459  28000 ????		23 ca	    var558     =	$23CA
    460  28000 ????		23 cb	    var559     =	$23CB
    461  28000 ????		23 cc	    var560     =	$23CC
    462  28000 ????		23 cd	    var561     =	$23CD
    463  28000 ????		23 ce	    var562     =	$23CE
    464  28000 ????		23 cf	    var563     =	$23CF
    465  28000 ????		23 d0	    var564     =	$23D0
    466  28000 ????		23 d1	    var565     =	$23D1
    467  28000 ????		23 d2	    var566     =	$23D2
    468  28000 ????		23 d3	    var567     =	$23D3
    469  28000 ????		23 d4	    var568     =	$23D4
    470  28000 ????		23 d5	    var569     =	$23D5
    471  28000 ????		23 d6	    var570     =	$23D6
    472  28000 ????		23 d7	    var571     =	$23D7
    473  28000 ????		23 d8	    var572     =	$23D8
    474  28000 ????		23 d9	    var573     =	$23D9
    475  28000 ????		23 da	    var574     =	$23DA
    476  28000 ????		23 db	    var575     =	$23DB
    477  28000 ????		23 dc	    var576     =	$23DC
    478  28000 ????		23 dd	    var577     =	$23DD
    479  28000 ????		23 de	    var578     =	$23DE
    480  28000 ????		23 df	    var579     =	$23DF
    481  28000 ????		23 e0	    var580     =	$23E0
    482  28000 ????		23 e1	    var581     =	$23E1
    483  28000 ????		23 e2	    var582     =	$23E2
    484  28000 ????		23 e3	    var583     =	$23E3
    485  28000 ????		23 e4	    var584     =	$23E4
    486  28000 ????		23 e5	    var585     =	$23E5
    487  28000 ????		23 e6	    var586     =	$23E6
    488  28000 ????		23 e7	    var587     =	$23E7
    489  28000 ????		23 e8	    var588     =	$23E8
    490  28000 ????		23 e9	    var589     =	$23E9
    491  28000 ????		23 ea	    var590     =	$23EA
    492  28000 ????		23 eb	    var591     =	$23EB
    493  28000 ????		23 ec	    var592     =	$23EC
    494  28000 ????		23 ed	    var593     =	$23ED
    495  28000 ????		23 ee	    var594     =	$23EE
    496  28000 ????		23 ef	    var595     =	$23EF
    497  28000 ????		23 f0	    var596     =	$23F0
    498  28000 ????		23 f1	    var597     =	$23F1
    499  28000 ????		23 f2	    var598     =	$23F2
    500  28000 ????		23 f3	    var599     =	$23F3
    501  28000 ????		23 f4	    var600     =	$23F4
    502  28000 ????		23 f5	    var601     =	$23F5
    503  28000 ????		23 f6	    var602     =	$23F6
    504  28000 ????		23 f7	    var603     =	$23F7
    505  28000 ????		23 f8	    var604     =	$23F8
    506  28000 ????		23 f9	    var605     =	$23F9
    507  28000 ????		23 fa	    var606     =	$23FA
    508  28000 ????		23 fb	    var607     =	$23FB
    509  28000 ????		23 fc	    var608     =	$23FC
    510  28000 ????		23 fd	    var609     =	$23FD
    511  28000 ????		23 fe	    var610     =	$23FE
    512  28000 ????		23 ff	    var611     =	$23FF
    513  28000 ????		24 00	    var612     =	$2400
    514  28000 ????		24 01	    var613     =	$2401
    515  28000 ????		24 02	    var614     =	$2402
    516  28000 ????		24 03	    var615     =	$2403
    517  28000 ????		24 04	    var616     =	$2404
    518  28000 ????		24 05	    var617     =	$2405
    519  28000 ????		24 06	    var618     =	$2406
    520  28000 ????		24 07	    var619     =	$2407
    521  28000 ????		24 08	    var620     =	$2408
    522  28000 ????		24 09	    var621     =	$2409
    523  28000 ????		24 0a	    var622     =	$240A
    524  28000 ????		24 0b	    var623     =	$240B
    525  28000 ????		24 0c	    var624     =	$240C
    526  28000 ????		24 0d	    var625     =	$240D
    527  28000 ????		24 0e	    var626     =	$240E
    528  28000 ????		24 0f	    var627     =	$240F
    529  28000 ????		24 10	    var628     =	$2410
    530  28000 ????		24 11	    var629     =	$2411
    531  28000 ????		24 12	    var630     =	$2412
    532  28000 ????		24 13	    var631     =	$2413
    533  28000 ????		24 14	    var632     =	$2414
    534  28000 ????		24 15	    var633     =	$2415
    535  28000 ????		24 16	    var634     =	$2416
    536  28000 ????		24 17	    var635     =	$2417
    537  28000 ????		24 18	    var636     =	$2418
    538  28000 ????		24 19	    var637     =	$2419
    539  28000 ????		24 1a	    var638     =	$241A
    540  28000 ????		24 1b	    var639     =	$241B
    541  28000 ????		24 1c	    var640     =	$241C
    542  28000 ????		24 1d	    var641     =	$241D
    543  28000 ????		24 1e	    var642     =	$241E
    544  28000 ????		24 1f	    var643     =	$241F
    545  28000 ????		24 20	    var644     =	$2420
    546  28000 ????		24 21	    var645     =	$2421
    547  28000 ????		24 22	    var646     =	$2422
    548  28000 ????		24 23	    var647     =	$2423
    549  28000 ????		24 24	    var648     =	$2424
    550  28000 ????		24 25	    var649     =	$2425
    551  28000 ????		24 26	    var650     =	$2426
    552  28000 ????		24 27	    var651     =	$2427
    553  28000 ????		24 28	    var652     =	$2428
    554  28000 ????		24 29	    var653     =	$2429
    555  28000 ????		24 2a	    var654     =	$242A
    556  28000 ????		24 2b	    var655     =	$242B
    557  28000 ????		24 2c	    var656     =	$242C
    558  28000 ????		24 2d	    var657     =	$242D
    559  28000 ????		24 2e	    var658     =	$242E
    560  28000 ????		24 2f	    var659     =	$242F
    561  28000 ????		24 30	    var660     =	$2430
    562  28000 ????		24 31	    var661     =	$2431
    563  28000 ????		24 32	    var662     =	$2432
    564  28000 ????		24 33	    var663     =	$2433
    565  28000 ????		24 34	    var664     =	$2434
    566  28000 ????		24 35	    var665     =	$2435
    567  28000 ????		24 36	    var666     =	$2436
    568  28000 ????		24 37	    var667     =	$2437
    569  28000 ????		24 38	    var668     =	$2438
    570  28000 ????		24 39	    var669     =	$2439
    571  28000 ????		24 3a	    var670     =	$243A
    572  28000 ????		24 3b	    var671     =	$243B
    573  28000 ????		24 3c	    var672     =	$243C
    574  28000 ????		24 3d	    var673     =	$243D
    575  28000 ????		24 3e	    var674     =	$243E
    576  28000 ????		24 3f	    var675     =	$243F
    577  28000 ????		24 40	    var676     =	$2440
    578  28000 ????		24 41	    var677     =	$2441
    579  28000 ????		24 42	    var678     =	$2442
    580  28000 ????		24 43	    var679     =	$2443
    581  28000 ????		24 44	    var680     =	$2444
    582  28000 ????		24 45	    var681     =	$2445
    583  28000 ????		24 46	    var682     =	$2446
    584  28000 ????		24 47	    var683     =	$2447
    585  28000 ????		24 48	    var684     =	$2448
    586  28000 ????		24 49	    var685     =	$2449
    587  28000 ????		24 4a	    var686     =	$244A
    588  28000 ????		24 4b	    var687     =	$244B
    589  28000 ????		24 4c	    var688     =	$244C
    590  28000 ????		24 4d	    var689     =	$244D
    591  28000 ????		24 4e	    var690     =	$244E
    592  28000 ????		24 4f	    var691     =	$244F
    593  28000 ????		24 50	    var692     =	$2450
    594  28000 ????		24 51	    var693     =	$2451
    595  28000 ????		24 52	    var694     =	$2452
    596  28000 ????		24 53	    var695     =	$2453
    597  28000 ????		24 54	    var696     =	$2454
    598  28000 ????		24 55	    var697     =	$2455
    599  28000 ????		24 56	    var698     =	$2456
    600  28000 ????		24 57	    var699     =	$2457
    601  28000 ????		24 58	    var700     =	$2458
    602  28000 ????		24 59	    var701     =	$2459
    603  28000 ????		24 5a	    var702     =	$245A
    604  28000 ????		24 5b	    var703     =	$245B
    605  28000 ????		24 5c	    var704     =	$245C
    606  28000 ????		24 5d	    var705     =	$245D
    607  28000 ????		24 5e	    var706     =	$245E
    608  28000 ????		24 5f	    var707     =	$245F
    609  28000 ????		24 60	    var708     =	$2460
    610  28000 ????		24 61	    var709     =	$2461
    611  28000 ????		24 62	    var710     =	$2462
    612  28000 ????		24 63	    var711     =	$2463
    613  28000 ????		24 64	    var712     =	$2464
    614  28000 ????		24 65	    var713     =	$2465
    615  28000 ????		24 66	    var714     =	$2466
    616  28000 ????		24 67	    var715     =	$2467
    617  28000 ????		24 68	    var716     =	$2468
    618  28000 ????		24 69	    var717     =	$2469
    619  28000 ????		24 6a	    var718     =	$246A
    620  28000 ????		24 6b	    var719     =	$246B
    621  28000 ????		24 6c	    var720     =	$246C
    622  28000 ????		24 6d	    var721     =	$246D
    623  28000 ????		24 6e	    var722     =	$246E
    624  28000 ????		24 6f	    var723     =	$246F
    625  28000 ????		24 70	    var724     =	$2470
    626  28000 ????		24 71	    var725     =	$2471
    627  28000 ????		24 72	    var726     =	$2472
    628  28000 ????		24 73	    var727     =	$2473
    629  28000 ????		24 74	    var728     =	$2474
    630  28000 ????		24 75	    var729     =	$2475
    631  28000 ????		24 76	    var730     =	$2476
    632  28000 ????		24 77	    var731     =	$2477
    633  28000 ????		24 78	    var732     =	$2478
    634  28000 ????		24 79	    var733     =	$2479
    635  28000 ????		24 7a	    var734     =	$247A
    636  28000 ????		24 7b	    var735     =	$247B
    637  28000 ????		24 7c	    var736     =	$247C
    638  28000 ????		24 7d	    var737     =	$247D
    639  28000 ????		24 7e	    var738     =	$247E
    640  28000 ????		24 7f	    var739     =	$247F
    641  28000 ????		24 80	    var740     =	$2480
    642  28000 ????		24 81	    var741     =	$2481
    643  28000 ????		24 82	    var742     =	$2482
    644  28000 ????		24 83	    var743     =	$2483
    645  28000 ????		24 84	    var744     =	$2484
    646  28000 ????		24 85	    var745     =	$2485
    647  28000 ????		24 86	    var746     =	$2486
    648  28000 ????		24 87	    var747     =	$2487
    649  28000 ????		24 88	    var748     =	$2488
    650  28000 ????		24 89	    var749     =	$2489
    651  28000 ????		24 8a	    var750     =	$248A
    652  28000 ????		24 8b	    var751     =	$248B
    653  28000 ????		24 8c	    var752     =	$248C
    654  28000 ????		24 8d	    var753     =	$248D
    655  28000 ????		24 8e	    var754     =	$248E
    656  28000 ????		24 8f	    var755     =	$248F
    657  28000 ????		24 90	    var756     =	$2490
    658  28000 ????		24 91	    var757     =	$2491
    659  28000 ????		24 92	    var758     =	$2492
    660  28000 ????		24 93	    var759     =	$2493
    661  28000 ????		24 94	    var760     =	$2494
    662  28000 ????		24 95	    var761     =	$2495
    663  28000 ????		24 96	    var762     =	$2496
    664  28000 ????		24 97	    var763     =	$2497
    665  28000 ????		24 98	    var764     =	$2498
    666  28000 ????		24 99	    var765     =	$2499
    667  28000 ????		24 9a	    var766     =	$249A
    668  28000 ????		24 9b	    var767     =	$249B
    669  28000 ????		24 9c	    var768     =	$249C
    670  28000 ????		24 9d	    var769     =	$249D
    671  28000 ????		24 9e	    var770     =	$249E
    672  28000 ????		24 9f	    var771     =	$249F
    673  28000 ????		24 a0	    var772     =	$24A0
    674  28000 ????		24 a1	    var773     =	$24A1
    675  28000 ????		24 a2	    var774     =	$24A2
    676  28000 ????		24 a3	    var775     =	$24A3
    677  28000 ????		24 a4	    var776     =	$24A4
    678  28000 ????		24 a5	    var777     =	$24A5
    679  28000 ????		24 a6	    var778     =	$24A6
    680  28000 ????		24 a7	    var779     =	$24A7
    681  28000 ????		24 a8	    var780     =	$24A8
    682  28000 ????		24 a9	    var781     =	$24A9
    683  28000 ????		24 aa	    var782     =	$24AA
    684  28000 ????		24 ab	    var783     =	$24AB
    685  28000 ????		24 ac	    var784     =	$24AC
    686  28000 ????		24 ad	    var785     =	$24AD
    687  28000 ????		24 ae	    var786     =	$24AE
    688  28000 ????		24 af	    var787     =	$24AF
    689  28000 ????		24 b0	    var788     =	$24B0
    690  28000 ????		24 b1	    var789     =	$24B1
    691  28000 ????		24 b2	    var790     =	$24B2
    692  28000 ????		24 b3	    var791     =	$24B3
    693  28000 ????		24 b4	    var792     =	$24B4
    694  28000 ????		24 b5	    var793     =	$24B5
    695  28000 ????		24 b6	    var794     =	$24B6
    696  28000 ????		24 b7	    var795     =	$24B7
    697  28000 ????		24 b8	    var796     =	$24B8
    698  28000 ????		24 b9	    var797     =	$24B9
    699  28000 ????		24 ba	    var798     =	$24BA
    700  28000 ????		24 bb	    var799     =	$24BB
    701  28000 ????		24 bc	    var800     =	$24BC
    702  28000 ????		24 bd	    var801     =	$24BD
    703  28000 ????		24 be	    var802     =	$24BE
    704  28000 ????		24 bf	    var803     =	$24BF
    705  28000 ????		24 c0	    var804     =	$24C0
    706  28000 ????		24 c1	    var805     =	$24C1
    707  28000 ????		24 c2	    var806     =	$24C2
    708  28000 ????		24 c3	    var807     =	$24C3
    709  28000 ????		24 c4	    var808     =	$24C4
    710  28000 ????		24 c5	    var809     =	$24C5
    711  28000 ????		24 c6	    var810     =	$24C6
    712  28000 ????		24 c7	    var811     =	$24C7
    713  28000 ????		24 c8	    var812     =	$24C8
    714  28000 ????		24 c9	    var813     =	$24C9
    715  28000 ????		24 ca	    var814     =	$24CA
    716  28000 ????		24 cb	    var815     =	$24CB
    717  28000 ????		24 cc	    var816     =	$24CC
    718  28000 ????		24 cd	    var817     =	$24CD
    719  28000 ????		24 ce	    var818     =	$24CE
    720  28000 ????		24 cf	    var819     =	$24CF
    721  28000 ????		24 d0	    var820     =	$24D0
    722  28000 ????		24 d1	    var821     =	$24D1
    723  28000 ????		24 d2	    var822     =	$24D2
    724  28000 ????		24 d3	    var823     =	$24D3
    725  28000 ????		24 d4	    var824     =	$24D4
    726  28000 ????		24 d5	    var825     =	$24D5
    727  28000 ????		24 d6	    var826     =	$24D6
    728  28000 ????		24 d7	    var827     =	$24D7
    729  28000 ????		24 d8	    var828     =	$24D8
    730  28000 ????		24 d9	    var829     =	$24D9
    731  28000 ????		24 da	    var830     =	$24DA
    732  28000 ????		24 db	    var831     =	$24DB
    733  28000 ????		24 dc	    var832     =	$24DC
    734  28000 ????		24 dd	    var833     =	$24DD
    735  28000 ????		24 de	    var834     =	$24DE
    736  28000 ????		24 df	    var835     =	$24DF
    737  28000 ????		24 e0	    var836     =	$24E0
    738  28000 ????		24 e1	    var837     =	$24E1
    739  28000 ????		24 e2	    var838     =	$24E2
    740  28000 ????		24 e3	    var839     =	$24E3
    741  28000 ????		24 e4	    var840     =	$24E4
    742  28000 ????		24 e5	    var841     =	$24E5
    743  28000 ????		24 e6	    var842     =	$24E6
    744  28000 ????		24 e7	    var843     =	$24E7
    745  28000 ????		24 e8	    var844     =	$24E8
    746  28000 ????		24 e9	    var845     =	$24E9
    747  28000 ????		24 ea	    var846     =	$24EA
    748  28000 ????		24 eb	    var847     =	$24EB
    749  28000 ????		24 ec	    var848     =	$24EC
    750  28000 ????		24 ed	    var849     =	$24ED
    751  28000 ????		24 ee	    var850     =	$24EE
    752  28000 ????		24 ef	    var851     =	$24EF
    753  28000 ????		24 f0	    var852     =	$24F0
    754  28000 ????		24 f1	    var853     =	$24F1
    755  28000 ????		24 f2	    var854     =	$24F2
    756  28000 ????		24 f3	    var855     =	$24F3
    757  28000 ????		24 f4	    var856     =	$24F4
    758  28000 ????		24 f5	    var857     =	$24F5
    759  28000 ????		24 f6	    var858     =	$24F6
    760  28000 ????		24 f7	    var859     =	$24F7
    761  28000 ????		24 f8	    var860     =	$24F8
    762  28000 ????		24 f9	    var861     =	$24F9
    763  28000 ????		24 fa	    var862     =	$24FA
    764  28000 ????		24 fb	    var863     =	$24FB
    765  28000 ????		24 fc	    var864     =	$24FC
    766  28000 ????		24 fd	    var865     =	$24FD
    767  28000 ????		24 fe	    var866     =	$24FE
    768  28000 ????		24 ff	    var867     =	$24FF
    769  28000 ????		25 00	    var868     =	$2500
    770  28000 ????		25 01	    var869     =	$2501
    771  28000 ????		25 02	    var870     =	$2502
    772  28000 ????		25 03	    var871     =	$2503
    773  28000 ????		25 04	    var872     =	$2504
    774  28000 ????		25 05	    var873     =	$2505
    775  28000 ????		25 06	    var874     =	$2506
    776  28000 ????		25 07	    var875     =	$2507
    777  28000 ????		25 08	    var876     =	$2508
    778  28000 ????		25 09	    var877     =	$2509
    779  28000 ????		25 0a	    var878     =	$250A
    780  28000 ????		25 0b	    var879     =	$250B
    781  28000 ????		25 0c	    var880     =	$250C
    782  28000 ????		25 0d	    var881     =	$250D
    783  28000 ????		25 0e	    var882     =	$250E
    784  28000 ????		25 0f	    var883     =	$250F
    785  28000 ????		25 10	    var884     =	$2510
    786  28000 ????		25 11	    var885     =	$2511
    787  28000 ????		25 12	    var886     =	$2512
    788  28000 ????		25 13	    var887     =	$2513
    789  28000 ????		25 14	    var888     =	$2514
    790  28000 ????		25 15	    var889     =	$2515
    791  28000 ????		25 16	    var890     =	$2516
    792  28000 ????		25 17	    var891     =	$2517
    793  28000 ????		25 18	    var892     =	$2518
    794  28000 ????		25 19	    var893     =	$2519
    795  28000 ????		25 1a	    var894     =	$251A
    796  28000 ????		25 1b	    var895     =	$251B
    797  28000 ????		25 1c	    var896     =	$251C
    798  28000 ????		25 1d	    var897     =	$251D
    799  28000 ????		25 1e	    var898     =	$251E
    800  28000 ????		25 1f	    var899     =	$251F
    801  28000 ????		25 20	    var900     =	$2520
    802  28000 ????		25 21	    var901     =	$2521
    803  28000 ????		25 22	    var902     =	$2522
    804  28000 ????		25 23	    var903     =	$2523
    805  28000 ????		25 24	    var904     =	$2524
    806  28000 ????		25 25	    var905     =	$2525
    807  28000 ????		25 26	    var906     =	$2526
    808  28000 ????		25 27	    var907     =	$2527
    809  28000 ????		25 28	    var908     =	$2528
    810  28000 ????		25 29	    var909     =	$2529
    811  28000 ????		25 2a	    var910     =	$252A
    812  28000 ????		25 2b	    var911     =	$252B
    813  28000 ????		25 2c	    var912     =	$252C
    814  28000 ????		25 2d	    var913     =	$252D
    815  28000 ????		25 2e	    var914     =	$252E
    816  28000 ????		25 2f	    var915     =	$252F
    817  28000 ????		25 30	    var916     =	$2530
    818  28000 ????		25 31	    var917     =	$2531
    819  28000 ????		25 32	    var918     =	$2532
    820  28000 ????		25 33	    var919     =	$2533
    821  28000 ????		25 34	    var920     =	$2534
    822  28000 ????		25 35	    var921     =	$2535
    823  28000 ????		25 36	    var922     =	$2536
    824  28000 ????		25 37	    var923     =	$2537
    825  28000 ????		25 38	    var924     =	$2538
    826  28000 ????		25 39	    var925     =	$2539
    827  28000 ????		25 3a	    var926     =	$253A
    828  28000 ????		25 3b	    var927     =	$253B
    829  28000 ????		25 3c	    var928     =	$253C
    830  28000 ????		25 3d	    var929     =	$253D
    831  28000 ????		25 3e	    var930     =	$253E
    832  28000 ????		25 3f	    var931     =	$253F
    833  28000 ????		25 40	    var932     =	$2540
    834  28000 ????		25 41	    var933     =	$2541
    835  28000 ????		25 42	    var934     =	$2542
    836  28000 ????		25 43	    var935     =	$2543
    837  28000 ????		25 44	    var936     =	$2544
    838  28000 ????		25 45	    var937     =	$2545
    839  28000 ????		25 46	    var938     =	$2546
    840  28000 ????		25 47	    var939     =	$2547
    841  28000 ????		25 48	    var940     =	$2548
    842  28000 ????		25 49	    var941     =	$2549
    843  28000 ????		25 4a	    var942     =	$254A
    844  28000 ????		25 4b	    var943     =	$254B
    845  28000 ????		25 4c	    var944     =	$254C
    846  28000 ????		25 4d	    var945     =	$254D
    847  28000 ????		25 4e	    var946     =	$254E
    848  28000 ????		25 4f	    var947     =	$254F
    849  28000 ????		25 50	    var948     =	$2550
    850  28000 ????		25 51	    var949     =	$2551
    851  28000 ????		25 52	    var950     =	$2552
    852  28000 ????		25 53	    var951     =	$2553
    853  28000 ????		25 54	    var952     =	$2554
    854  28000 ????		25 55	    var953     =	$2555
    855  28000 ????		25 56	    var954     =	$2556
    856  28000 ????		25 57	    var955     =	$2557
    857  28000 ????		25 58	    var956     =	$2558
    858  28000 ????		25 59	    var957     =	$2559
    859  28000 ????		25 5a	    var958     =	$255A
    860  28000 ????		25 5b	    var959     =	$255B
    861  28000 ????		25 5c	    var960     =	$255C
    862  28000 ????		25 5d	    var961     =	$255D
    863  28000 ????		25 5e	    var962     =	$255E
    864  28000 ????		25 5f	    var963     =	$255F
    865  28000 ????		25 60	    var964     =	$2560
    866  28000 ????		25 61	    var965     =	$2561
    867  28000 ????		25 62	    var966     =	$2562
    868  28000 ????		25 63	    var967     =	$2563
    869  28000 ????		25 64	    var968     =	$2564
    870  28000 ????		25 65	    var969     =	$2565
    871  28000 ????		25 66	    var970     =	$2566
    872  28000 ????		25 67	    var971     =	$2567
    873  28000 ????		25 68	    var972     =	$2568
    874  28000 ????		25 69	    var973     =	$2569
    875  28000 ????		25 6a	    var974     =	$256A
    876  28000 ????		25 6b	    var975     =	$256B
    877  28000 ????		25 6c	    var976     =	$256C
    878  28000 ????		25 6d	    var977     =	$256D
    879  28000 ????		25 6e	    var978     =	$256E
    880  28000 ????		25 6f	    var979     =	$256F
    881  28000 ????		25 70	    var980     =	$2570
    882  28000 ????		25 71	    var981     =	$2571
    883  28000 ????		25 72	    var982     =	$2572
    884  28000 ????		25 73	    var983     =	$2573
    885  28000 ????		25 74	    var984     =	$2574
    886  28000 ????		25 75	    var985     =	$2575
    887  28000 ????		25 76	    var986     =	$2576
    888  28000 ????		25 77	    var987     =	$2577
    889  28000 ????		25 78	    var988     =	$2578
    890  28000 ????		25 79	    var989     =	$2579
    891  28000 ????		25 7a	    var990     =	$257A
    892  28000 ????		25 7b	    var991     =	$257B
    893  28000 ????		25 7c	    var992     =	$257C
    894  28000 ????		25 7d	    var993     =	$257D
    895  28000 ????		25 7e	    var994     =	$257E
    896  28000 ????		25 7f	    var995     =	$257F
    897  28000 ????		25 80	    var996     =	$2580
    898  28000 ????		25 81	    var997     =	$2581
    899  28000 ????		25 82	    var998     =	$2582
    900  28000 ????		25 83	    var999     =	$2583
    901  28000 ????		25 84	    var1000    =	$2584
    902  28000 ????		25 85	    var1001    =	$2585
    903  28000 ????		25 86	    var1002    =	$2586
    904  28000 ????		25 87	    var1003    =	$2587
    905  28000 ????		25 88	    var1004    =	$2588
    906  28000 ????		25 89	    var1005    =	$2589
    907  28000 ????		25 8a	    var1006    =	$258A
    908  28000 ????		25 8b	    var1007    =	$258B
    909  28000 ????		25 8c	    var1008    =	$258C
    910  28000 ????		25 8d	    var1009    =	$258D
    911  28000 ????		25 8e	    var1010    =	$258E
    912  28000 ????		25 8f	    var1011    =	$258F
    913  28000 ????		25 90	    var1012    =	$2590
    914  28000 ????		25 91	    var1013    =	$2591
    915  28000 ????		25 92	    var1014    =	$2592
    916  28000 ????		25 93	    var1015    =	$2593
    917  28000 ????		25 94	    var1016    =	$2594
    918  28000 ????		25 95	    var1017    =	$2595
    919  28000 ????		25 96	    var1018    =	$2596
    920  28000 ????		25 97	    var1019    =	$2597
    921  28000 ????		25 98	    var1020    =	$2598
    922  28000 ????		25 99	    var1021    =	$2599
    923  28000 ????		25 9a	    var1022    =	$259A
    924  28000 ????		25 9b	    var1023    =	$259B
    925  28000 ????		25 9c	    var1024    =	$259C
    926  28000 ????		25 9d	    var1025    =	$259D
    927  28000 ????		25 9e	    var1026    =	$259E
    928  28000 ????		25 9f	    var1027    =	$259F
    929  28000 ????		25 a0	    var1028    =	$25A0
    930  28000 ????		25 a1	    var1029    =	$25A1
    931  28000 ????		25 a2	    var1030    =	$25A2
    932  28000 ????		25 a3	    var1031    =	$25A3
    933  28000 ????		25 a4	    var1032    =	$25A4
    934  28000 ????		25 a5	    var1033    =	$25A5
    935  28000 ????		25 a6	    var1034    =	$25A6
    936  28000 ????		25 a7	    var1035    =	$25A7
    937  28000 ????		25 a8	    var1036    =	$25A8
    938  28000 ????		25 a9	    var1037    =	$25A9
    939  28000 ????		25 aa	    var1038    =	$25AA
    940  28000 ????		25 ab	    var1039    =	$25AB
    941  28000 ????		25 ac	    var1040    =	$25AC
    942  28000 ????		25 ad	    var1041    =	$25AD
    943  28000 ????		25 ae	    var1042    =	$25AE
    944  28000 ????		25 af	    var1043    =	$25AF
    945  28000 ????		25 b0	    var1044    =	$25B0
    946  28000 ????		25 b1	    var1045    =	$25B1
    947  28000 ????		25 b2	    var1046    =	$25B2
    948  28000 ????		25 b3	    var1047    =	$25B3
    949  28000 ????		25 b4	    var1048    =	$25B4
    950  28000 ????		25 b5	    var1049    =	$25B5
    951  28000 ????		25 b6	    var1050    =	$25B6
    952  28000 ????		25 b7	    var1051    =	$25B7
    953  28000 ????		25 b8	    var1052    =	$25B8
    954  28000 ????		25 b9	    var1053    =	$25B9
    955  28000 ????		25 ba	    var1054    =	$25BA
    956  28000 ????		25 bb	    var1055    =	$25BB
    957  28000 ????		25 bc	    var1056    =	$25BC
    958  28000 ????		25 bd	    var1057    =	$25BD
    959  28000 ????		25 be	    var1058    =	$25BE
    960  28000 ????		25 bf	    var1059    =	$25BF
    961  28000 ????		25 c0	    var1060    =	$25C0
    962  28000 ????		25 c1	    var1061    =	$25C1
    963  28000 ????		25 c2	    var1062    =	$25C2
    964  28000 ????		25 c3	    var1063    =	$25C3
    965  28000 ????		25 c4	    var1064    =	$25C4
    966  28000 ????		25 c5	    var1065    =	$25C5
    967  28000 ????		25 c6	    var1066    =	$25C6
    968  28000 ????		25 c7	    var1067    =	$25C7
    969  28000 ????		25 c8	    var1068    =	$25C8
    970  28000 ????		25 c9	    var1069    =	$25C9
    971  28000 ????		25 ca	    var1070    =	$25CA
    972  28000 ????		25 cb	    var1071    =	$25CB
    973  28000 ????		25 cc	    var1072    =	$25CC
    974  28000 ????		25 cd	    var1073    =	$25CD
    975  28000 ????		25 ce	    var1074    =	$25CE
    976  28000 ????		25 cf	    var1075    =	$25CF
    977  28000 ????		25 d0	    var1076    =	$25D0
    978  28000 ????		25 d1	    var1077    =	$25D1
    979  28000 ????		25 d2	    var1078    =	$25D2
    980  28000 ????		25 d3	    var1079    =	$25D3
    981  28000 ????		25 d4	    var1080    =	$25D4
    982  28000 ????		25 d5	    var1081    =	$25D5
    983  28000 ????		25 d6	    var1082    =	$25D6
    984  28000 ????		25 d7	    var1083    =	$25D7
    985  28000 ????		25 d8	    var1084    =	$25D8
    986  28000 ????		25 d9	    var1085    =	$25D9
    987  28000 ????		25 da	    var1086    =	$25DA
    988  28000 ????		25 db	    var1087    =	$25DB
    989  28000 ????		25 dc	    var1088    =	$25DC
    990  28000 ????		25 dd	    var1089    =	$25DD
    991  28000 ????		25 de	    var1090    =	$25DE
    992  28000 ????		25 df	    var1091    =	$25DF
    993  28000 ????		25 e0	    var1092    =	$25E0
    994  28000 ????		25 e1	    var1093    =	$25E1
    995  28000 ????		25 e2	    var1094    =	$25E2
    996  28000 ????		25 e3	    var1095    =	$25E3
    997  28000 ????		25 e4	    var1096    =	$25E4
    998  28000 ????		25 e5	    var1097    =	$25E5
    999  28000 ????		25 e6	    var1098    =	$25E6
   1000  28000 ????		25 e7	    var1099    =	$25E7
   1001  28000 ????		25 e8	    var1100    =	$25E8
   1002  28000 ????		25 e9	    var1101    =	$25E9
   1003  28000 ????		25 ea	    var1102    =	$25EA
   1004  28000 ????		25 eb	    var1103    =	$25EB
   1005  28000 ????		25 ec	    var1104    =	$25EC
   1006  28000 ????		25 ed	    var1105    =	$25ED
   1007  28000 ????		25 ee	    var1106    =	$25EE
   1008  28000 ????		25 ef	    var1107    =	$25EF
   1009  28000 ????		25 f0	    var1108    =	$25F0
   1010  28000 ????		25 f1	    var1109    =	$25F1
   1011  28000 ????		25 f2	    var1110    =	$25F2
   1012  28000 ????		25 f3	    var1111    =	$25F3
   1013  28000 ????		25 f4	    var1112    =	$25F4
   1014  28000 ????		25 f5	    var1113    =	$25F5
   1015  28000 ????		25 f6	    var1114    =	$25F6
   1016  28000 ????		25 f7	    var1115    =	$25F7
   1017  28000 ????		25 f8	    var1116    =	$25F8
   1018  28000 ????		25 f9	    var1117    =	$25F9
   1019  28000 ????		25 fa	    var1118    =	$25FA
   1020  28000 ????		25 fb	    var1119    =	$25FB
   1021  28000 ????		25 fc	    var1120    =	$25FC
   1022  28000 ????		25 fd	    var1121    =	$25FD
   1023  28000 ????		25 fe	    var1122    =	$25FE
   1024  28000 ????		25 ff	    var1123    =	$25FF
   1025  28000 ????		26 00	    var1124    =	$2600
   1026  28000 ????		26 01	    var1125    =	$2601
   1027  28000 ????		26 02	    var1126    =	$2602
   1028  28000 ????		26 03	    var1127    =	$2603
   1029  28000 ????		26 04	    var1128    =	$2604
   1030  28000 ????		26 05	    var1129    =	$2605
   1031  28000 ????		26 06	    var1130    =	$2606
   1032  28000 ????		26 07	    var1131    =	$2607
   1033  28000 ????		26 08	    var1132    =	$2608
   1034  28000 ????		26 09	    var1133    =	$2609
   1035  28000 ????		26 0a	    var1134    =	$260A
   1036  28000 ????		26 0b	    var1135    =	$260B
   1037  28000 ????		26 0c	    var1136    =	$260C
   1038  28000 ????		26 0d	    var1137    =	$260D
   1039  28000 ????		26 0e	    var1138    =	$260E
   1040  28000 ????		26 0f	    var1139    =	$260F
   1041  28000 ????		26 10	    var1140    =	$2610
   1042  28000 ????		26 11	    var1141    =	$2611
   1043  28000 ????		26 12	    var1142    =	$2612
   1044  28000 ????		26 13	    var1143    =	$2613
   1045  28000 ????		26 14	    var1144    =	$2614
   1046  28000 ????		26 15	    var1145    =	$2615
   1047  28000 ????		26 16	    var1146    =	$2616
   1048  28000 ????		26 17	    var1147    =	$2617
   1049  28000 ????		26 18	    var1148    =	$2618
   1050  28000 ????		26 19	    var1149    =	$2619
   1051  28000 ????		26 1a	    var1150    =	$261A
   1052  28000 ????		26 1b	    var1151    =	$261B
   1053  28000 ????		26 1c	    var1152    =	$261C
   1054  28000 ????		26 1d	    var1153    =	$261D
   1055  28000 ????		26 1e	    var1154    =	$261E
   1056  28000 ????		26 1f	    var1155    =	$261F
   1057  28000 ????		26 20	    var1156    =	$2620
   1058  28000 ????		26 21	    var1157    =	$2621
   1059  28000 ????		26 22	    var1158    =	$2622
   1060  28000 ????		26 23	    var1159    =	$2623
   1061  28000 ????		26 24	    var1160    =	$2624
   1062  28000 ????		26 25	    var1161    =	$2625
   1063  28000 ????		26 26	    var1162    =	$2626
   1064  28000 ????		26 27	    var1163    =	$2627
   1065  28000 ????		26 28	    var1164    =	$2628
   1066  28000 ????		26 29	    var1165    =	$2629
   1067  28000 ????		26 2a	    var1166    =	$262A
   1068  28000 ????		26 2b	    var1167    =	$262B
   1069  28000 ????		26 2c	    var1168    =	$262C
   1070  28000 ????		26 2d	    var1169    =	$262D
   1071  28000 ????		26 2e	    var1170    =	$262E
   1072  28000 ????		26 2f	    var1171    =	$262F
   1073  28000 ????		26 30	    var1172    =	$2630
   1074  28000 ????		26 31	    var1173    =	$2631
   1075  28000 ????		26 32	    var1174    =	$2632
   1076  28000 ????		26 33	    var1175    =	$2633
   1077  28000 ????		26 34	    var1176    =	$2634
   1078  28000 ????		26 35	    var1177    =	$2635
   1079  28000 ????		26 36	    var1178    =	$2636
   1080  28000 ????		26 37	    var1179    =	$2637
   1081  28000 ????		26 38	    var1180    =	$2638
   1082  28000 ????		26 39	    var1181    =	$2639
   1083  28000 ????		26 3a	    var1182    =	$263A
   1084  28000 ????		26 3b	    var1183    =	$263B
   1085  28000 ????		26 3c	    var1184    =	$263C
   1086  28000 ????		26 3d	    var1185    =	$263D
   1087  28000 ????		26 3e	    var1186    =	$263E
   1088  28000 ????		26 3f	    var1187    =	$263F
   1089  28000 ????		26 40	    var1188    =	$2640
   1090  28000 ????		26 41	    var1189    =	$2641
   1091  28000 ????		26 42	    var1190    =	$2642
   1092  28000 ????		26 43	    var1191    =	$2643
   1093  28000 ????		26 44	    var1192    =	$2644
   1094  28000 ????		26 45	    var1193    =	$2645
   1095  28000 ????		26 46	    var1194    =	$2646
   1096  28000 ????		26 47	    var1195    =	$2647
   1097  28000 ????		26 48	    var1196    =	$2648
   1098  28000 ????		26 49	    var1197    =	$2649
   1099  28000 ????		26 4a	    var1198    =	$264A
   1100  28000 ????		26 4b	    var1199    =	$264B
   1101  28000 ????		26 4c	    var1200    =	$264C
   1102  28000 ????		26 4d	    var1201    =	$264D
   1103  28000 ????		26 4e	    var1202    =	$264E
   1104  28000 ????		26 4f	    var1203    =	$264F
   1105  28000 ????		26 50	    var1204    =	$2650
   1106  28000 ????		26 51	    var1205    =	$2651
   1107  28000 ????		26 52	    var1206    =	$2652
   1108  28000 ????		26 53	    var1207    =	$2653
   1109  28000 ????		26 54	    var1208    =	$2654
   1110  28000 ????		26 55	    var1209    =	$2655
   1111  28000 ????		26 56	    var1210    =	$2656
   1112  28000 ????		26 57	    var1211    =	$2657
   1113  28000 ????		26 58	    var1212    =	$2658
   1114  28000 ????		26 59	    var1213    =	$2659
   1115  28000 ????		26 5a	    var1214    =	$265A
   1116  28000 ????		26 5b	    var1215    =	$265B
   1117  28000 ????		26 5c	    var1216    =	$265C
   1118  28000 ????		26 5d	    var1217    =	$265D
   1119  28000 ????		26 5e	    var1218    =	$265E
   1120  28000 ????		26 5f	    var1219    =	$265F
   1121  28000 ????		26 60	    var1220    =	$2660
   1122  28000 ????		26 61	    var1221    =	$2661
   1123  28000 ????		26 62	    var1222    =	$2662
   1124  28000 ????		26 63	    var1223    =	$2663
   1125  28000 ????		26 64	    var1224    =	$2664
   1126  28000 ????		26 65	    var1225    =	$2665
   1127  28000 ????		26 66	    var1226    =	$2666
   1128  28000 ????		26 67	    var1227    =	$2667
   1129  28000 ????		26 68	    var1228    =	$2668
   1130  28000 ????		26 69	    var1229    =	$2669
   1131  28000 ????		26 6a	    var1230    =	$266A
   1132  28000 ????		26 6b	    var1231    =	$266B
   1133  28000 ????		26 6c	    var1232    =	$266C
   1134  28000 ????		26 6d	    var1233    =	$266D
   1135  28000 ????		26 6e	    var1234    =	$266E
   1136  28000 ????		26 6f	    var1235    =	$266F
   1137  28000 ????		26 70	    var1236    =	$2670
   1138  28000 ????		26 71	    var1237    =	$2671
   1139  28000 ????		26 72	    var1238    =	$2672
   1140  28000 ????		26 73	    var1239    =	$2673
   1141  28000 ????		26 74	    var1240    =	$2674
   1142  28000 ????		26 75	    var1241    =	$2675
   1143  28000 ????		26 76	    var1242    =	$2676
   1144  28000 ????		26 77	    var1243    =	$2677
   1145  28000 ????		26 78	    var1244    =	$2678
   1146  28000 ????		26 79	    var1245    =	$2679
   1147  28000 ????		26 7a	    var1246    =	$267A
   1148  28000 ????		26 7b	    var1247    =	$267B
   1149  28000 ????		26 7c	    var1248    =	$267C
   1150  28000 ????		26 7d	    var1249    =	$267D
   1151  28000 ????		26 7e	    var1250    =	$267E
   1152  28000 ????		26 7f	    var1251    =	$267F
   1153  28000 ????		26 80	    var1252    =	$2680
   1154  28000 ????		26 81	    var1253    =	$2681
   1155  28000 ????		26 82	    var1254    =	$2682
   1156  28000 ????		26 83	    var1255    =	$2683
   1157  28000 ????		26 84	    var1256    =	$2684
   1158  28000 ????		26 85	    var1257    =	$2685
   1159  28000 ????		26 86	    var1258    =	$2686
   1160  28000 ????		26 87	    var1259    =	$2687
   1161  28000 ????		26 88	    var1260    =	$2688
   1162  28000 ????		26 89	    var1261    =	$2689
   1163  28000 ????		26 8a	    var1262    =	$268A
   1164  28000 ????		26 8b	    var1263    =	$268B
   1165  28000 ????		26 8c	    var1264    =	$268C
   1166  28000 ????		26 8d	    var1265    =	$268D
   1167  28000 ????		26 8e	    var1266    =	$268E
   1168  28000 ????		26 8f	    var1267    =	$268F
   1169  28000 ????		26 90	    var1268    =	$2690
   1170  28000 ????		26 91	    var1269    =	$2691
   1171  28000 ????		26 92	    var1270    =	$2692
   1172  28000 ????		26 93	    var1271    =	$2693
   1173  28000 ????		26 94	    var1272    =	$2694
   1174  28000 ????		26 95	    var1273    =	$2695
   1175  28000 ????		26 96	    var1274    =	$2696
   1176  28000 ????		26 97	    var1275    =	$2697
   1177  28000 ????		26 98	    var1276    =	$2698
   1178  28000 ????		26 99	    var1277    =	$2699
   1179  28000 ????		26 9a	    var1278    =	$269A
   1180  28000 ????		26 9b	    var1279    =	$269B
   1181  28000 ????		26 9c	    var1280    =	$269C
   1182  28000 ????		26 9d	    var1281    =	$269D
   1183  28000 ????		26 9e	    var1282    =	$269E
   1184  28000 ????		26 9f	    var1283    =	$269F
   1185  28000 ????		26 a0	    var1284    =	$26A0
   1186  28000 ????		26 a1	    var1285    =	$26A1
   1187  28000 ????		26 a2	    var1286    =	$26A2
   1188  28000 ????		26 a3	    var1287    =	$26A3
   1189  28000 ????		26 a4	    var1288    =	$26A4
   1190  28000 ????		26 a5	    var1289    =	$26A5
   1191  28000 ????		26 a6	    var1290    =	$26A6
   1192  28000 ????		26 a7	    var1291    =	$26A7
   1193  28000 ????		26 a8	    var1292    =	$26A8
   1194  28000 ????		26 a9	    var1293    =	$26A9
   1195  28000 ????		26 aa	    var1294    =	$26AA
   1196  28000 ????		26 ab	    var1295    =	$26AB
   1197  28000 ????		26 ac	    var1296    =	$26AC
   1198  28000 ????		26 ad	    var1297    =	$26AD
   1199  28000 ????		26 ae	    var1298    =	$26AE
   1200  28000 ????		26 af	    var1299    =	$26AF
   1201  28000 ????		26 b0	    var1300    =	$26B0
   1202  28000 ????		26 b1	    var1301    =	$26B1
   1203  28000 ????		26 b2	    var1302    =	$26B2
   1204  28000 ????		26 b3	    var1303    =	$26B3
   1205  28000 ????		26 b4	    var1304    =	$26B4
   1206  28000 ????		26 b5	    var1305    =	$26B5
   1207  28000 ????		26 b6	    var1306    =	$26B6
   1208  28000 ????		26 b7	    var1307    =	$26B7
   1209  28000 ????		26 b8	    var1308    =	$26B8
   1210  28000 ????		26 b9	    var1309    =	$26B9
   1211  28000 ????		26 ba	    var1310    =	$26BA
   1212  28000 ????		26 bb	    var1311    =	$26BB
   1213  28000 ????		26 bc	    var1312    =	$26BC
   1214  28000 ????		26 bd	    var1313    =	$26BD
   1215  28000 ????		26 be	    var1314    =	$26BE
   1216  28000 ????		26 bf	    var1315    =	$26BF
   1217  28000 ????		26 c0	    var1316    =	$26C0
   1218  28000 ????		26 c1	    var1317    =	$26C1
   1219  28000 ????		26 c2	    var1318    =	$26C2
   1220  28000 ????		26 c3	    var1319    =	$26C3
   1221  28000 ????		26 c4	    var1320    =	$26C4
   1222  28000 ????		26 c5	    var1321    =	$26C5
   1223  28000 ????		26 c6	    var1322    =	$26C6
   1224  28000 ????		26 c7	    var1323    =	$26C7
   1225  28000 ????		26 c8	    var1324    =	$26C8
   1226  28000 ????		26 c9	    var1325    =	$26C9
   1227  28000 ????		26 ca	    var1326    =	$26CA
   1228  28000 ????		26 cb	    var1327    =	$26CB
   1229  28000 ????		26 cc	    var1328    =	$26CC
   1230  28000 ????		26 cd	    var1329    =	$26CD
   1231  28000 ????		26 ce	    var1330    =	$26CE
   1232  28000 ????		26 cf	    var1331    =	$26CF
   1233  28000 ????		26 d0	    var1332    =	$26D0
   1234  28000 ????		26 d1	    var1333    =	$26D1
   1235  28000 ????		26 d2	    var1334    =	$26D2
   1236  28000 ????		26 d3	    var1335    =	$26D3
   1237  28000 ????		26 d4	    var1336    =	$26D4
   1238  28000 ????		26 d5	    var1337    =	$26D5
   1239  28000 ????		26 d6	    var1338    =	$26D6
   1240  28000 ????		26 d7	    var1339    =	$26D7
   1241  28000 ????		26 d8	    var1340    =	$26D8
   1242  28000 ????		26 d9	    var1341    =	$26D9
   1243  28000 ????		26 da	    var1342    =	$26DA
   1244  28000 ????		26 db	    var1343    =	$26DB
   1245  28000 ????		26 dc	    var1344    =	$26DC
   1246  28000 ????		26 dd	    var1345    =	$26DD
   1247  28000 ????		26 de	    var1346    =	$26DE
   1248  28000 ????		26 df	    var1347    =	$26DF
   1249  28000 ????		26 e0	    var1348    =	$26E0
   1250  28000 ????		26 e1	    var1349    =	$26E1
   1251  28000 ????		26 e2	    var1350    =	$26E2
   1252  28000 ????		26 e3	    var1351    =	$26E3
   1253  28000 ????		26 e4	    var1352    =	$26E4
   1254  28000 ????		26 e5	    var1353    =	$26E5
   1255  28000 ????		26 e6	    var1354    =	$26E6
   1256  28000 ????		26 e7	    var1355    =	$26E7
   1257  28000 ????		26 e8	    var1356    =	$26E8
   1258  28000 ????		26 e9	    var1357    =	$26E9
   1259  28000 ????		26 ea	    var1358    =	$26EA
   1260  28000 ????		26 eb	    var1359    =	$26EB
   1261  28000 ????		26 ec	    var1360    =	$26EC
   1262  28000 ????		26 ed	    var1361    =	$26ED
   1263  28000 ????		26 ee	    var1362    =	$26EE
   1264  28000 ????		26 ef	    var1363    =	$26EF
   1265  28000 ????		26 f0	    var1364    =	$26F0
   1266  28000 ????		26 f1	    var1365    =	$26F1
   1267  28000 ????		26 f2	    var1366    =	$26F2
   1268  28000 ????		26 f3	    var1367    =	$26F3
   1269  28000 ????		26 f4	    var1368    =	$26F4
   1270  28000 ????		26 f5	    var1369    =	$26F5
   1271  28000 ????		26 f6	    var1370    =	$26F6
   1272  28000 ????		26 f7	    var1371    =	$26F7
   1273  28000 ????		26 f8	    var1372    =	$26F8
   1274  28000 ????		26 f9	    var1373    =	$26F9
   1275  28000 ????		26 fa	    var1374    =	$26FA
   1276  28000 ????		26 fb	    var1375    =	$26FB
   1277  28000 ????		26 fc	    var1376    =	$26FC
   1278  28000 ????		26 fd	    var1377    =	$26FD
   1279  28000 ????		26 fe	    var1378    =	$26FE
   1280  28000 ????		26 ff	    var1379    =	$26FF
   1281  28000 ????		27 00	    var1380    =	$2700
   1282  28000 ????		27 01	    var1381    =	$2701
   1283  28000 ????		27 02	    var1382    =	$2702
   1284  28000 ????		27 03	    var1383    =	$2703
   1285  28000 ????		27 04	    var1384    =	$2704
   1286  28000 ????		27 05	    var1385    =	$2705
   1287  28000 ????		27 06	    var1386    =	$2706
   1288  28000 ????		27 07	    var1387    =	$2707
   1289  28000 ????		27 08	    var1388    =	$2708
   1290  28000 ????		27 09	    var1389    =	$2709
   1291  28000 ????		27 0a	    var1390    =	$270A
   1292  28000 ????		27 0b	    var1391    =	$270B
   1293  28000 ????		27 0c	    var1392    =	$270C
   1294  28000 ????		27 0d	    var1393    =	$270D
   1295  28000 ????		27 0e	    var1394    =	$270E
   1296  28000 ????		27 0f	    var1395    =	$270F
   1297  28000 ????		27 10	    var1396    =	$2710
   1298  28000 ????		27 11	    var1397    =	$2711
   1299  28000 ????		27 12	    var1398    =	$2712
   1300  28000 ????		27 13	    var1399    =	$2713
   1301  28000 ????		27 14	    var1400    =	$2714
   1302  28000 ????		27 15	    var1401    =	$2715
   1303  28000 ????		27 16	    var1402    =	$2716
   1304  28000 ????		27 17	    var1403    =	$2717
   1305  28000 ????		27 18	    var1404    =	$2718
   1306  28000 ????		27 19	    var1405    =	$2719
   1307  28000 ????		27 1a	    var1406    =	$271A
   1308  28000 ????		27 1b	    var1407    =	$271B
   1309  28000 ????		27 1c	    var1408    =	$271C
   1310  28000 ????		27 1d	    var1409    =	$271D
   1311  28000 ????		27 1e	    var1410    =	$271E
   1312  28000 ????		27 1f	    var1411    =	$271F
   1313  28000 ????		27 20	    var1412    =	$2720
   1314  28000 ????		27 21	    var1413    =	$2721
   1315  28000 ????		27 22	    var1414    =	$2722
   1316  28000 ????		27 23	    var1415    =	$2723
   1317  28000 ????		27 24	    var1416    =	$2724
   1318  28000 ????		27 25	    var1417    =	$2725
   1319  28000 ????		27 26	    var1418    =	$2726
   1320  28000 ????		27 27	    var1419    =	$2727
   1321  28000 ????		27 28	    var1420    =	$2728
   1322  28000 ????		27 29	    var1421    =	$2729
   1323  28000 ????		27 2a	    var1422    =	$272A
   1324  28000 ????		27 2b	    var1423    =	$272B
   1325  28000 ????		27 2c	    var1424    =	$272C
   1326  28000 ????		27 2d	    var1425    =	$272D
   1327  28000 ????		27 2e	    var1426    =	$272E
   1328  28000 ????		27 2f	    var1427    =	$272F
   1329  28000 ????		27 30	    var1428    =	$2730
   1330  28000 ????		27 31	    var1429    =	$2731
   1331  28000 ????		27 32	    var1430    =	$2732
   1332  28000 ????		27 33	    var1431    =	$2733
   1333  28000 ????		27 34	    var1432    =	$2734
   1334  28000 ????		27 35	    var1433    =	$2735
   1335  28000 ????		27 36	    var1434    =	$2736
   1336  28000 ????		27 37	    var1435    =	$2737
   1337  28000 ????		27 38	    var1436    =	$2738
   1338  28000 ????		27 39	    var1437    =	$2739
   1339  28000 ????		27 3a	    var1438    =	$273A
   1340  28000 ????		27 3b	    var1439    =	$273B
   1341  28000 ????		27 3c	    var1440    =	$273C
   1342  28000 ????		27 3d	    var1441    =	$273D
   1343  28000 ????		27 3e	    var1442    =	$273E
   1344  28000 ????		27 3f	    var1443    =	$273F
   1345  28000 ????		27 40	    var1444    =	$2740
   1346  28000 ????		27 41	    var1445    =	$2741
   1347  28000 ????		27 42	    var1446    =	$2742
   1348  28000 ????		27 43	    var1447    =	$2743
   1349  28000 ????		27 44	    var1448    =	$2744
   1350  28000 ????		27 45	    var1449    =	$2745
   1351  28000 ????		27 46	    var1450    =	$2746
   1352  28000 ????		27 47	    var1451    =	$2747
   1353  28000 ????		27 48	    var1452    =	$2748
   1354  28000 ????		27 49	    var1453    =	$2749
   1355  28000 ????		27 4a	    var1454    =	$274A
   1356  28000 ????		27 4b	    var1455    =	$274B
   1357  28000 ????		27 4c	    var1456    =	$274C
   1358  28000 ????		27 4d	    var1457    =	$274D
   1359  28000 ????		27 4e	    var1458    =	$274E
   1360  28000 ????		27 4f	    var1459    =	$274F
   1361  28000 ????		27 50	    var1460    =	$2750
   1362  28000 ????		27 51	    var1461    =	$2751
   1363  28000 ????		27 52	    var1462    =	$2752
   1364  28000 ????		27 53	    var1463    =	$2753
   1365  28000 ????		27 54	    var1464    =	$2754
   1366  28000 ????		27 55	    var1465    =	$2755
   1367  28000 ????		27 56	    var1466    =	$2756
   1368  28000 ????		27 57	    var1467    =	$2757
   1369  28000 ????		27 58	    var1468    =	$2758
   1370  28000 ????		27 59	    var1469    =	$2759
   1371  28000 ????		27 5a	    var1470    =	$275A
   1372  28000 ????		27 5b	    var1471    =	$275B
   1373  28000 ????		27 5c	    var1472    =	$275C
   1374  28000 ????		27 5d	    var1473    =	$275D
   1375  28000 ????		27 5e	    var1474    =	$275E
   1376  28000 ????		27 5f	    var1475    =	$275F
   1377  28000 ????		27 60	    var1476    =	$2760
   1378  28000 ????		27 61	    var1477    =	$2761
   1379  28000 ????		27 62	    var1478    =	$2762
   1380  28000 ????		27 63	    var1479    =	$2763
   1381  28000 ????		27 64	    var1480    =	$2764
   1382  28000 ????		27 65	    var1481    =	$2765
   1383  28000 ????		27 66	    var1482    =	$2766
   1384  28000 ????		27 67	    var1483    =	$2767
   1385  28000 ????		27 68	    var1484    =	$2768
   1386  28000 ????		27 69	    var1485    =	$2769
   1387  28000 ????		27 6a	    var1486    =	$276A
   1388  28000 ????		27 6b	    var1487    =	$276B
   1389  28000 ????		27 6c	    var1488    =	$276C
   1390  28000 ????		27 6d	    var1489    =	$276D
   1391  28000 ????		27 6e	    var1490    =	$276E
   1392  28000 ????		27 6f	    var1491    =	$276F
   1393  28000 ????		27 70	    var1492    =	$2770
   1394  28000 ????		27 71	    var1493    =	$2771
   1395  28000 ????		27 72	    var1494    =	$2772
   1396  28000 ????		27 73	    var1495    =	$2773
   1397  28000 ????		27 74	    var1496    =	$2774
   1398  28000 ????		27 75	    var1497    =	$2775
   1399  28000 ????		27 76	    var1498    =	$2776
   1400  28000 ????		27 77	    var1499    =	$2777
   1401  28000 ????		27 78	    var1500    =	$2778
   1402  28000 ????		27 79	    var1501    =	$2779
   1403  28000 ????		27 7a	    var1502    =	$277A
   1404  28000 ????		27 7b	    var1503    =	$277B
   1405  28000 ????		27 7c	    var1504    =	$277C
   1406  28000 ????		27 7d	    var1505    =	$277D
   1407  28000 ????		27 7e	    var1506    =	$277E
   1408  28000 ????		27 7f	    var1507    =	$277F
   1409  28000 ????		27 80	    var1508    =	$2780
   1410  28000 ????		27 81	    var1509    =	$2781
   1411  28000 ????		27 82	    var1510    =	$2782
   1412  28000 ????		27 83	    var1511    =	$2783
   1413  28000 ????		27 84	    var1512    =	$2784
   1414  28000 ????		27 85	    var1513    =	$2785
   1415  28000 ????		27 86	    var1514    =	$2786
   1416  28000 ????		27 87	    var1515    =	$2787
   1417  28000 ????		27 88	    var1516    =	$2788
   1418  28000 ????		27 89	    var1517    =	$2789
   1419  28000 ????		27 8a	    var1518    =	$278A
   1420  28000 ????		27 8b	    var1519    =	$278B
   1421  28000 ????		27 8c	    var1520    =	$278C
   1422  28000 ????		27 8d	    var1521    =	$278D
   1423  28000 ????		27 8e	    var1522    =	$278E
   1424  28000 ????		27 8f	    var1523    =	$278F
   1425  28000 ????		27 90	    var1524    =	$2790
   1426  28000 ????		27 91	    var1525    =	$2791
   1427  28000 ????		27 92	    var1526    =	$2792
   1428  28000 ????		27 93	    var1527    =	$2793
   1429  28000 ????		27 94	    var1528    =	$2794
   1430  28000 ????		27 95	    var1529    =	$2795
   1431  28000 ????		27 96	    var1530    =	$2796
   1432  28000 ????		27 97	    var1531    =	$2797
   1433  28000 ????		27 98	    var1532    =	$2798
   1434  28000 ????		27 99	    var1533    =	$2799
   1435  28000 ????		27 9a	    var1534    =	$279A
   1436  28000 ????		27 9b	    var1535    =	$279B
   1437  28000 ????		27 9c	    var1536    =	$279C
   1438  28000 ????		27 9d	    var1537    =	$279D
   1439  28000 ????		27 9e	    var1538    =	$279E
   1440  28000 ????		27 9f	    var1539    =	$279F
   1441  28000 ????		27 a0	    var1540    =	$27A0
   1442  28000 ????		27 a1	    var1541    =	$27A1
   1443  28000 ????		27 a2	    var1542    =	$27A2
   1444  28000 ????		27 a3	    var1543    =	$27A3
   1445  28000 ????		27 a4	    var1544    =	$27A4
   1446  28000 ????		27 a5	    var1545    =	$27A5
   1447  28000 ????		27 a6	    var1546    =	$27A6
   1448  28000 ????		27 a7	    var1547    =	$27A7
   1449  28000 ????		27 a8	    var1548    =	$27A8
   1450  28000 ????		27 a9	    var1549    =	$27A9
   1451  28000 ????		27 aa	    var1550    =	$27AA
   1452  28000 ????		27 ab	    var1551    =	$27AB
   1453  28000 ????		27 ac	    var1552    =	$27AC
   1454  28000 ????		27 ad	    var1553    =	$27AD
   1455  28000 ????		27 ae	    var1554    =	$27AE
   1456  28000 ????		27 af	    var1555    =	$27AF
   1457  28000 ????		27 b0	    var1556    =	$27B0
   1458  28000 ????		27 b1	    var1557    =	$27B1
   1459  28000 ????		27 b2	    var1558    =	$27B2
   1460  28000 ????		27 b3	    var1559    =	$27B3
   1461  28000 ????		27 b4	    var1560    =	$27B4
   1462  28000 ????		27 b5	    var1561    =	$27B5
   1463  28000 ????		27 b6	    var1562    =	$27B6
   1464  28000 ????		27 b7	    var1563    =	$27B7
   1465  28000 ????		27 b8	    var1564    =	$27B8
   1466  28000 ????		27 b9	    var1565    =	$27B9
   1467  28000 ????		27 ba	    var1566    =	$27BA
   1468  28000 ????		27 bb	    var1567    =	$27BB
   1469  28000 ????		27 bc	    var1568    =	$27BC
   1470  28000 ????		27 bd	    var1569    =	$27BD
   1471  28000 ????		27 be	    var1570    =	$27BE
   1472  28000 ????		27 bf	    var1571    =	$27BF
   1473  28000 ????		27 c0	    var1572    =	$27C0
   1474  28000 ????		27 c1	    var1573    =	$27C1
   1475  28000 ????		27 c2	    var1574    =	$27C2
   1476  28000 ????		27 c3	    var1575    =	$27C3
   1477  28000 ????		27 c4	    var1576    =	$27C4
   1478  28000 ????		27 c5	    var1577    =	$27C5
   1479  28000 ????		27 c6	    var1578    =	$27C6
   1480  28000 ????		27 c7	    var1579    =	$27C7
   1481  28000 ????		27 c8	    var1580    =	$27C8
   1482  28000 ????		27 c9	    var1581    =	$27C9
   1483  28000 ????		27 ca	    var1582    =	$27CA
   1484  28000 ????		27 cb	    var1583    =	$27CB
   1485  28000 ????		27 cc	    var1584    =	$27CC
   1486  28000 ????		27 cd	    var1585    =	$27CD
   1487  28000 ????		27 ce	    var1586    =	$27CE
   1488  28000 ????		27 cf	    var1587    =	$27CF
   1489  28000 ????		27 d0	    var1588    =	$27D0
   1490  28000 ????		27 d1	    var1589    =	$27D1
   1491  28000 ????		27 d2	    var1590    =	$27D2
   1492  28000 ????		27 d3	    var1591    =	$27D3
   1493  28000 ????		27 d4	    var1592    =	$27D4
   1494  28000 ????		27 d5	    var1593    =	$27D5
   1495  28000 ????		27 d6	    var1594    =	$27D6
   1496  28000 ????		27 d7	    var1595    =	$27D7
   1497  28000 ????		27 d8	    var1596    =	$27D8
   1498  28000 ????		27 d9	    var1597    =	$27D9
   1499  28000 ????		27 da	    var1598    =	$27DA
   1500  28000 ????		27 db	    var1599    =	$27DB
   1501  28000 ????		27 dc	    var1600    =	$27DC
   1502  28000 ????		27 dd	    var1601    =	$27DD
   1503  28000 ????		27 de	    var1602    =	$27DE
   1504  28000 ????		27 df	    var1603    =	$27DF
   1505  28000 ????		27 e0	    var1604    =	$27E0
   1506  28000 ????		27 e1	    var1605    =	$27E1
   1507  28000 ????		27 e2	    var1606    =	$27E2
   1508  28000 ????		27 e3	    var1607    =	$27E3
   1509  28000 ????		27 e4	    var1608    =	$27E4
   1510  28000 ????		27 e5	    var1609    =	$27E5
   1511  28000 ????		27 e6	    var1610    =	$27E6
   1512  28000 ????		27 e7	    var1611    =	$27E7
   1513  28000 ????		27 e8	    var1612    =	$27E8
   1514  28000 ????		27 e9	    var1613    =	$27E9
   1515  28000 ????		27 ea	    var1614    =	$27EA
   1516  28000 ????		27 eb	    var1615    =	$27EB
   1517  28000 ????		27 ec	    var1616    =	$27EC
   1518  28000 ????		27 ed	    var1617    =	$27ED
   1519  28000 ????		27 ee	    var1618    =	$27EE
   1520  28000 ????		27 ef	    var1619    =	$27EF
   1521  28000 ????		27 f0	    var1620    =	$27F0
   1522  28000 ????		27 f1	    var1621    =	$27F1
   1523  28000 ????		27 f2	    var1622    =	$27F2
   1524  28000 ????		27 f3	    var1623    =	$27F3
   1525  28000 ????		27 f4	    var1624    =	$27F4
   1526  28000 ????		27 f5	    var1625    =	$27F5
   1527  28000 ????		27 f6	    var1626    =	$27F6
   1528  28000 ????		27 f7	    var1627    =	$27F7
   1529  28000 ????		27 f8	    var1628    =	$27F8
   1530  28000 ????		27 f9	    var1629    =	$27F9
   1531  28000 ????		27 fa	    var1630    =	$27FA
   1532  28000 ????		27 fb	    var1631    =	$27FB
   1533  28000 ????		27 fc	    var1632    =	$27FC
   1534  28000 ????		27 fd	    var1633    =	$27FD
   1535  28000 ????		27 fe	    var1634    =	$27FE
   1536  28000 ????		27 ff	    var1635    =	$27FF
------- FILE c:\Users\seany\Documents\irata\0087_Irata.78b.asm
   1474  28000 ????
   1475  28000 ????						; BEADHEADER... disabled for now
   1476  28000 ????						; A BEAD header gets automatically incorportated into the ROM header. 
   1477  28000 ????						; For more BEAD executable info, check out the spec...
   1478  28000 ????						; http://7800.8bitdev.org/index.php/The_Atari_7800_BEAD_Execuable_Specification
   1479  28000 ????
   1480  28000 ????		00 01	    GAMEDESCRIPTIONSET =	1
   1481  28000 ????		4e 61 6d 65 GAMEDESCRIPTION =	"Test Name"
   1482  28000 ????
   1483  28000 ????
   1484  28000 ????		00 40	    BDHSC      =	%01000000
   1485  28000 ????		00 20	    BDYM       =	%00100000
   1486  28000 ????		00 10	    BDPOKEY    =	%00010000
   1487  28000 ????		00 08	    BDROF      =	%00001000
   1488  28000 ????		00 00	    BD16K      =	%00000000
   1489  28000 ????		00 01	    BD32K      =	%00000001
   1490  28000 ????		00 02	    BD48K      =	%00000010
   1491  28000 ????		00 05	    BD1800     =	%00000101
   1492  28000 ????		00 06	    BD4000     =	%00000110
   1493  28000 ????
   1494  28000 ????			   -	       ifconst	BEADHEADER
   1495  28000 ????			   -BEADHARDWARE SET	0
   1496  28000 ????			   -	       ifconst	ROM16K
   1497  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD16K)
   1498  28000 ????			   -	       endif
   1499  28000 ????			   -	       ifconst	ROM32K
   1500  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD32K)
   1501  28000 ????			   -	       endif
   1502  28000 ????			   -	       ifconst	ROM48K
   1503  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD48K)
   1504  28000 ????			   -	       endif
   1505  28000 ????			   -	       ifconst	pokeysupport
   1506  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BDPOKEY)
   1507  28000 ????			   -	       endif
   1508  28000 ????			   -	       ifconst	HSSUPPORT
   1509  28000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BDHSC)
   1510  28000 ????			   -	       endif
   1511  28000 ????				       endif
   1512  28000 ????
   1513  28000 ????						;start address of cart...
   1514  28000 ????
   1515  28000 ????			    BANK_WAS_SET SET	0
   1516  28000 ????
   1517  28000 ????			   -	       ifconst	ROM8K
   1518  28000 ????			   -	       ORG	$E000,0
   1519  28000 ????			   -BANK_WAS_SET SET	1
   1520  28000 ????				       endif		; ROM8K
   1521  28000 ????
   1522  28000 ????			   -	       ifconst	ROM16K
   1523  28000 ????			   -	       ORG	$C000,0
   1524  28000 ????			   -BANK_WAS_SET SET	1
   1525  28000 ????			   -	       ifconst	BEADHEADER
   1526  28000 ????			   -	       .byte	$BE,$AD,BEADHARDWARE
   1527  28000 ????			   -	       ifconst	GAMEDESCRIPTION
   1528  28000 ????			   -	       CLC
   1529  28000 ????			   -	       BCC	_SKIPDESCRIPTION
   1530  28000 ????			   -	       .byte	GAMEDESCRIPTION,0
   1531  28000 ????			   -_SKIPDESCRIPTION
   1532  28000 ????			   -	       endif		; GAMEDESCRIPTION
   1533  28000 ????			   -	       jmp	($FFFC)
   1534  28000 ????			   -	       endif		; BEADHEADER
   1535  28000 ????				       endif		; ROM16K
   1536  28000 ????
   1537  28000 ????			   -	       ifconst	ROM32K
   1538  28000 ????			   -	       ORG	$8000,0
   1539  28000 ????			   -BANK_WAS_SET SET	1
   1540  28000 ????			   -	       ifconst	BEADHEADER
   1541  28000 ????			   -	       .byte	$BE,$AD,BEADHARDWARE
   1542  28000 ????			   -	       ifconst	GAMEDESCRIPTION
   1543  28000 ????			   -	       CLC
   1544  28000 ????			   -	       BCC	_SKIPDESCRIPTION
   1545  28000 ????			   -	       .byte	GAMEDESCRIPTION,0
   1546  28000 ????			   -_SKIPDESCRIPTION
   1547  28000 ????			   -	       endif		; GAMEDESCRIPTION
   1548  28000 ????			   -	       jmp	($FFFC)
   1549  28000 ????			   -	       endif		; BEADHEADER
   1550  28000 ????				       endif		; ROM32K
   1551  28000 ????
   1552  28000 ????			   -	       ifconst	ROM48K
   1553  28000 ????			   -	       ORG	$4000,0
   1554  28000 ????			   -BANK_WAS_SET SET	1
   1555  28000 ????			   -	       ifconst	BEADHEADER
   1556  28000 ????			   -	       .byte	$BE,$AD,BEADHARDWARE
   1557  28000 ????			   -	       ifconst	GAMEDESCRIPTIONSET
   1558  28000 ????			   -	       CLC
   1559  28000 ????			   -	       BCC	_SKIPDESCRIPTION
   1560  28000 ????			   -	       .byte	GAMEDESCRIPTION,0
   1561  28000 ????			   -_SKIPDESCRIPTION
   1562  28000 ????			   -	       endif		; GAMEDESCRIPTIONSET
   1563  28000 ????			   -	       jmp	($FFFC)
   1564  28000 ????			   -	       endif		; BEADHEADER
   1565  28000 ????				       endif		; ROM48K
   1566  28000 ????
   1567  28000 ????			   -	       ifconst	ROM52K
   1568  28000 ????			   -BANK_WAS_SET SET	1
   1569  28000 ????			   -	       ORG	$3000,0
   1570  28000 ????				       endif		; ROM52K
   1571  28000 ????
   1572  28000 ????				       ifconst	bankswitchmode
   1573  28000 ????			   -	       ifconst	ROMAT4K
   1574  28000 ????			   -BANK_WAS_SET SET	1
   1575  28000 ????			   -	       ORG	$4000,0
   1576  28000 ????			   -	       RORG	$4000
   1577  28000 ????				       else		; ROMAT4K
   1578  28000 ????			    BANK_WAS_SET SET	1
   1579  8000					      ORG	$8000,0
   1580  8000					      RORG	$8000
   1581  8000					      endif
   1582  8000					      endif
   1583  8000
   1584  8000				  -	      if	BANK_WAS_SET = 0
   1585  8000				  -	      ORG	$8000,0	; default is 32K
   1586  8000					      endif
   1587  8000
   1588  8000				   START_OF_ROM SET	.
   1589  8000				   SPACEOVERFLOW SET	0
   1590  8000				  -	      ifnconst	SPACEOVERFLOWPASS
   1591  8000				  -SPACEOVERFLOWPASS SET	0
   1592  8000					      endif	SPACEOVERFLOWPASS
   1593  8000				   game
   1594  8000				   .
   1595  8000							;;line 1;; 
   1596  8000
   1597  8000				   .L00 		;;line 2;;  set 7800header 'Irata^Battle'
   1598  8000
   1599  8000				   .L01 		;;line 3;;  set tv NTSC
   1600  8000
   1601  8000				   .
   1602  8000							;;line 4;; 
   1603  8000
   1604  8000				   .
   1605  8000							;;line 5;; 
   1606  8000
   1607  8000				   .L02 		;;line 6;;  set zoneheight 16
   1608  8000
   1609  8000				   .L03 		;;line 7;;  displaymode 160A
   1610  8000
   1611  8000		       a9 40		      lda	#%01000000	;Enable DMA, mode=160x2/160x4
   1612  8002		       85 3c		      sta	CTRL
   1613  8004
   1614  8004		       8d 07 21 	      sta	sCTRL
   1615  8007
   1616  8007				   .L04 		;;line 8;;  set plotvalueonscreen on
   1617  8007
   1618  8007				   .L05 		;;line 9;;  set romsize 128k
   1619  8007
   1620  8007				   .
   1621  8007							;;line 10;; 
   1622  8007
   1623  8007				   .L06 		;;line 11;;  incgraphic font.png 160A
   1624  8007
   1625  8007				   .L07 		;;line 12;;  characterset font
   1626  8007
   1627  8007		       a9 a0		      lda	#>font
   1628  8009		       8d 0b 21 	      sta	sCHARBASE
   1629  800c
   1630  800c		       85 34		      sta	CHARBASE
   1631  800e		       a9 60		      lda	#(font_mode | %01100000)
   1632  8010		       8d 06 21 	      sta	charactermode
   1633  8013
   1634  8013				   .L08 		;;line 13;;  alphachars '0123456789abcdefghijklmnopqrstuvwxyz>`?!/.,-_()[]&AB '
   1635  8013
   1636  8013				   .
   1637  8013							;;line 14;; 
   1638  8013
   1639  8013				   .L09 		;;line 15;;  rem pallette 0 text
   1640  8013
   1641  8013				   .L010		;;line 16;;  P0C1 = $0F
   1642  8013
   1643  8013		       a9 0f		      lda	#$0F
   1644  8015		       85 21		      sta	P0C1
   1645  8017				   .L011		;;line 17;;  P0C2 = $0C
   1646  8017
   1647  8017		       a9 0c		      lda	#$0C
   1648  8019		       85 22		      sta	P0C2
   1649  801b				   .L012		;;line 18;;  P0C3 = $0A
   1650  801b
   1651  801b		       a9 0a		      lda	#$0A
   1652  801d		       85 23		      sta	P0C3
   1653  801f				   .
   1654  801f							;;line 19;; 
   1655  801f
   1656  801f				   .L013		;;line 20;;  rem sprites
   1657  801f
   1658  801f				   .L014		;;line 21;;  incgraphic images/player.png 160A 0 1 3 2
   1659  801f
   1660  801f				   .L015		;;line 22;;  incgraphic images/missle.png 160A 0 1 3 2
   1661  801f
   1662  801f				   .
   1663  801f							;;line 23;; 
   1664  801f
   1665  801f				   .L016		;;line 24;;  rem pallette 1 player
   1666  801f
   1667  801f				   .L017		;;line 25;;  P1C1 = $0F
   1668  801f
   1669  801f		       a9 0f		      lda	#$0F
   1670  8021		       85 25		      sta	P1C1
   1671  8023				   .
   1672  8023							;;line 26;; 
   1673  8023
   1674  8023				   .
   1675  8023							;;line 27;; 
   1676  8023
   1677  8023				   .L018		;;line 28;;  BACKGRND = $00
   1678  8023
   1679  8023		       a9 00		      lda	#$00
   1680  8025		       85 20		      sta	BACKGRND
   1681  8027				   .
   1682  8027							;;line 29;; 
   1683  8027
   1684  8027				   .L019		;;line 30;;  dim bgColor = var1
   1685  8027
   1686  8027				   .L020		;;line 31;;  dim wait = var2
   1687  8027
   1688  8027				   .L021		;;line 32;;  dim lives = var3
   1689  8027
   1690  8027				   .L022		;;line 33;;  dim score = var4
   1691  8027
   1692  8027				   .L023		;;line 34;;  dim playerX = var5
   1693  8027
   1694  8027				   .L024		;;line 35;;  dim playerY = var6
   1695  8027
   1696  8027				   .L025		;;line 36;;  dim missle_fire_xpos = var7
   1697  8027
   1698  8027				   .L026		;;line 37;;  dim missle_fire_ypos = var8
   1699  8027
   1700  8027				   .L027		;;line 38;;  dim starting = var9
   1701  8027
   1702  8027				   .
   1703  8027							;;line 39;; 
   1704  8027
   1705  8027				   .L028		;;line 40;;  bgColor = 0
   1706  8027
   1707  8027		       a9 00		      lda	#0
   1708  8029		       8d 41 01 	      sta	bgColor
   1709  802c				   .L029		;;line 41;;  wait = 0
   1710  802c
   1711  802c		       a9 00		      lda	#0
   1712  802e		       8d 42 01 	      sta	wait
   1713  8031				   .L030		;;line 42;;  lives = 0
   1714  8031
   1715  8031		       a9 00		      lda	#0
   1716  8033		       8d 43 01 	      sta	lives
   1717  8036				   .L031		;;line 43;;  score = 0
   1718  8036
   1719  8036		       a9 00		      lda	#0
   1720  8038		       8d 44 01 	      sta	score
   1721  803b				   .L032		;;line 44;;  playerX = 0
   1722  803b
   1723  803b		       a9 00		      lda	#0
   1724  803d		       8d 45 01 	      sta	playerX
   1725  8040				   .L033		;;line 45;;  playerY = 0
   1726  8040
   1727  8040		       a9 00		      lda	#0
   1728  8042		       8d 46 01 	      sta	playerY
   1729  8045				   .L034		;;line 46;;  missle_fire_xpos = 0
   1730  8045
   1731  8045		       a9 00		      lda	#0
   1732  8047		       8d 47 01 	      sta	missle_fire_xpos
   1733  804a				   .L035		;;line 47;;  missle_fire_ypos = 0
   1734  804a
   1735  804a		       a9 00		      lda	#0
   1736  804c		       8d 48 01 	      sta	missle_fire_ypos
   1737  804f				   .L036		;;line 48;;  starting = 1
   1738  804f
   1739  804f		       a9 01		      lda	#1
   1740  8051		       8d 49 01 	      sta	starting
   1741  8054				   .
   1742  8054							;;line 49;; 
   1743  8054
   1744  8054				   ._titleLoop
   1745  8054							;;line 50;; _titleLoop
   1746  8054
   1747  8054				   .L037		;;line 51;;  clearscreen
   1748  8054
   1749  8054		       20 7f f0 	      jsr	clearscreen
   1750  8057				   .L038		;;line 52;;  BACKGRND = bgColor
   1751  8057
   1752  8057		       ad 41 01 	      lda	bgColor
   1753  805a		       85 20		      sta	BACKGRND
   1754  805c				   .
   1755  805c							;;line 53;; 
   1756  805c
   1757  805c				   .L039		;;line 54;;  plotchars 'welcome^irata^warrior!' 0 58 5
   1758  805c
   1759  805c		       4c 75 80 	      JMP	skipalphadata0
   1760  805f				   alphadata0
   1761  805f		       20		      .byte.b	(<font + $20)
   1762  8060		       0e		      .byte.b	(<font + $0e)
   1763  8061		       15		      .byte.b	(<font + $15)
   1764  8062		       0c		      .byte.b	(<font + $0c)
   1765  8063		       18		      .byte.b	(<font + $18)
   1766  8064		       16		      .byte.b	(<font + $16)
   1767  8065		       0e		      .byte.b	(<font + $0e)
   1768  8066		       34		      .byte.b	(<font + $34)
   1769  8067		       12		      .byte.b	(<font + $12)
   1770  8068		       1b		      .byte.b	(<font + $1b)
   1771  8069		       0a		      .byte.b	(<font + $0a)
   1772  806a		       1d		      .byte.b	(<font + $1d)
   1773  806b		       0a		      .byte.b	(<font + $0a)
   1774  806c		       34		      .byte.b	(<font + $34)
   1775  806d		       20		      .byte.b	(<font + $20)
   1776  806e		       0a		      .byte.b	(<font + $0a)
   1777  806f		       1b		      .byte.b	(<font + $1b)
   1778  8070		       1b		      .byte.b	(<font + $1b)
   1779  8071		       12		      .byte.b	(<font + $12)
   1780  8072		       18		      .byte.b	(<font + $18)
   1781  8073		       1b		      .byte.b	(<font + $1b)
   1782  8074		       27		      .byte.b	(<font + $27)
   1783  8075				   skipalphadata0
   1784  8075		       a9 0a		      lda	#10	; width in two's complement
   1785  8077		       09 00		      ora	#0	; palette left shifted 5 bits
   1786  8079		       85 44		      sta	temp3
   1787  807b		       a9 5f		      lda	#<alphadata0
   1788  807d		       85 42		      sta	temp1
   1789  807f
   1790  807f		       a9 80		      lda	#>alphadata0
   1791  8081		       85 43		      sta	temp2
   1792  8083
   1793  8083		       a9 3a		      lda	#58
   1794  8085		       85 45		      sta	temp4
   1795  8087
   1796  8087		       a9 05		      lda	#5
   1797  8089
   1798  8089		       85 46		      sta	temp5
   1799  808b
   1800  808b		       20 94 f3 	      jsr	plotcharacters
   1801  808e				   .
   1802  808e							;;line 55;; 
   1803  808e
   1804  808e				   .L040		;;line 56;;  drawscreen
   1805  808e
   1806  808e		       20 b3 f0 	      jsr	drawscreen
   1807  8091				   .L041		;;line 57;;  if joy0fire  ||  joy0fire1 then goto _initGame
   1808  8091
   1809  8091		       2c 02 21 	      bit	sINPT1
   1810  8094		       10 03		      bpl	.skipL041
   1811  8096				   .condpart0
   1812  8096		       4c 9e 80 	      jmp	.condpart1
   1813  8099				   .skipL041
   1814  8099		       2c 02 21 	      bit	sINPT1
   1815  809c		       10 03		      bpl	.skip0OR
   1816  809e				   .condpart1
   1817  809e		       4c a4 80 	      jmp	._initGame
   1818  80a1
   1819  80a1				   .skip0OR
   1820  80a1				   .
   1821  80a1							;;line 58;; 
   1822  80a1
   1823  80a1				   .L042		;;line 59;;  goto _titleLoop
   1824  80a1
   1825  80a1		       4c 54 80 	      jmp	._titleLoop
   1826  80a4
   1827  80a4				   .
   1828  80a4							;;line 60;; 
   1829  80a4
   1830  80a4				   ._initGame
   1831  80a4							;;line 61;; _initGame
   1832  80a4
   1833  80a4				   .L043		;;line 62;;  clearscreen
   1834  80a4
   1835  80a4		       20 7f f0 	      jsr	clearscreen
   1836  80a7				   .L044		;;line 63;;  lives = 3
   1837  80a7
   1838  80a7		       a9 03		      lda	#3
   1839  80a9		       8d 43 01 	      sta	lives
   1840  80ac				   .L045		;;line 64;;  score = 0
   1841  80ac
   1842  80ac		       a9 00		      lda	#0
   1843  80ae		       8d 44 01 	      sta	score
   1844  80b1				   .L046		;;line 65;;  playerX = 70
   1845  80b1
   1846  80b1		       a9 46		      lda	#70
   1847  80b3		       8d 45 01 	      sta	playerX
   1848  80b6				   .L047		;;line 66;;  playerY = 170
   1849  80b6
   1850  80b6		       a9 aa		      lda	#170
   1851  80b8		       8d 46 01 	      sta	playerY
   1852  80bb				   .L048		;;line 67;;  missle_fire_xpos = 70
   1853  80bb
   1854  80bb		       a9 46		      lda	#70
   1855  80bd		       8d 47 01 	      sta	missle_fire_xpos
   1856  80c0				   .L049		;;line 68;;  missle_fire_ypos = 170
   1857  80c0
   1858  80c0		       a9 aa		      lda	#170
   1859  80c2		       8d 48 01 	      sta	missle_fire_ypos
   1860  80c5				   .L050		;;line 69;;  starting = 1
   1861  80c5
   1862  80c5		       a9 01		      lda	#1
   1863  80c7		       8d 49 01 	      sta	starting
   1864  80ca				   ._gameLoop
   1865  80ca							;;line 70;; _gameLoop
   1866  80ca
   1867  80ca				   .
   1868  80ca							;;line 71;; 
   1869  80ca
   1870  80ca				   .L051		;;line 72;;  clearscreen
   1871  80ca
   1872  80ca		       20 7f f0 	      jsr	clearscreen
   1873  80cd				   .
   1874  80cd							;;line 73;; 
   1875  80cd
   1876  80cd				   .L052		;;line 74;;  rem plotchars 'game'  0 68 5
   1877  80cd
   1878  80cd				   .L053		;;line 75;;  if playerX < 1 then playerX = 1
   1879  80cd
   1880  80cd		       ad 45 01 	      lda	playerX
   1881  80d0		       c9 01		      cmp	#1
   1882  80d2		       b0 05		      bcs	.skipL053
   1883  80d4				   .condpart2
   1884  80d4		       a9 01		      lda	#1
   1885  80d6		       8d 45 01 	      sta	playerX
   1886  80d9				   .skipL053
   1887  80d9				   .L054		;;line 76;;  if playerX > 145 then playerX = 145
   1888  80d9
   1889  80d9		       a9 91		      lda	#145
   1890  80db		       cd 45 01 	      cmp	playerX
   1891  80de		       b0 05		      bcs	.skipL054
   1892  80e0				   .condpart3
   1893  80e0		       a9 91		      lda	#145
   1894  80e2		       8d 45 01 	      sta	playerX
   1895  80e5				   .skipL054
   1896  80e5				   .
   1897  80e5							;;line 77;; 
   1898  80e5
   1899  80e5				   .L055		;;line 78;;  plotsprite player 1 playerX playerY
   1900  80e5
   1901  80e5		       a9 35		      lda	#<player
   1902  80e7		       85 42		      sta	temp1
   1903  80e9
   1904  80e9		       a9 a0		      lda	#>player
   1905  80eb		       85 43		      sta	temp2
   1906  80ed
   1907  80ed		       a9 3c		      lda	#(32|player_width_twoscompliment)
   1908  80ef		       85 44		      sta	temp3
   1909  80f1
   1910  80f1		       ad 45 01 	      lda	playerX
   1911  80f4		       85 45		      sta	temp4
   1912  80f6
   1913  80f6		       ad 46 01 	      lda	playerY
   1914  80f9
   1915  80f9		       85 46		      sta	temp5
   1916  80fb
   1917  80fb		       a9 40		      lda	#(player_mode|%01000000)
   1918  80fd		       85 47		      sta	temp6
   1919  80ff
   1920  80ff		       20 e3 f2 	      jsr	plotsprite
   1921  8102				   .L056		;;line 79;;  if joy0left then playerX = playerX  -  1
   1922  8102
   1923  8102		       2c 31 21 	      bit	sSWCHA
   1924  8105		       70 09		      bvs	.skipL056
   1925  8107				   .condpart4
   1926  8107		       ad 45 01 	      lda	playerX
   1927  810a		       38		      SEC
   1928  810b		       e9 01		      SBC	#1
   1929  810d		       8d 45 01 	      sta	playerX
   1930  8110				   .skipL056
   1931  8110				   .L057		;;line 80;;  if joy0right then playerX = playerX  +  1
   1932  8110
   1933  8110		       2c 31 21 	      bit	sSWCHA
   1934  8113		       30 09		      bmi	.skipL057
   1935  8115				   .condpart5
   1936  8115		       ad 45 01 	      lda	playerX
   1937  8118		       18		      CLC
   1938  8119		       69 01		      ADC	#1
   1939  811b		       8d 45 01 	      sta	playerX
   1940  811e				   .skipL057
   1941  811e				   .L058		;;line 81;;  if joy0fire  ||  joy0fire1 then goto _initMissle
   1942  811e
   1943  811e		       2c 02 21 	      bit	sINPT1
   1944  8121		       10 03		      bpl	.skipL058
   1945  8123				   .condpart6
   1946  8123		       4c 2b 81 	      jmp	.condpart7
   1947  8126				   .skipL058
   1948  8126		       2c 02 21 	      bit	sINPT1
   1949  8129		       10 03		      bpl	.skip1OR
   1950  812b				   .condpart7
   1951  812b		       4c 39 81 	      jmp	._initMissle
   1952  812e
   1953  812e				   .skip1OR
   1954  812e				   .
   1955  812e							;;line 82;; 
   1956  812e
   1957  812e				   .
   1958  812e							;;line 83;; 
   1959  812e
   1960  812e				   .L059		;;line 84;;  drawscreen
   1961  812e
   1962  812e		       20 b3 f0 	      jsr	drawscreen
   1963  8131				   .
   1964  8131							;;line 85;; 
   1965  8131
   1966  8131				   .L060		;;line 86;;  starting = 0
   1967  8131
   1968  8131		       a9 00		      lda	#0
   1969  8133		       8d 49 01 	      sta	starting
   1970  8136				   .L061		;;line 87;;  goto _gameLoop
   1971  8136
   1972  8136		       4c ca 80 	      jmp	._gameLoop
   1973  8139
   1974  8139				   .
   1975  8139							;;line 88;; 
   1976  8139
   1977  8139				   ._initMissle
   1978  8139							;;line 89;; _initMissle
   1979  8139
   1980  8139				   .L062		;;line 90;;  if starting  >  0 then goto _gameLoop
   1981  8139
   1982  8139		       a9 00		      lda	#0
   1983  813b		       cd 49 01 	      cmp	starting
   1984  813e		       b0 03		      bcs	.skipL062
   1985  8140				   .condpart8
   1986  8140		       4c ca 80 	      jmp	._gameLoop
   1987  8143
   1988  8143				   .skipL062
   1989  8143				   .
   1990  8143							;;line 91;; 
   1991  8143
   1992  8143				   .L063		;;line 92;;  missle_fire_xpos = playerX
   1993  8143
   1994  8143		       ad 45 01 	      lda	playerX
   1995  8146		       8d 47 01 	      sta	missle_fire_xpos
   1996  8149				   .L064		;;line 93;;  missle_fire_ypos = playerY  -  10
   1997  8149
   1998  8149		       ad 46 01 	      lda	playerY
   1999  814c		       38		      SEC
   2000  814d		       e9 0a		      SBC	#10
   2001  814f		       8d 48 01 	      sta	missle_fire_ypos
   2002  8152				   .
   2003  8152							;;line 94;; 
   2004  8152
   2005  8152				   .
   2006  8152							;;line 95;; 
   2007  8152
   2008  8152				   .
   2009  8152							;;line 96;; 
   2010  8152
   2011  8152				   ._missleLoop
   2012  8152							;;line 97;; _missleLoop
   2013  8152
   2014  8152				   .
   2015  8152							;;line 98;; 
   2016  8152
   2017  8152				   .L065		;;line 99;;  clearscreen
   2018  8152
   2019  8152		       20 7f f0 	      jsr	clearscreen
   2020  8155				   .L066		;;line 100;;  plotsprite player 1 playerX playerY
   2021  8155
   2022  8155		       a9 35		      lda	#<player
   2023  8157		       85 42		      sta	temp1
   2024  8159
   2025  8159		       a9 a0		      lda	#>player
   2026  815b		       85 43		      sta	temp2
   2027  815d
   2028  815d		       a9 3c		      lda	#(32|player_width_twoscompliment)
   2029  815f		       85 44		      sta	temp3
   2030  8161
   2031  8161		       ad 45 01 	      lda	playerX
   2032  8164		       85 45		      sta	temp4
   2033  8166
   2034  8166		       ad 46 01 	      lda	playerY
   2035  8169
   2036  8169		       85 46		      sta	temp5
   2037  816b
   2038  816b		       a9 40		      lda	#(player_mode|%01000000)
   2039  816d		       85 47		      sta	temp6
   2040  816f
   2041  816f		       20 e3 f2 	      jsr	plotsprite
   2042  8172				   .
   2043  8172							;;line 101;; 
   2044  8172
   2045  8172				   .L067		;;line 102;;  plotsprite missle 1 missle_fire_xpos missle_fire_ypos
   2046  8172
   2047  8172		       a9 39		      lda	#<missle
   2048  8174		       85 42		      sta	temp1
   2049  8176
   2050  8176		       a9 a0		      lda	#>missle
   2051  8178		       85 43		      sta	temp2
   2052  817a
   2053  817a		       a9 3c		      lda	#(32|missle_width_twoscompliment)
   2054  817c		       85 44		      sta	temp3
   2055  817e
   2056  817e		       ad 47 01 	      lda	missle_fire_xpos
   2057  8181		       85 45		      sta	temp4
   2058  8183
   2059  8183		       ad 48 01 	      lda	missle_fire_ypos
   2060  8186
   2061  8186		       85 46		      sta	temp5
   2062  8188
   2063  8188		       a9 40		      lda	#(missle_mode|%01000000)
   2064  818a		       85 47		      sta	temp6
   2065  818c
   2066  818c		       20 e3 f2 	      jsr	plotsprite
   2067  818f				   .L068		;;line 103;;  missle_fire_ypos = missle_fire_ypos  -  1
   2068  818f
   2069  818f		       ad 48 01 	      lda	missle_fire_ypos
   2070  8192		       38		      SEC
   2071  8193		       e9 01		      SBC	#1
   2072  8195		       8d 48 01 	      sta	missle_fire_ypos
   2073  8198				   .L069		;;line 104;;  if missle_fire_ypos  <  1 then goto _gameLoop
   2074  8198
   2075  8198		       ad 48 01 	      lda	missle_fire_ypos
   2076  819b		       c9 01		      cmp	#1
   2077  819d		       b0 03		      bcs	.skipL069
   2078  819f				   .condpart9
   2079  819f		       4c ca 80 	      jmp	._gameLoop
   2080  81a2
   2081  81a2				   .skipL069
   2082  81a2				   .L070		;;line 105;;  if joy0left then playerX = playerX  -  1
   2083  81a2
   2084  81a2		       2c 31 21 	      bit	sSWCHA
   2085  81a5		       70 09		      bvs	.skipL070
   2086  81a7				   .condpart10
   2087  81a7		       ad 45 01 	      lda	playerX
   2088  81aa		       38		      SEC
   2089  81ab		       e9 01		      SBC	#1
   2090  81ad		       8d 45 01 	      sta	playerX
   2091  81b0				   .skipL070
   2092  81b0				   .L071		;;line 106;;  if joy0right then playerX = playerX  +  1
   2093  81b0
   2094  81b0		       2c 31 21 	      bit	sSWCHA
   2095  81b3		       30 09		      bmi	.skipL071
   2096  81b5				   .condpart11
   2097  81b5		       ad 45 01 	      lda	playerX
   2098  81b8		       18		      CLC
   2099  81b9		       69 01		      ADC	#1
   2100  81bb		       8d 45 01 	      sta	playerX
   2101  81be				   .skipL071
   2102  81be				   .
   2103  81be							;;line 107;; 
   2104  81be
   2105  81be				   .L072		;;line 108;;  drawscreen
   2106  81be
   2107  81be		       20 b3 f0 	      jsr	drawscreen
   2108  81c1				   .
   2109  81c1							;;line 109;; 
   2110  81c1
   2111  81c1				   .L073		;;line 110;;  goto _missleLoop
   2112  81c1		       4c 52 81 	      jmp	._missleLoop
   2113  81c1				   DMAHOLEEND0 SET	.
   2114  81c4				   gameend
   2115  81c4				   DMAHOLEEND0 SET	.
   7740 bytes of ROM space left in the main area of bank 1.
   2116  81c4					      echo	" ",[($A000 - .)]d , "bytes of ROM space left in the main area of bank 1."
   2117  81c4				  -	      if	($A000 - .) < 0
   2118  81c4				  -SPACEOVERFLOW SET	(SPACEOVERFLOW+1)
   2119  81c4					      endif
   2120  81c4				  -	      if	START_OF_ROM = .	; avoid dasm empty start-rom truncation.
   2121  81c4				  -	      .byte	0
   2122  81c4					      endif
   2123  81c4				   START_OF_ROM SET	0	; scuttle so we always fail subsequent banks
   2124  81c4
   2125  a000					      ORG	$A000,0	; *************
   2126  a000
   2127  a000					      RORG	$A000	; *************
   2128  a000
   2129  a000		       a0 00	   font       =	$A000
   2130  a000
   2131  a000				   font
   2132  a000		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2133  a020		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   2134  a020		       a0 35	   player     =	$A035
   2135  a035
   2136  a035				   player
   2137  a035		       00 00 00 00	      HEX	00000000
   2138  a035		       a0 39	   missle     =	$A039
   2139  a039
   2140  a039				   missle
   2141  a039		       00 00 00 00	      HEX	00000000
   2142  a03d
   2143  a100					      ORG	$A100,0	; *************
   2144  a100
   2145  a100					      RORG	$A100	; *************
   2146  a100
   2147  a100							;font
   2148  a100		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2149  a120		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   2150  a135							;player
   2151  a135		       14 00 00 50	      HEX	14000050
   2152  a139							;missle
   2153  a139		       00 55 55 00	      HEX	00555500
   2154  a13d
   2155  a200					      ORG	$A200,0	; *************
   2156  a200
   2157  a200					      RORG	$A200	; *************
   2158  a200
   2159  a200							;font
   2160  a200		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2161  a220		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   2162  a235							;player
   2163  a235		       05 45 45 40	      HEX	05454540
   2164  a239							;missle
   2165  a239		       00 55 55 00	      HEX	00555500
   2166  a23d
   2167  a300					      ORG	$A300,0	; *************
   2168  a300
   2169  a300					      RORG	$A300	; *************
   2170  a300
   2171  a300							;font
   2172  a300		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2173  a320		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   2174  a335							;player
   2175  a335		       05 45 45 40	      HEX	05454540
   2176  a339							;missle
   2177  a339		       00 55 55 00	      HEX	00555500
   2178  a33d
   2179  a400					      ORG	$A400,0	; *************
   2180  a400
   2181  a400					      RORG	$A400	; *************
   2182  a400
   2183  a400							;font
   2184  a400		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2185  a420		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   2186  a435							;player
   2187  a435		       01 45 45 00	      HEX	01454500
   2188  a439							;missle
   2189  a439		       00 55 55 00	      HEX	00555500
   2190  a43d
   2191  a500					      ORG	$A500,0	; *************
   2192  a500
   2193  a500					      RORG	$A500	; *************
   2194  a500
   2195  a500							;font
   2196  a500		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2197  a520		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   2198  a535							;player
   2199  a535		       01 45 45 00	      HEX	01454500
   2200  a539							;missle
   2201  a539		       00 31 40 00	      HEX	00314000
   2202  a53d
   2203  a600					      ORG	$A600,0	; *************
   2204  a600
   2205  a600					      RORG	$A600	; *************
   2206  a600
   2207  a600							;font
   2208  a600		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2209  a620		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   2210  a635							;player
   2211  a635		       01 45 44 00	      HEX	01454400
   2212  a639							;missle
   2213  a639		       00 01 40 00	      HEX	00014000
   2214  a63d
   2215  a700					      ORG	$A700,0	; *************
   2216  a700
   2217  a700					      RORG	$A700	; *************
   2218  a700
   2219  a700							;font
   2220  a700		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2221  a720		       00 00 00 00*	      HEX	000000000000000000000000000000000000000000
   2222  a735							;player
   2223  a735		       00 45 44 00	      HEX	00454400
   2224  a739							;missle
   2225  a739		       00 01 40 00	      HEX	00014000
   2226  a73d
   2227  a800					      ORG	$A800,0	; *************
   2228  a800
   2229  a800					      RORG	$A800	; *************
   2230  a800
   2231  a800							;font
   2232  a800		       00 00 00 00*	      HEX	0000000000000000000000000000000000000000000000000000000000000000
   2233  a820		       00 00 00 00*	      HEX	000000000000000000004000540000000000000000
   2234  a835							;player
   2235  a835		       00 45 44 00	      HEX	00454400
   2236  a839							;missle
   2237  a839		       00 01 40 00	      HEX	00014000
   2238  a83d
   2239  a900					      ORG	$A900,0	; *************
   2240  a900
   2241  a900					      RORG	$A900	; *************
   2242  a900
   2243  a900							;font
   2244  a900		       54 54 54 54*	      HEX	5454545404545410545444505450544054445454445444445440044454105410
   2245  a920		       44 44 10 54*	      HEX	444410544000101040101000000440545414154000
   2246  a935							;player
   2247  a935		       00 45 44 00	      HEX	00454400
   2248  a939							;missle
   2249  a939		       00 01 40 00	      HEX	00014000
   2250  a93d
   2251  aa00					      ORG	$AA00,0	; *************
   2252  aa00
   2253  aa00					      RORG	$AA00	; *************
   2254  aa00
   2255  aa00							;font
   2256  aa00		       44 10 40 04*	      HEX	4410400404444410440444444044404044441044444044444440504404104454
   2257  aa20		       54 44 10 40*	      HEX	544410405000000040000000001010400441401000
   2258  aa35							;player
   2259  aa35		       00 45 44 00	      HEX	00454400
   2260  aa39							;missle
   2261  aa39		       00 01 40 00	      HEX	00014000
   2262  aa3d
   2263  ab00					      ORG	$AB00,0	; *************
   2264  ab00
   2265  ab00					      RORG	$AB00	; *************
   2266  ab00
   2267  ab00							;font
   2268  ab00		       44 10 40 04*	      HEX	4410400404044410440454444044404044441004504044444454445004104444
   2269  ab20		       54 54 10 40*	      HEX	545410405400101010000000004004400441451000
   2270  ab35							;player
   2271  ab35		       00 45 44 00	      HEX	00454400
   2272  ab39							;missle
   2273  ab39		       00 00 00 00	      HEX	00000000
   2274  ab3d
   2275  ac00					      ORG	$AC00,0	; *************
   2276  ac00
   2277  ac00					      RORG	$AC00	; *************
   2278  ac00
   2279  ac00							;font
   2280  ac00		       44 10 54 14*	      HEX	4410541454045410545444504044505044541004504054444444444454104444
   2281  ac20		       44 10 10 50*	      HEX	441010505500101010000054004004400414441000
   2282  ac35							;player
   2283  ac35		       00 45 44 00	      HEX	00454400
   2284  ac39							;missle
   2285  ac39		       00 00 00 00	      HEX	00000000
   2286  ac3d
   2287  ad00					      ORG	$AD00,0	; *************
   2288  ad00
   2289  ad00					      RORG	$AD00	; *************
   2290  ad00
   2291  ad00							;font
   2292  ad00		       44 10 04 04*	      HEX	4410040444544004444444444044404040441004444054444444444440104444
   2293  ad20		       44 54 44 14*	      HEX	445444145400041010000000004004400444451000
   2294  ad35							;player
   2295  ad35		       00 00 00 00	      HEX	00000000
   2296  ad39							;missle
   2297  ad39		       00 00 00 00	      HEX	00000000
   2298  ad3d
   2299  ae00					      ORG	$AE00,0	; *************
   2300  ae00
   2301  ae00					      RORG	$AE00	; *************
   2302  ae00
   2303  ae00							;font
   2304  ae00		       44 50 04 04*	      HEX	4450040444404044444444444044404040441004444054444444444440104444
   2305  ae20		       44 44 44 04*	      HEX	444444045044441004000000001010400444401000
   2306  ae35							;player
   2307  ae35		       00 00 00 00	      HEX	00000000
   2308  ae39							;missle
   2309  ae39		       00 00 00 00	      HEX	00000000
   2310  ae3d
   2311  af00					      ORG	$AF00,0	; *************
   2312  af00
   2313  af00					      RORG	$AF00	; *************
   2314  af00
   2315  af00							;font
   2316  af00		       54 10 54 54*	      HEX	5410545444545454545454505450545454445404444044545454545454544444
   2317  af20		       44 44 44 54*	      HEX	444444544044541004000000000440545410154000
   2318  af35							;player
   2319  af35		       00 00 00 00	      HEX	00000000
   2320  af39							;missle
   2321  af39		       00 00 00 00	      HEX	00000000
   2322  af3d
   2323  b000					      ORG	$B000,0	; *************
   2324  b000
   2325  b000					      RORG	$B000	; *************
   2326  b000				  -	      if	SPACEOVERFLOW > 0
   2327  b000				  -	      echo	""
   2328  b000				  -	      echo	"######## ERROR: space overflow detected in",[SPACEOVERFLOW]d,"areas."
   2329  b000				  -	      echo	"######## look above for areas with negative ROM space left."
   2330  b000					      endif
   2331  b000
   2332  b000
   2333  b000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2334  b000
   2335  b000				  -	      ifnconst	bankswitchmode
   2336  b000				  -	      if	( * < $f000 )
   2337  b000				  -	      ORG	$F000
   2338  b000				  -	      endif
   2339  b000					      else
   2340  b000					      ifconst	ROM128K
   2341  b000					      if	( * < $f000 )
   2342  27000					       ORG	$27000
   2343  27000					       RORG	$F000
   2344  27000					       endif
   2345  27000					       endif
   2346  27000				   -	       ifconst	ROM144K
   2347  27000				   -	       if	( * < $f000 )
   2348  27000				   -	       ORG	$27000
   2349  27000				   -	       RORG	$F000
   2350  27000				   -	       endif
   2351  27000					       endif
   2352  27000				   -	       ifconst	ROM256K
   2353  27000				   -	       if	( * < $f000 )
   2354  27000				   -	       ORG	$47000
   2355  27000				   -	       RORG	$F000
   2356  27000				   -	       endif
   2357  27000					       endif
   2358  27000				   -	       ifconst	ROM272K
   2359  27000				   -	       if	( * < $f000 )
   2360  27000				   -	       ORG	$47000
   2361  27000				   -	       RORG	$F000
   2362  27000				   -	       endif
   2363  27000					       endif
   2364  27000				   -	       ifconst	ROM512K
   2365  27000				   -	       if	( * < $f000 )
   2366  27000				   -	       ORG	$87000
   2367  27000				   -	       RORG	$F000
   2368  27000				   -	       endif
   2369  27000					       endif
   2370  27000				   -	       ifconst	ROM528K
   2371  27000				   -	       if	( * < $f000 )
   2372  27000				   -	       ORG	$87000
   2373  27000				   -	       RORG	$F000
   2374  27000				   -	       endif
   2375  27000					       endif
   2376  27000					       endif
   2377  27000
   2378  27000							; all of these "modules" have conditional clauses in them, so even though
   2379  27000							; they're always included here, they don't take up rom unless the user
   2380  27000							; explicitly enables support for the feature.
   2381  27000
   2382  27000					       ifnconst	included.rmtplayer.asm
------- FILE rmtplayer.asm LEVEL 2 PASS 3
      0  27000					       include	rmtplayer.asm	; requires page alignment, so go first
      1  27000				   -	       ifconst	RMT
      2  27000				   -
      3  27000				   -rmtmodulestart
      4  27000				   -
      5  27000				   -			;*
      6  27000				   -			;* Raster Music Tracker, RMT Atari routine version 1.20030223
      7  27000				   -			;* (c) Radek Sterba, Raster/C.P.U., 2002 - 2003
      8  27000				   -			;* http://raster.atari.org
      9  27000				   -			;*
     10  27000				   -			;* Some small changes to allow using this code with DASM cross assembler and
     11  27000				   -			;* to compile for cartridge based systems, like the Atari 5200 or 7800,
     12  27000				   -			;* by Eckhard Stolberg ( http://home.arcor.de/estolberg/ ).
     13  27000				   -			;*
     14  27000				   -			;* More small changes were made to use this code with 7800basic, and
     15  27000				   -			;* comments by VinsCool on more recent versions were back-ported.
     16  27000				   -			;* --Mike Saarna.
     17  27000				   -			;*
     18  27000				   -			;* Warnings:
     19  27000				   -			;*
     20  27000				   -			;* 1. RMT player routine needs 19 dedicated zero page bytes, as well as cca
     21  27000				   -			;* 1KB of memory before the "PLAYER" address for frequency tables and
     22  27000				   -			;* functionary variables. It's:
     23  27000				   -			;* a) from PLAYER-$400 to PLAYER for stereo RMTplayer
     24  27000				   -			;* b) from PLAYER-$380 to PLAYER for mono RMTplayer
     25  27000				   -			;*
     26  27000				   -			;* note: This has been changed for 5200 & 7800 compatibility. Now PLAYER
     27  27000				   -			;* points to the start of the frequency tables. The player routines follows
     28  27000				   -			;* after that. The variables are now independent and can be located with
     29  27000				   -			;* PLAYER_VAR_RAM and PLAYER_ZP_RAM (see below):
     30  27000				   -			;*
     31  27000				   -			;* 2. RMT player routine MUST (!!!) be compiled aligned to a memory page.
     32  27000				   -			;* i.e. "PLAYER" address can be $..00 only!
     33  27000				   -			;*
     34  27000				   -			;* 3. Because of RMTplayer provides a lot of effects, it spent a lot of
     35  27000				   -			;* CPU time.
     36  27000				   -			;*
     37  27000				   -			;*
     38  27000				   -			;* Define the following equates here or in your main code file.
     39  27000				   -			;* Set the values according to the system you compile for.
     40  27000				   -			;*
     41  27000				   -
     42  27000				   -POKEY_BASE equ	pokeyaddress
     43  27000				   -PLAYER_ZP_RAM equ	songchannel1layer1lo	;* player routine needs 19 bytes
     44  27000				   -			;* of zero page RAM
     45  27000				   -PLAYER_VAR_RAM equ	RMTRAM	;* variables in main RAM - 173 bytes
     46  27000				   -			;* mono - 337 stereo
     47  27000				   -
     48  27000				   -ROM_BASED  equ	1	;* using a ROM based system - no self modifying code
     49  27000				   -STEREO8T   equ	0	;* 0 => compile RMTplayer for mono 4 tracks
     50  27000				   -			; ;1 => compile RMTplayer for stereo 8 tracks
     51  27000				   -
     52  27000				   -HARD_OF_HEARING equ	1	;* repeat output to pokey
     53  27000				   -
     54  27000				   -rmt_ispeed equ	PLAYER_ZP_RAM+19
     55  27000				   -rmt_intcount equ	PLAYER_ZP_RAM+20
     56  27000				   -
     57  27000				   -			;*
     58  27000				   -
     59  27000				   -	       IF	STEREO8T
     60  27000				   -TRACKS     equ	8
     61  27000				   -	       ELSE
     62  27000				   -TRACKS     equ	4
     63  27000				   -	       ENDIF
     64  27000				   -
     65  27000				   -			;*
     66  27000				   -			;* RMT FEATures definitions
     67  27000				   -			;* For optimizations of RMT player routine to concrete RMT modul only!
     68  27000				   -			;* --------BEGIN--------
     69  27000				   -FEAT_COMMAND1 equ	1	;* cca 8 bytes
     70  27000				   -FEAT_COMMAND2 equ	1	;* cca 20 bytes (+save 1 address in zero page)
     71  27000				   -			;* and quicker whole RMT routine
     72  27000				   -FEAT_COMMAND3 equ	1	;* cca 12 bytes
     73  27000				   -FEAT_COMMAND4 equ	1	;* cca 15 bytes
     74  27000				   -FEAT_COMMAND5 equ	1	;* cca 67 bytes
     75  27000				   -FEAT_COMMAND6 equ	1	;* cca 15 bytes
     76  27000				   -			;* COMMAND7 SETNOTE (i.e. command 7 with parameter != $80)
     77  27000				   -FEAT_COMMAND7SETNOTE equ	1	;* cca 12 bytes
     78  27000				   -			;* COMMAND7 VOLUMEONLY (i.e. command 7 with parameter == $80)
     79  27000				   -FEAT_COMMAND7VOLUMEONLY equ	1	;* cca 74 bytes
     80  27000				   -			;* PORTAMENTO
     81  27000				   -FEAT_PORTAMENTO equ	1	;* cca 138 bytes and quicker whole RMT routine
     82  27000				   -			;* FILTER
     83  27000				   -FEAT_FILTER equ	1	;* cca 179 bytes and quicker whole RMT routine
     84  27000				   -FEAT_FILTERG0L equ	1	;* (cca 38 bytes for each)
     85  27000				   -FEAT_FILTERG1L equ	1
     86  27000				   -FEAT_FILTERG0R equ	1
     87  27000				   -FEAT_FILTERG1R equ	1
     88  27000				   -			;* BASS16B (i.e. distortion value 6)
     89  27000				   -FEAT_BASS16 equ	1	;* cca 194 bytes +128bytes freq table and
     90  27000				   -			;* quicker whole RMT routine
     91  27000				   -FEAT_BASS16G1L equ	1	;* (cca 47 bytes for each)
     92  27000				   -FEAT_BASS16G3L equ	1
     93  27000				   -FEAT_BASS16G1R equ	1
     94  27000				   -FEAT_BASS16G3R equ	1
     95  27000				   -			;* VOLUME ONLY for particular generators
     96  27000				   -FEAT_VOLUMEONLYG0L equ	1	;* (cca 7 bytes for each)
     97  27000				   -FEAT_VOLUMEONLYG2L equ	1
     98  27000				   -FEAT_VOLUMEONLYG3L equ	1
     99  27000				   -FEAT_VOLUMEONLYG0R equ	1
    100  27000				   -FEAT_VOLUMEONLYG2R equ	1
    101  27000				   -FEAT_VOLUMEONLYG3R equ	1
    102  27000				   -			;* TABLE TYPE (i.e. TABLETYPE=1)
    103  27000				   -FEAT_TABLETYPE equ	1	;* cca 53 bytes and quicker whole RMT routine
    104  27000				   -			;* TABLE MODE (i.e. TABLEMODE=1)
    105  27000				   -FEAT_TABLEMODE equ	1	;* cca 16 bytes and quicker whole RMT routine
    106  27000				   -			;* AUDCTLMANUALSET (i.e. any MANUAL AUDCTL setting to nonzero value)
    107  27000				   -FEAT_AUDCTLMANUALSET equ	1	;* cca 27 bytes and quicker whole RMT routine
    108  27000				   -			;* --------END--------
    109  27000				   -			;*
    110  27000				   -			;*
    111  27000				   -			;* RMT ZeroPage addresses
    112  27000				   -
    113  27000				   -MEMLOC     SET	PLAYER_ZP_RAM
    114  27000				   -p_tis      =	MEMLOC
    115  27000				   -p_instrstable =	MEMLOC
    116  27000				   -MEMLOC     SET	(MEMLOC+2)
    117  27000				   -ptrTracksTblLo =	MEMLOC
    118  27000				   -MEMLOC     SET	(MEMLOC+2)
    119  27000				   -ptrTracksTblHi =	MEMLOC
    120  27000				   -MEMLOC     SET	(MEMLOC+2)
    121  27000				   -ptrSongLines =	MEMLOC
    122  27000				   -MEMLOC     SET	(MEMLOC+2)
    123  27000				   -
    124  27000				   -_ns        =	MEMLOC
    125  27000				   -MEMLOC     SET	(MEMLOC+2)
    126  27000				   -_nr        =	MEMLOC
    127  27000				   -MEMLOC     SET	(MEMLOC+2)
    128  27000				   -_nt        =	MEMLOC
    129  27000				   -MEMLOC     SET	(MEMLOC+2)
    130  27000				   -
    131  27000				   -rmtreg1    =	MEMLOC
    132  27000				   -MEMLOC     SET	(MEMLOC+1)
    133  27000				   -rmtreg2    =	MEMLOC
    134  27000				   -MEMLOC     SET	(MEMLOC+1)
    135  27000				   -rmtreg3    =	MEMLOC
    136  27000				   -MEMLOC     SET	(MEMLOC+1)
    137  27000				   -_tmp       =	MEMLOC
    138  27000				   -MEMLOC     SET	(MEMLOC+1)
    139  27000				   -	       IF	FEAT_COMMAND2
    140  27000				   -frqaddcmd2 =	MEMLOC
    141  27000				   -MEMLOC     SET	(MEMLOC+1)
    142  27000				   -	       ENDIF
    143  27000				   -
    144  27000				   -			;*
    145  27000				   -			;* Variables in main RAM used by player routine.
    146  27000				   -			;* 337 bytes for stereo - 173 bytes for mono
    147  27000				   -			;*
    148  27000				   -
    149  27000				   -MEMLOC     SET	PLAYER_VAR_RAM
    150  27000				   -track_variables =	MEMLOC
    151  27000				   -
    152  27000				   -trackn_TblLo =	MEMLOC
    153  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    154  27000				   -trackn_TblHi =	MEMLOC
    155  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    156  27000				   -trackn_idx =	MEMLOC
    157  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    158  27000				   -trackn_pause =	MEMLOC
    159  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    160  27000				   -trackn_note =	MEMLOC
    161  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    162  27000				   -trackn_volume =	MEMLOC
    163  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    164  27000				   -trackn_distor =	MEMLOC
    165  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    166  27000				   -trackn_shiftfrq =	MEMLOC
    167  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    168  27000				   -
    169  27000				   -	       IF	FEAT_PORTAMENTO
    170  27000				   -trackn_portafrqc =	MEMLOC
    171  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    172  27000				   -trackn_portafrqa =	MEMLOC
    173  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    174  27000				   -trackn_portaspeed =	MEMLOC
    175  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    176  27000				   -trackn_portaspeeda =	MEMLOC
    177  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    178  27000				   -trackn_portadepth =	MEMLOC
    179  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    180  27000				   -	       ENDIF
    181  27000				   -
    182  27000				   -trackn_instrx2 =	MEMLOC
    183  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    184  27000				   -trackn_instrdb =	MEMLOC
    185  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    186  27000				   -trackn_instrhb =	MEMLOC
    187  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    188  27000				   -trackn_instridx =	MEMLOC
    189  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    190  27000				   -trackn_instrlen =	MEMLOC
    191  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    192  27000				   -trackn_instrlop =	MEMLOC
    193  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    194  27000				   -trackn_instrreachend =	MEMLOC
    195  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    196  27000				   -trackn_volumeslidedepth =	MEMLOC
    197  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    198  27000				   -trackn_volumeslidevalue =	MEMLOC
    199  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    200  27000				   -trackn_volumemin =	MEMLOC
    201  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    202  27000				   -trackn_effdelay =	MEMLOC
    203  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    204  27000				   -trackn_effvibratoa =	MEMLOC
    205  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    206  27000				   -trackn_effvibratobeg =	MEMLOC
    207  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    208  27000				   -trackn_effvibratoend =	MEMLOC
    209  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    210  27000				   -trackn_effshift =	MEMLOC
    211  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    212  27000				   -trackn_tabletypespeed =	MEMLOC
    213  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    214  27000				   -
    215  27000				   -	       IF	FEAT_TABLEMODE
    216  27000				   -trackn_tablemode =	MEMLOC
    217  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    218  27000				   -	       ENDIF
    219  27000				   -
    220  27000				   -trackn_tablenote =	MEMLOC
    221  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    222  27000				   -
    223  27000				   -trackn_tablea =	MEMLOC
    224  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    225  27000				   -trackn_tableend =	MEMLOC
    226  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    227  27000				   -trackn_tablelop =	MEMLOC
    228  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    229  27000				   -trackn_tablespeeda =	MEMLOC
    230  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    231  27000				   -trackn_command =	MEMLOC
    232  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    233  27000				   -
    234  27000				   -	       IF	FEAT_BASS16
    235  27000				   -trackn_outnote =	MEMLOC
    236  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    237  27000				   -	       ENDIF
    238  27000				   -	       IF	FEAT_FILTER
    239  27000				   -trackn_filter =	MEMLOC
    240  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    241  27000				   -	       ENDIF
    242  27000				   -
    243  27000				   -trackn_audf =	MEMLOC
    244  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    245  27000				   -trackn_audc =	MEMLOC
    246  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    247  27000				   -
    248  27000				   -	       IF	FEAT_AUDCTLMANUALSET
    249  27000				   -trackn_audctl =	MEMLOC
    250  27000				   -MEMLOC     SET	(MEMLOC+TRACKS)
    251  27000				   -	       ENDIF
    252  27000				   -
    253  27000				   -v_audctl   =	MEMLOC
    254  27000				   -MEMLOC     SET	(MEMLOC+1)
    255  27000				   -v_audctl2  =	MEMLOC
    256  27000				   -MEMLOC     SET	(MEMLOC+1)
    257  27000				   -v_speed    =	MEMLOC
    258  27000				   -MEMLOC     SET	(MEMLOC+1)
    259  27000				   -v_aspeed   =	MEMLOC
    260  27000				   -MEMLOC     SET	(MEMLOC+1)
    261  27000				   -v_bspeed   =	MEMLOC
    262  27000				   -MEMLOC     SET	(MEMLOC+1)
    263  27000				   -v_instrspeed =	MEMLOC
    264  27000				   -MEMLOC     SET	(MEMLOC+1)
    265  27000				   -smc_silence_instrspeed =	MEMLOC
    266  27000				   -MEMLOC     SET	(MEMLOC+1)
    267  27000				   -v_maxtracklen =	MEMLOC
    268  27000				   -MEMLOC     SET	(MEMLOC+1)
    269  27000				   -v_abeat    =	MEMLOC
    270  27000				   -MEMLOC     SET	(MEMLOC+1)
    271  27000				   -
    272  27000				   -track_endvariables =	MEMLOC
    273  27000				   -
    274  27000				   -			;*
    275  27000				   -			;* Data tables used by player routine.
    276  27000				   -			;*
    277  27000				   -	       ALIGN	256
    278  27000				   -PLAYER     =	.
    279  27000				   -
    280  27000				   -volumetab
    281  27000				   -	       dc.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    282  27000				   -	       dc.b	$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01
    283  27000				   -	       dc.b	$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01,$02,$02,$02,$02
    284  27000				   -	       dc.b	$00,$00,$00,$01,$01,$01,$01,$01,$02,$02,$02,$02,$02,$03,$03,$03
    285  27000				   -	       dc.b	$00,$00,$01,$01,$01,$01,$02,$02,$02,$02,$03,$03,$03,$03,$04,$04
    286  27000				   -	       dc.b	$00,$00,$01,$01,$01,$02,$02,$02,$03,$03,$03,$04,$04,$04,$05,$05
    287  27000				   -	       dc.b	$00,$00,$01,$01,$02,$02,$02,$03,$03,$04,$04,$04,$05,$05,$06,$06
    288  27000				   -	       dc.b	$00,$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07
    289  27000				   -	       dc.b	$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07,$08
    290  27000				   -	       dc.b	$00,$01,$01,$02,$02,$03,$04,$04,$05,$05,$06,$07,$07,$08,$08,$09
    291  27000				   -	       dc.b	$00,$01,$01,$02,$03,$03,$04,$05,$05,$06,$07,$07,$08,$09,$09,$0A
    292  27000				   -	       dc.b	$00,$01,$01,$02,$03,$04,$04,$05,$06,$07,$07,$08,$09,$0A,$0A,$0B
    293  27000				   -	       dc.b	$00,$01,$02,$02,$03,$04,$05,$06,$06,$07,$08,$09,$0A,$0A,$0B,$0C
    294  27000				   -	       dc.b	$00,$01,$02,$03,$03,$04,$05,$06,$07,$08,$09,$0A,$0A,$0B,$0C,$0D
    295  27000				   -	       dc.b	$00,$01,$02,$03,$04,$05,$06,$07,$07,$08,$09,$0A,$0B,$0C,$0D,$0E
    296  27000				   -	       dc.b	$00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0A,$0B,$0C,$0D,$0E,$0F
    297  27000				   -
    298  27000				   -frqtab
    299  27000				   -			; ERT [<frqtab]!=0 ;* frqtab must begin at the memory page bound!
    300  27000				   -			;* (i.e. $..00 address)
    301  27000				   -frqtabbass1
    302  27000				   -	       dc.b	$BF,$B6,$AA,$A1,$98,$8F,$89,$80,$F2,$E6,$DA,$CE,$BF,$B6,$AA,$A1
    303  27000				   -	       dc.b	$98,$8F,$89,$80,$7A,$71,$6B,$65,$5F,$5C,$56,$50,$4D,$47,$44,$3E
    304  27000				   -	       dc.b	$3C,$38,$35,$32,$2F,$2D,$2A,$28,$25,$23,$21,$1F,$1D,$1C,$1A,$18
    305  27000				   -	       dc.b	$17,$16,$14,$13,$12,$11,$10,$0F,$0E,$0D,$0C,$0B,$0A,$09,$08,$07
    306  27000				   -frqtabbass2
    307  27000				   -	       dc.b	$FF,$F1,$E4,$D8,$CA,$C0,$B5,$AB,$A2,$99,$8E,$87,$7F,$79,$73,$70
    308  27000				   -	       dc.b	$66,$61,$5A,$55,$52,$4B,$48,$43,$3F,$3C,$39,$37,$33,$30,$2D,$2A
    309  27000				   -	       dc.b	$28,$25,$24,$21,$1F,$1E,$1C,$1B,$19,$17,$16,$15,$13,$12,$11,$10
    310  27000				   -	       dc.b	$0F,$0E,$0D,$0C,$0B,$0A,$09,$08,$07,$06,$05,$04,$03,$02,$01,$00
    311  27000				   -frqtabpure
    312  27000				   -	       dc.b	$F3,$E6,$D9,$CC,$C1,$B5,$AD,$A2,$99,$90,$88,$80,$79,$72,$6C,$66
    313  27000				   -	       dc.b	$60,$5B,$55,$51,$4C,$48,$44,$40,$3C,$39,$35,$32,$2F,$2D,$2A,$28
    314  27000				   -	       dc.b	$25,$23,$21,$1F,$1D,$1C,$1A,$18,$17,$16,$14,$13,$12,$11,$10,$0F
    315  27000				   -	       dc.b	$0E,$0D,$0C,$0B,$0A,$09,$08,$07,$06,$05,$04,$03,$02,$01,$00,$00
    316  27000				   -	       IF	FEAT_BASS16
    317  27000				   -frqtabbasshi
    318  27000				   -	       dc.b	$0D,$0D,$0C,$0B,$0B,$0A,$0A,$09,$08,$08,$07,$07,$07,$06,$06,$05
    319  27000				   -	       dc.b	$05,$05,$04,$04,$04,$04,$03,$03,$03,$03,$03,$02,$02,$02,$02,$02
    320  27000				   -	       dc.b	$02,$02,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$00,$00
    321  27000				   -	       dc.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    322  27000				   -	       ENDIF
    323  27000				   -
    324  27000				   -	       IF	FEAT_BASS16
    325  27000				   -frqtabbasslo
    326  27000				   -	       dc.b	$F2,$33,$96,$E2,$38,$8C,$00,$6A,$E8,$6A,$EF,$80,$08,$AE,$46,$E6
    327  27000				   -	       dc.b	$95,$41,$F6,$B0,$6E,$30,$F6,$BB,$84,$52,$22,$F4,$C8,$A0,$7A,$55
    328  27000				   -	       dc.b	$34,$14,$F5,$D8,$BD,$A4,$8D,$77,$60,$4E,$38,$27,$15,$06,$F7,$E8
    329  27000				   -	       dc.b	$DB,$CF,$C3,$B8,$AC,$A2,$9A,$90,$88,$7F,$78,$70,$6A,$64,$5E,$00
    330  27000				   -	       ENDIF
    331  27000				   -
    332  27000				   -	       IF	ROM_BASED
    333  27000				   -rts_tab    dc.w	cmd0-1,cmd1-1,cmd2-1,cmd3-1,cmd4-1,cmd5-1,cmd6-1,cmd7-1
    334  27000				   -	       ENDIF
    335  27000				   -INSTRPAR   equ	12
    336  27000				   -tabbeganddistor
    337  27000				   -	       dc.b	frqtabpure-frqtab,$00
    338  27000				   -	       dc.b	frqtabpure-frqtab,$20
    339  27000				   -	       dc.b	frqtabpure-frqtab,$40
    340  27000				   -	       dc.b	frqtabbass1-frqtab,$c0
    341  27000				   -	       dc.b	frqtabpure-frqtab,$80
    342  27000				   -	       dc.b	frqtabpure-frqtab,$a0
    343  27000				   -	       dc.b	frqtabbass1-frqtab,$c0
    344  27000				   -	       dc.b	frqtabbass2-frqtab,$c0
    345  27000				   -vibtabbeg  dc.b	0,vib1-vib0,vib2-vib0,vib3-vib0,vibx-vib0
    346  27000				   -vib0       dc.b	0
    347  27000				   -vib1       dc.b	1,-1,-1,1
    348  27000				   -vib2       dc.b	1,0,-1,-1,0,1
    349  27000				   -vib3       dc.b	1,1,0,-1,-1,-1,-1,0,1,1
    350  27000				   -vibx
    351  27000				   -emptytrack
    352  27000				   -	       dc.b	62,0
    353  27000				   -
    354  27000				   -			;*
    355  27000				   -			;* Set of RMT main vectors:
    356  27000				   -			;*
    357  27000				   -RASTERMUSICTRACKER
    358  27000				   -	       jmp	rmt_init	;* Must be run first, to clear memory and initialise
    359  27000				   -			;* the player... Once this is done, run rmt_play
    360  27000				   -			;* afterwards, or Set_Pokey if you want to manually
    361  27000				   -			;* time certain things.
    362  27000				   -
    363  27000				   -	       jmp	rmt_play	;* One play each subroutine call. SetPokey is
    364  27000				   -			;* executed first, then all the play code is ran
    365  27000				   -			;* once, until the RTS. rmt_play could be called
    366  27000				   -			;* multiple times per frame if wanted.
    367  27000				   -
    368  27000				   -	       jmp	rmt_p3	;* Similar to rmt_play, but will also skip SetPokey
    369  27000				   -			;* and the instruments/songlines/tracklines
    370  27000				   -			;* initialisation, very useful for playing simple
    371  27000				   -			;* things.
    372  27000				   -
    373  27000				   -	       jmp	rmt_silence	;* Run this to stop the driver, and reset all POKEY
    374  27000				   -			;* registers to 0. This is also part of rmt_init
    375  27000				   -			;* when it is executed first.
    376  27000				   -
    377  27000				   -	       jmp	SetPokey	;* Run to copy the contents of the Shadow POKEY
    378  27000				   -			;* registers (v_audctl, v_skctl, trackn_audf,x etc)
    379  27000				   -			;* into the real ones. Will be run first each time
    380  27000				   -			;* rmt_play is called.
    381  27000				   -rmt_init
    382  27000				   -	       stx	_ns
    383  27000				   -	       sty	_ns+1
    384  27000				   -	       pha
    385  27000				   -	       IF	track_endvariables-track_variables>255
    386  27000				   -	       ldy	#0
    387  27000				   -	       tya
    388  27000				   -ri_clear_loop
    389  27000				   -	       sta	track_variables,y
    390  27000				   -	       sta	track_endvariables-$100,y
    391  27000				   -	       iny
    392  27000				   -	       bne	ri_clear_loop
    393  27000				   -	       ELSE
    394  27000				   -	       ldy	#track_endvariables-track_variables
    395  27000				   -	       lda	#0
    396  27000				   -ri_clear_loop
    397  27000				   -	       sta	track_variables-1,y
    398  27000				   -	       dey
    399  27000				   -	       bne	ri_clear_loop
    400  27000				   -	       ENDIF
    401  27000				   -			;* Parse the RMT module data
    402  27000				   -			;* Track length: +4
    403  27000				   -	       ldy	#4
    404  27000				   -	       lda	(_ns),y
    405  27000				   -	       sta	v_maxtracklen	;* Change the code to store the track length
    406  27000				   -	       iny
    407  27000				   -	       lda	(_ns),y
    408  27000				   -	       sta	v_speed	;* Change the code to store the song speed
    409  27000				   -	       iny
    410  27000				   -	       lda	(_ns),y
    411  27000				   -	       sta	v_instrspeed	;* Change the code to store the instrument speed
    412  27000				   -	       sta	smc_silence_instrspeed
    413  27000				   -
    414  27000				   -			; Copy 4 pointers: +8
    415  27000				   -			; -> InstrumentPtrs[]	       2 bytes
    416  27000				   -			; -> TracksPtrsLow[]	       2 bytes
    417  27000				   -			; -> TracksPtrsHi	       2 bytes
    418  27000				   -			; -> SongData		       2 bytes
    419  27000				   -	       ldy	#8
    420  27000				   -ri_copy_loop
    421  27000				   -	       lda	(_ns),y
    422  27000				   -	       sta	p_tis-8,y
    423  27000				   -	       iny
    424  27000				   -	       cpy	#8+8	;* we started at 8, so loop until 16
    425  27000				   -	       bne	ri_copy_loop
    426  27000				   -
    427  27000				   -	       pla
    428  27000				   -	       pha
    429  27000				   -	       IF	STEREO8T
    430  27000				   -	       asl
    431  27000				   -	       asl
    432  27000				   -	       asl
    433  27000				   -	       clc
    434  27000				   -	       adc	ptrSongLines
    435  27000				   -	       sta	ptrSongLines
    436  27000				   -	       pla
    437  27000				   -	       and	#$e0
    438  27000				   -	       asl
    439  27000				   -	       rol
    440  27000				   -	       rol
    441  27000				   -	       rol
    442  27000				   -	       ELSE
    443  27000				   -	       asl
    444  27000				   -	       asl
    445  27000				   -	       clc
    446  27000				   -	       adc	ptrSongLines
    447  27000				   -	       sta	ptrSongLines
    448  27000				   -	       pla
    449  27000				   -	       and	#$c0
    450  27000				   -	       asl
    451  27000				   -	       rol
    452  27000				   -	       rol
    453  27000				   -	       ENDIF
    454  27000				   -	       adc	ptrSongLines+1
    455  27000				   -	       sta	ptrSongLines+1
    456  27000				   -
    457  27000				   -	       jsr	GetSongLine
    458  27000				   -
    459  27000				   -	       jsr	GetTrackLine
    460  27000				   -	       jsr	InitOfNewSetInstrumentsOnly
    461  27000				   -	       jsr	rmt_silence
    462  27000				   -	       lda	v_instrspeed
    463  27000				   -	       rts
    464  27000				   -
    465  27000				   -rmt_silence
    466  27000				   -	       IF	STEREO8T
    467  27000				   -	       lda	#0
    468  27000				   -	       sta	POKEY_BASE+$08
    469  27000				   -	       sta	POKEY_BASE_S+$08
    470  27000				   -	       ldy	#3
    471  27000				   -	       sty	POKEY_BASE+$0f
    472  27000				   -	       sty	POKEY_BASE_S+$0f
    473  27000				   -	       ldy	#8
    474  27000				   -rmt_silence_loop
    475  27000				   -	       sta	POKEY_BASE+$00,y
    476  27000				   -	       sta	POKEY_BASE_S+$00,y
    477  27000				   -	       dey
    478  27000				   -	       bpl	rmt_silence_loop
    479  27000				   -	       ELSE
    480  27000				   -	       lda	#0
    481  27000				   -	       sta	POKEY_BASE+$08
    482  27000				   -	       ldy	#3
    483  27000				   -	       sty	POKEY_BASE+$0f
    484  27000				   -	       ldy	#8
    485  27000				   -rmt_silence_loop
    486  27000				   -	       sta	POKEY_BASE+$00,y
    487  27000				   -	       dey
    488  27000				   -	       bpl	rmt_silence_loop
    489  27000				   -	       ENDIF
    490  27000				   -	       rts
    491  27000				   -
    492  27000				   -GetSongLine
    493  27000				   -	       ldx	#0
    494  27000				   -	       stx	v_abeat
    495  27000				   -gsl_loop
    496  27000				   -	       ldx	#0
    497  27000				   -gsl_nextSongLine
    498  27000				   -	       txa
    499  27000				   -	       tay
    500  27000				   -	       lda	(ptrSongLines),y
    501  27000				   -	       cmp	#$fe	;* check for "goto line"
    502  27000				   -	       bcs	gsl_GotoOrEmpty	;* and handle it.
    503  27000				   -			;* (A) = Real track #
    504  27000				   -			;* Get the ptr to the track data and store it in ptrTracksTblLo
    505  27000				   -	       tay
    506  27000				   -	       lda	(ptrTracksTblLo),y
    507  27000				   -	       sta	trackn_TblLo,x
    508  27000				   -	       lda	(ptrTracksTblHi),y
    509  27000				   -gsl_initTrack
    510  27000				   -	       sta	trackn_TblHi,x
    511  27000				   -
    512  27000				   -	       lda	#0	;* reset the track index to 0 trackn_idx[x] = 0
    513  27000				   -	       sta	trackn_idx,x
    514  27000				   -
    515  27000				   -	       lda	#1
    516  27000				   -	       sta	trackn_pause,x	;* #1 is a new track, #0 is no new track
    517  27000				   -
    518  27000				   -	       lda	#$80	;* mark that there is no new instrument
    519  27000				   -	       sta	trackn_instrx2,x	;* #$80 is negative, will BMI when encountered,
    520  27000				   -			;* meaning no new instrument initialisation
    521  27000				   -	       inx
    522  27000				   -	       cpx	#TRACKS	;* if x < TRACKS --> gsl_nextSongLine
    523  27000				   -	       bne	gsl_nextSongLine
    524  27000				   -
    525  27000				   -			;* Done with data points of a song line, move to the next line
    526  27000				   -	       lda	ptrSongLines
    527  27000				   -	       clc
    528  27000				   -	       adc	#TRACKS
    529  27000				   -	       sta	ptrSongLines
    530  27000				   -	       bcc	gsl_skipSongHiIncrement
    531  27000				   -	       inc	ptrSongLines+1
    532  27000				   -gsl_skipSongHiIncrement
    533  27000				   -	       rts
    534  27000				   -
    535  27000				   -gsl_GotoOrEmpty
    536  27000				   -			; "cmp #$FE" performed prior to getting here
    537  27000				   -	       beq	gsl_Goto
    538  27000				   -
    539  27000				   -gsl_Empty
    540  27000				   -	       lda	#<emptytrack
    541  27000				   -	       sta	trackn_TblLo,x
    542  27000				   -	       lda	#>emptytrack
    543  27000				   -	       jmp	gsl_initTrack
    544  27000				   -
    545  27000				   -gsl_Goto
    546  27000				   -			; Data format: 0xFE, ???, low, high bytes of ptr to next song line
    547  27000				   -	       ldy	#2
    548  27000				   -	       lda	(ptrSongLines),y
    549  27000				   -	       tax
    550  27000				   -	       iny
    551  27000				   -	       lda	(ptrSongLines),y
    552  27000				   -	       sta	ptrSongLines+1
    553  27000				   -	       stx	ptrSongLines
    554  27000				   -	       jmp	gsl_loop
    555  27000				   -
    556  27000				   -GetTrackLine
    557  27000				   -rmtoo0
    558  27000				   -rmtoo0a
    559  27000				   -	       lda	v_speed
    560  27000				   -	       sta	v_bspeed
    561  27000				   -	       ldx	#0
    562  27000				   -gtl_loopTracks
    563  27000				   -	       lda	trackn_pause,x
    564  27000				   -	       beq	gtl_checkEndOfLoop
    565  27000				   -	       dec	trackn_pause,x
    566  27000				   -	       bne	gtl_checkEndOfLoop
    567  27000				   -	       inc	trackn_pause,x
    568  27000				   -
    569  27000				   -	       lda	trackn_TblLo,x
    570  27000				   -	       sta	_ns
    571  27000				   -	       lda	trackn_TblHi,x
    572  27000				   -	       sta	_ns+1
    573  27000				   -
    574  27000				   -oo1i
    575  27000				   -	       ldy	trackn_idx,x
    576  27000				   -			;* Get a track data point
    577  27000				   -			;* 0 - 60 = Note, instr and volume data
    578  27000				   -			;* 61 - Volume only
    579  27000				   -			;* 62 = Pause/empty line
    580  27000				   -			;* 63 - Speed, go loop or end
    581  27000				   -	       lda	(_ns),y
    582  27000				   -	       sta	rmtreg1
    583  27000				   -	       iny
    584  27000				   -	       lda	(_ns),y
    585  27000				   -	       sta	rmtreg2
    586  27000				   -	       iny
    587  27000				   -	       tya
    588  27000				   -	       sta	trackn_idx,x
    589  27000				   -
    590  27000				   -	       lda	rmtreg1
    591  27000				   -	       and	#$3f
    592  27000				   -	       cmp	#61
    593  27000				   -	       beq	gtl_ProcessVolumeData
    594  27000				   -	       bcs	gtl_Is62or63
    595  27000				   -
    596  27000				   -			;* if we're here it's a note, so store it.
    597  27000				   -	       sta	trackn_note,x
    598  27000				   -	       IF	FEAT_BASS16
    599  27000				   -	       sta	trackn_outnote,x
    600  27000				   -	       ENDIF
    601  27000				   -
    602  27000				   -			;* Process the instrument #
    603  27000				   -	       lda	rmtreg2
    604  27000				   -	       lsr
    605  27000				   -	       and	#$3f*2
    606  27000				   -	       sta	trackn_instrx2,x
    607  27000				   -
    608  27000				   -gtl_ProcessVolumeData
    609  27000				   -	       lda	rmtreg2
    610  27000				   -	       lsr
    611  27000				   -	       ror	rmtreg1
    612  27000				   -	       lsr
    613  27000				   -	       ror	rmtreg1
    614  27000				   -	       lda	rmtreg1
    615  27000				   -	       and	#$f0
    616  27000				   -	       sta	trackn_volume,x
    617  27000				   -gtl_checkEndOfLoop
    618  27000				   -	       inx
    619  27000				   -	       cpx	#TRACKS
    620  27000				   -	       bne	gtl_loopTracks
    621  27000				   -	       lda	v_bspeed
    622  27000				   -	       sta	v_speed
    623  27000				   -	       sta	v_aspeed
    624  27000				   -	       rts
    625  27000				   -
    626  27000				   -gtl_Is62or63
    627  27000				   -	       cmp	#63
    628  27000				   -	       beq	rmtoo63
    629  27000				   -	       lda	rmtreg1
    630  27000				   -	       and	#$c0
    631  27000				   -	       beq	rmtoo62_b
    632  27000				   -	       asl
    633  27000				   -	       rol
    634  27000				   -	       rol
    635  27000				   -	       sta	trackn_pause,x
    636  27000				   -	       dec	trackn_idx,x
    637  27000				   -	       jmp	gtl_checkEndOfLoop
    638  27000				   -
    639  27000				   -rmtoo62_b
    640  27000				   -	       lda	rmtreg2
    641  27000				   -	       sta	trackn_pause,x
    642  27000				   -	       jmp	gtl_checkEndOfLoop
    643  27000				   -
    644  27000				   -rmtoo63
    645  27000				   -	       lda	rmtreg1
    646  27000				   -	       bmi	rmtoo63_1X
    647  27000				   -	       lda	rmtreg2
    648  27000				   -	       sta	v_bspeed
    649  27000				   -	       jmp	oo1i
    650  27000				   -rmtoo63_1X
    651  27000				   -	       cmp	#255
    652  27000				   -	       beq	rmtoo63_11
    653  27000				   -	       lda	rmtreg2
    654  27000				   -	       sta	trackn_idx,x
    655  27000				   -	       jmp	oo1i
    656  27000				   -
    657  27000				   -rmtoo63_11
    658  27000				   -	       jsr	GetSongLine
    659  27000				   -	       jmp	rmtoo0
    660  27000				   -
    661  27000				   -InitOfNewSetInstrumentsOnly
    662  27000				   -	       ldx	#0
    663  27000				   -p2x1       ldy	trackn_instrx2,x
    664  27000				   -	       bmi	p2x2	;* if negative, no new instrument to initialise for this channel
    665  27000				   -	       jsr	SetUpInstrumentY2
    666  27000				   -	       lda	#$80
    667  27000				   -	       sta	trackn_instrx2,x
    668  27000				   -p2x2
    669  27000				   -	       inx
    670  27000				   -	       cpx	#TRACKS
    671  27000				   -	       bne	p2x1
    672  27000				   -	       rts
    673  27000				   -
    674  27000				   -rmt_play
    675  27000				   -rmt_p0
    676  27000				   -	       jsr	SetPokey
    677  27000				   -rmt_p1
    678  27000				   -	       dec	smc_silence_instrspeed
    679  27000				   -	       beq	rmtp1a
    680  27000				   -	       jmp	rmt_p3
    681  27000				   -rmtp1a
    682  27000				   -	       lda	v_instrspeed
    683  27000				   -	       sta	smc_silence_instrspeed
    684  27000				   -rmt_p2
    685  27000				   -	       dec	v_aspeed
    686  27000				   -	       bne	rmt_p3
    687  27000				   -	       inc	v_abeat
    688  27000				   -	       lda	v_abeat
    689  27000				   -	       cmp	v_maxtracklen
    690  27000				   -	       bne	rmtp2o2
    691  27000				   -	       jsr	GetSongLine
    692  27000				   -rmtp2o2
    693  27000				   -	       jsr	GetTrackLine
    694  27000				   -	       jmp	rmt_p2X
    695  27000				   -go_ppnext
    696  27000				   -	       jmp	ppnext
    697  27000				   -rmt_p2X
    698  27000				   -	       jsr	InitOfNewSetInstrumentsOnly
    699  27000				   -rmt_p3
    700  27000				   -	       lda	#>frqtab
    701  27000				   -	       sta	_nr+1
    702  27000				   -
    703  27000				   -	       ldx	#0
    704  27000				   -rmtpp1
    705  27000				   -	       lda	trackn_instrhb,x
    706  27000				   -	       beq	go_ppnext
    707  27000				   -	       sta	_ns+1
    708  27000				   -	       lda	trackn_instrdb,x
    709  27000				   -	       sta	_ns
    710  27000				   -	       ldy	trackn_instridx,x
    711  27000				   -	       lda	(_ns),y
    712  27000				   -	       sta	rmtreg1
    713  27000				   -	       iny
    714  27000				   -	       lda	(_ns),y
    715  27000				   -	       sta	rmtreg2
    716  27000				   -	       iny
    717  27000				   -	       lda	(_ns),y
    718  27000				   -	       sta	rmtreg3
    719  27000				   -	       iny
    720  27000				   -	       tya
    721  27000				   -	       cmp	trackn_instrlen,x
    722  27000				   -	       bcc	rmtpp2
    723  27000				   -	       beq	rmtpp2
    724  27000				   -	       lda	#$80
    725  27000				   -	       sta	trackn_instrreachend,x
    726  27000				   -rmtpp1b
    727  27000				   -	       lda	trackn_instrlop,x
    728  27000				   -rmtpp2
    729  27000				   -	       sta	trackn_instridx,x
    730  27000				   -	       lda	rmtreg1
    731  27000				   -	       IF	STEREO8T
    732  27000				   -	       cpx	#4
    733  27000				   -	       bcc	rmtpp2s
    734  27000				   -	       lsr
    735  27000				   -	       lsr
    736  27000				   -	       lsr
    737  27000				   -	       lsr
    738  27000				   -rmtpp2s
    739  27000				   -	       ENDIF
    740  27000				   -	       and	#$0f
    741  27000				   -	       ora	trackn_volume,x
    742  27000				   -	       tay
    743  27000				   -	       lda	volumetab,y
    744  27000				   -	       pha
    745  27000				   -	       lda	rmtreg2
    746  27000				   -	       and	#$0e
    747  27000				   -	       tay
    748  27000				   -	       lda	tabbeganddistor,y
    749  27000				   -	       sta	_nr
    750  27000				   -	       pla
    751  27000				   -	       ora	tabbeganddistor+1,y
    752  27000				   -	       sta	trackn_audc,x
    753  27000				   -	       jmp	InstrumentsEffects
    754  27000				   -returnfromInstrumentsEffects
    755  27000				   -	       IF	FEAT_COMMAND2
    756  27000				   -	       lda	#0
    757  27000				   -	       sta	frqaddcmd2
    758  27000				   -	       ENDIF
    759  27000				   -	       lda	rmtreg2
    760  27000				   -	       sta	trackn_command,x
    761  27000				   -	       and	#$70
    762  27000				   -	       lsr
    763  27000				   -	       lsr
    764  27000				   -	       IF	ROM_BASED
    765  27000				   -	       lsr
    766  27000				   -	       tay
    767  27000				   -	       lda	rts_tab+1,y
    768  27000				   -	       pha
    769  27000				   -	       lda	rts_tab,y
    770  27000				   -	       pha
    771  27000				   -	       rts
    772  27000				   -	       ELSE
    773  27000				   -	       sta	jmx+1
    774  27000				   -jmx
    775  27000				   -	       bcc	*
    776  27000				   -	       jmp	cmd0
    777  27000				   -	       nop
    778  27000				   -	       jmp	cmd1
    779  27000				   -	       nop
    780  27000				   -	       jmp	cmd2
    781  27000				   -	       nop
    782  27000				   -	       jmp	cmd3
    783  27000				   -	       nop
    784  27000				   -	       jmp	cmd4
    785  27000				   -	       nop
    786  27000				   -	       jmp	cmd5
    787  27000				   -	       nop
    788  27000				   -	       jmp	cmd6
    789  27000				   -	       nop
    790  27000				   -	       jmp	cmd7
    791  27000				   -	       ENDIF
    792  27000				   -cmd0
    793  27000				   -	       lda	trackn_note,x
    794  27000				   -	       clc
    795  27000				   -	       adc	rmtreg3
    796  27000				   -cmd0a
    797  27000				   -	       IF	FEAT_TABLETYPE
    798  27000				   -	       ldy	trackn_tabletypespeed,x
    799  27000				   -	       bmi	cmd0b
    800  27000				   -	       ENDIF
    801  27000				   -	       clc
    802  27000				   -	       adc	trackn_tablenote,x
    803  27000				   -	       cmp	#61
    804  27000				   -	       bcc	cmd0a1
    805  27000				   -	       lda	#0
    806  27000				   -	       sta	trackn_audc,x
    807  27000				   -	       lda	#63
    808  27000				   -cmd0a1
    809  27000				   -	       IF	FEAT_BASS16
    810  27000				   -	       sta	trackn_outnote,x
    811  27000				   -	       ENDIF
    812  27000				   -	       tay
    813  27000				   -	       lda	(_nr),y
    814  27000				   -	       clc
    815  27000				   -	       adc	trackn_shiftfrq,x
    816  27000				   -	       IF	FEAT_COMMAND2
    817  27000				   -	       clc
    818  27000				   -	       adc	frqaddcmd2
    819  27000				   -	       ENDIF
    820  27000				   -	       sta	trackn_audf,x
    821  27000				   -	       jmp	rmtpp9
    822  27000				   -	       IF	FEAT_TABLETYPE
    823  27000				   -cmd0b
    824  27000				   -	       cmp	#61
    825  27000				   -	       bcc	cmd0b1
    826  27000				   -	       lda	#0
    827  27000				   -	       sta	trackn_audc,x
    828  27000				   -	       lda	#63
    829  27000				   -cmd0b1
    830  27000				   -	       tay
    831  27000				   -	       lda	trackn_shiftfrq,x
    832  27000				   -	       clc
    833  27000				   -	       adc	trackn_tablenote,x
    834  27000				   -	       clc
    835  27000				   -	       adc	(_nr),y
    836  27000				   -	       IF	FEAT_COMMAND2
    837  27000				   -	       clc
    838  27000				   -	       adc	frqaddcmd2
    839  27000				   -	       ENDIF
    840  27000				   -	       sta	trackn_audf,x
    841  27000				   -	       jmp	rmtpp9
    842  27000				   -	       ENDIF
    843  27000				   -cmd1
    844  27000				   -	       IF	FEAT_COMMAND1
    845  27000				   -	       lda	rmtreg3
    846  27000				   -	       sta	trackn_audf,x
    847  27000				   -	       jmp	rmtpp9
    848  27000				   -	       ENDIF
    849  27000				   -cmd2
    850  27000				   -	       IF	FEAT_COMMAND2
    851  27000				   -	       lda	rmtreg3
    852  27000				   -	       sta	frqaddcmd2
    853  27000				   -	       lda	trackn_note,x
    854  27000				   -	       jmp	cmd0a
    855  27000				   -	       ENDIF
    856  27000				   -cmd3
    857  27000				   -	       IF	FEAT_COMMAND3
    858  27000				   -	       lda	trackn_note,x
    859  27000				   -	       clc
    860  27000				   -	       adc	rmtreg3
    861  27000				   -	       sta	trackn_note,x
    862  27000				   -	       jmp	cmd0a
    863  27000				   -	       ENDIF
    864  27000				   -cmd4
    865  27000				   -	       IF	FEAT_COMMAND4
    866  27000				   -	       lda	trackn_shiftfrq,x
    867  27000				   -	       clc
    868  27000				   -	       adc	rmtreg3
    869  27000				   -	       sta	trackn_shiftfrq,x
    870  27000				   -	       lda	trackn_note,x
    871  27000				   -	       jmp	cmd0a
    872  27000				   -	       ENDIF
    873  27000				   -cmd5
    874  27000				   -	       IF	FEAT_COMMAND5&&FEAT_PORTAMENTO
    875  27000				   -	       IF	FEAT_TABLETYPE
    876  27000				   -	       lda	trackn_tabletypespeed,x
    877  27000				   -	       bpl	cmd5a1
    878  27000				   -	       ldy	trackn_note,x
    879  27000				   -	       lda	(_nr),y
    880  27000				   -	       clc
    881  27000				   -	       adc	trackn_tablenote,x
    882  27000				   -	       jmp	cmd5ax
    883  27000				   -	       ENDIF
    884  27000				   -cmd5a1
    885  27000				   -	       lda	trackn_note,x
    886  27000				   -	       clc
    887  27000				   -	       adc	trackn_tablenote,x
    888  27000				   -	       cmp	#61
    889  27000				   -	       bcc	cmd5a2
    890  27000				   -	       lda	#63
    891  27000				   -cmd5a2
    892  27000				   -	       tay
    893  27000				   -	       lda	(_nr),y
    894  27000				   -cmd5ax
    895  27000				   -	       sta	trackn_portafrqc,x
    896  27000				   -	       ldy	rmtreg3
    897  27000				   -	       bne	cmd5a
    898  27000				   -	       sta	trackn_portafrqa,x
    899  27000				   -cmd5a
    900  27000				   -	       tya
    901  27000				   -	       lsr
    902  27000				   -	       lsr
    903  27000				   -	       lsr
    904  27000				   -	       lsr
    905  27000				   -	       sta	trackn_portaspeed,x
    906  27000				   -	       sta	trackn_portaspeeda,x
    907  27000				   -	       lda	rmtreg3
    908  27000				   -	       and	#$0f
    909  27000				   -	       sta	trackn_portadepth,x
    910  27000				   -	       lda	trackn_note,x
    911  27000				   -	       jmp	cmd0a
    912  27000				   -	       ELSE
    913  27000				   -	       IF	FEAT_COMMAND5
    914  27000				   -	       jmp	rmtpp9
    915  27000				   -	       ENDIF
    916  27000				   -	       ENDIF
    917  27000				   -cmd6
    918  27000				   -	       IF	FEAT_COMMAND6&&FEAT_FILTER
    919  27000				   -	       lda	rmtreg3
    920  27000				   -	       clc
    921  27000				   -	       adc	trackn_filter,x
    922  27000				   -	       sta	trackn_filter,x
    923  27000				   -	       lda	trackn_note,x
    924  27000				   -	       jmp	cmd0a
    925  27000				   -	       ELSE
    926  27000				   -	       IF	FEAT_COMMAND6
    927  27000				   -	       jmp	rmtpp9
    928  27000				   -	       ENDIF
    929  27000				   -	       ENDIF
    930  27000				   -cmd7
    931  27000				   -	       IF	FEAT_COMMAND7SETNOTE||FEAT_COMMAND7VOLUMEONLY
    932  27000				   -	       IF	FEAT_COMMAND7SETNOTE
    933  27000				   -	       lda	rmtreg3
    934  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY
    935  27000				   -	       cmp	#$80
    936  27000				   -	       beq	cmd7a
    937  27000				   -	       ENDIF
    938  27000				   -	       sta	trackn_note,x
    939  27000				   -	       jmp	cmd0a
    940  27000				   -	       ENDIF
    941  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY
    942  27000				   -cmd7a
    943  27000				   -	       lda	trackn_audc,x
    944  27000				   -	       ora	#$f0
    945  27000				   -	       sta	trackn_audc,x
    946  27000				   -	       lda	trackn_note,x
    947  27000				   -	       jmp	cmd0a
    948  27000				   -	       ENDIF
    949  27000				   -	       ENDIF
    950  27000				   -rmtpp9
    951  27000				   -	       IF	FEAT_PORTAMENTO
    952  27000				   -	       lda	trackn_portaspeeda,x
    953  27000				   -	       beq	rmtpp10
    954  27000				   -	       sec
    955  27000				   -	       sbc	#1
    956  27000				   -	       sta	trackn_portaspeeda,x
    957  27000				   -	       bne	rmtpp10
    958  27000				   -	       lda	trackn_portaspeed,x
    959  27000				   -	       sta	trackn_portaspeeda,x
    960  27000				   -	       lda	trackn_portafrqa,x
    961  27000				   -	       cmp	trackn_portafrqc,x
    962  27000				   -	       beq	rmtpp10
    963  27000				   -	       bcs	pps1
    964  27000				   -	       adc	trackn_portadepth,x
    965  27000				   -	       bcs	pps8
    966  27000				   -	       cmp	trackn_portafrqc,x
    967  27000				   -	       bcs	pps8
    968  27000				   -	       jmp	pps9
    969  27000				   -pps1
    970  27000				   -	       sbc	trackn_portadepth,x
    971  27000				   -	       bcc	pps8
    972  27000				   -	       cmp	trackn_portafrqc,x
    973  27000				   -	       bcs	pps9
    974  27000				   -pps8
    975  27000				   -	       lda	trackn_portafrqc,x
    976  27000				   -pps9
    977  27000				   -	       sta	trackn_portafrqa,x
    978  27000				   -rmtpp10
    979  27000				   -	       lda	rmtreg2
    980  27000				   -	       and	#$01
    981  27000				   -	       beq	rmtpp11
    982  27000				   -	       lda	trackn_portafrqa,x
    983  27000				   -	       clc
    984  27000				   -	       adc	trackn_shiftfrq,x
    985  27000				   -	       sta	trackn_audf,x
    986  27000				   -rmtpp11
    987  27000				   -	       ENDIF
    988  27000				   -ppnext
    989  27000				   -	       inx
    990  27000				   -	       cpx	#TRACKS
    991  27000				   -	       beq	rmt_p4
    992  27000				   -	       jmp	rmtpp1
    993  27000				   -rmt_p4
    994  27000				   -	       IF	FEAT_AUDCTLMANUALSET
    995  27000				   -	       ldx	#3
    996  27000				   -	       lda	#0
    997  27000				   -qq0        ora	trackn_audctl,x
    998  27000				   -	       dex
    999  27000				   -	       bpl	qq0
   1000  27000				   -	       sta	v_audctl
   1001  27000				   -qq1
   1002  27000				   -	       ldx	v_audctl
   1003  27000				   -	       ELSE
   1004  27000				   -	       ldx	#0
   1005  27000				   -	       stx	v_audctl
   1006  27000				   -	       ENDIF
   1007  27000				   -	       IF	FEAT_FILTER
   1008  27000				   -	       IF	FEAT_FILTERG0L
   1009  27000				   -	       lda	trackn_command+0
   1010  27000				   -	       bpl	qq2
   1011  27000				   -	       lda	trackn_audc+0
   1012  27000				   -	       and	#$0f
   1013  27000				   -	       beq	qq2
   1014  27000				   -	       lda	trackn_audf+0
   1015  27000				   -	       clc
   1016  27000				   -	       adc	trackn_filter+0
   1017  27000				   -	       sta	trackn_audf+2
   1018  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2L
   1019  27000				   -	       lda	trackn_audc+2
   1020  27000				   -	       and	#$10
   1021  27000				   -	       bne	qq1a
   1022  27000				   -	       ENDIF
   1023  27000				   -	       lda	#0
   1024  27000				   -	       sta	trackn_audc+2
   1025  27000				   -qq1a
   1026  27000				   -	       txa
   1027  27000				   -	       ora	#4
   1028  27000				   -	       tax
   1029  27000				   -	       ENDIF
   1030  27000				   -qq2
   1031  27000				   -	       IF	FEAT_FILTERG1L
   1032  27000				   -	       lda	trackn_command+1
   1033  27000				   -	       bpl	qq3
   1034  27000				   -	       lda	trackn_audc+1
   1035  27000				   -	       and	#$0f
   1036  27000				   -	       beq	qq3
   1037  27000				   -	       lda	trackn_audf+1
   1038  27000				   -	       clc
   1039  27000				   -	       adc	trackn_filter+1
   1040  27000				   -	       sta	trackn_audf+3
   1041  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG3L
   1042  27000				   -	       lda	trackn_audc+3
   1043  27000				   -	       and	#$10
   1044  27000				   -	       bne	qq2a
   1045  27000				   -	       ENDIF
   1046  27000				   -	       lda	#0
   1047  27000				   -	       sta	trackn_audc+3
   1048  27000				   -qq2a
   1049  27000				   -	       txa
   1050  27000				   -	       ora	#2
   1051  27000				   -	       tax
   1052  27000				   -	       ENDIF
   1053  27000				   -qq3
   1054  27000				   -	       IF	FEAT_FILTERG0L||FEAT_FILTERG1L
   1055  27000				   -	       cpx	v_audctl
   1056  27000				   -	       bne	qq5
   1057  27000				   -	       ENDIF
   1058  27000				   -	       ENDIF
   1059  27000				   -	       IF	FEAT_BASS16
   1060  27000				   -	       IF	FEAT_BASS16G1L
   1061  27000				   -	       lda	trackn_command+1
   1062  27000				   -	       and	#$0e
   1063  27000				   -	       cmp	#6
   1064  27000				   -	       bne	qq4
   1065  27000				   -	       lda	trackn_audc+1
   1066  27000				   -	       and	#$0f
   1067  27000				   -	       beq	qq4
   1068  27000				   -	       ldy	trackn_outnote+1
   1069  27000				   -	       lda	frqtabbasslo,y
   1070  27000				   -	       sta	trackn_audf+0
   1071  27000				   -	       lda	frqtabbasshi,y
   1072  27000				   -	       sta	trackn_audf+1
   1073  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG0L
   1074  27000				   -	       lda	trackn_audc+0
   1075  27000				   -	       and	#$10
   1076  27000				   -	       bne	qq3a
   1077  27000				   -	       ENDIF
   1078  27000				   -	       lda	#0
   1079  27000				   -	       sta	trackn_audc+0
   1080  27000				   -qq3a
   1081  27000				   -	       txa
   1082  27000				   -	       ora	#$50
   1083  27000				   -	       tax
   1084  27000				   -	       ENDIF
   1085  27000				   -qq4
   1086  27000				   -	       IF	FEAT_BASS16G3L
   1087  27000				   -	       lda	trackn_command+3
   1088  27000				   -	       and	#$0e
   1089  27000				   -	       cmp	#6
   1090  27000				   -	       bne	qq5
   1091  27000				   -	       lda	trackn_audc+3
   1092  27000				   -	       and	#$0f
   1093  27000				   -	       beq	qq5
   1094  27000				   -	       ldy	trackn_outnote+3
   1095  27000				   -	       lda	frqtabbasslo,y
   1096  27000				   -	       sta	trackn_audf+2
   1097  27000				   -	       lda	frqtabbasshi,y
   1098  27000				   -	       sta	trackn_audf+3
   1099  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2L
   1100  27000				   -	       lda	trackn_audc+2
   1101  27000				   -	       and	#$10
   1102  27000				   -	       bne	qq4a
   1103  27000				   -	       ENDIF
   1104  27000				   -	       lda	#0
   1105  27000				   -	       sta	trackn_audc+2
   1106  27000				   -qq4a
   1107  27000				   -	       txa
   1108  27000				   -	       ora	#$28
   1109  27000				   -	       tax
   1110  27000				   -	       ENDIF
   1111  27000				   -	       ENDIF
   1112  27000				   -qq5
   1113  27000				   -	       stx	v_audctl
   1114  27000				   -	       IF	STEREO8T
   1115  27000				   -	       IF	FEAT_AUDCTLMANUALSET
   1116  27000				   -	       ldx	#3
   1117  27000				   -	       lda	#0
   1118  27000				   -qs0        ora	trackn_audctl+4,x
   1119  27000				   -	       dex
   1120  27000				   -	       bpl	qs0
   1121  27000				   -	       sta	v_audctl2
   1122  27000				   -qs1
   1123  27000				   -	       ldx	v_audctl2
   1124  27000				   -	       ELSE
   1125  27000				   -	       ldx	#0
   1126  27000				   -	       stx	v_audctl2
   1127  27000				   -	       ENDIF
   1128  27000				   -	       IF	FEAT_FILTER
   1129  27000				   -	       IF	FEAT_FILTERG0R
   1130  27000				   -	       lda	trackn_command+0+4
   1131  27000				   -	       bpl	qs2
   1132  27000				   -	       lda	trackn_audc+0+4
   1133  27000				   -	       and	#$0f
   1134  27000				   -	       beq	qs2
   1135  27000				   -	       lda	trackn_audf+0+4
   1136  27000				   -	       clc
   1137  27000				   -	       adc	trackn_filter+0+4
   1138  27000				   -	       sta	trackn_audf+2+4
   1139  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2R
   1140  27000				   -	       lda	trackn_audc+2+4
   1141  27000				   -	       and	#$10
   1142  27000				   -	       bne	qs1a
   1143  27000				   -	       ENDIF
   1144  27000				   -	       lda	#0
   1145  27000				   -	       sta	trackn_audc+2+4
   1146  27000				   -qs1a
   1147  27000				   -	       txa
   1148  27000				   -	       ora	#4
   1149  27000				   -	       tax
   1150  27000				   -	       ENDIF
   1151  27000				   -qs2
   1152  27000				   -	       IF	FEAT_FILTERG1R
   1153  27000				   -	       lda	trackn_command+1+4
   1154  27000				   -	       bpl	qs3
   1155  27000				   -	       lda	trackn_audc+1+4
   1156  27000				   -	       and	#$0f
   1157  27000				   -	       beq	qs3
   1158  27000				   -	       lda	trackn_audf+1+4
   1159  27000				   -	       clc
   1160  27000				   -	       adc	trackn_filter+1+4
   1161  27000				   -	       sta	trackn_audf+3+4
   1162  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG3R
   1163  27000				   -	       lda	trackn_audc+3+4
   1164  27000				   -	       and	#$10
   1165  27000				   -	       bne	qs2a
   1166  27000				   -	       ENDIF
   1167  27000				   -	       lda	#0
   1168  27000				   -	       sta	trackn_audc+3+4
   1169  27000				   -qs2a
   1170  27000				   -	       txa
   1171  27000				   -	       ora	#2
   1172  27000				   -	       tax
   1173  27000				   -	       ENDIF
   1174  27000				   -qs3
   1175  27000				   -	       IF	FEAT_FILTERG0R||FEAT_FILTERG1R
   1176  27000				   -	       cpx	v_audctl2
   1177  27000				   -	       bne	qs5
   1178  27000				   -	       ENDIF
   1179  27000				   -	       ENDIF
   1180  27000				   -	       IF	FEAT_BASS16
   1181  27000				   -	       IF	FEAT_BASS16G1R
   1182  27000				   -	       lda	trackn_command+1+4
   1183  27000				   -	       and	#$0e
   1184  27000				   -	       cmp	#6
   1185  27000				   -	       bne	qs4
   1186  27000				   -	       lda	trackn_audc+1+4
   1187  27000				   -	       and	#$0f
   1188  27000				   -	       beq	qs4
   1189  27000				   -	       ldy	trackn_outnote+1+4
   1190  27000				   -	       lda	frqtabbasslo,y
   1191  27000				   -	       sta	trackn_audf+0+4
   1192  27000				   -	       lda	frqtabbasshi,y
   1193  27000				   -	       sta	trackn_audf+1+4
   1194  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG0R
   1195  27000				   -	       lda	trackn_audc+0+4
   1196  27000				   -	       and	#$10
   1197  27000				   -	       bne	qs3a
   1198  27000				   -	       ENDIF
   1199  27000				   -	       lda	#0
   1200  27000				   -	       sta	trackn_audc+0+4
   1201  27000				   -qs3a
   1202  27000				   -	       txa
   1203  27000				   -	       ora	#$50
   1204  27000				   -	       tax
   1205  27000				   -	       ENDIF
   1206  27000				   -qs4
   1207  27000				   -	       IF	FEAT_BASS16G3R
   1208  27000				   -	       lda	trackn_command+3+4
   1209  27000				   -	       and	#$0e
   1210  27000				   -	       cmp	#6
   1211  27000				   -	       bne	qs5
   1212  27000				   -	       lda	trackn_audc+3+4
   1213  27000				   -	       and	#$0f
   1214  27000				   -	       beq	qs5
   1215  27000				   -	       ldy	trackn_outnote+3+4
   1216  27000				   -	       lda	frqtabbasslo,y
   1217  27000				   -	       sta	trackn_audf+2+4
   1218  27000				   -	       lda	frqtabbasshi,y
   1219  27000				   -	       sta	trackn_audf+3+4
   1220  27000				   -	       IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2R
   1221  27000				   -	       lda	trackn_audc+2+4
   1222  27000				   -	       and	#$10
   1223  27000				   -	       bne	qs4a
   1224  27000				   -	       ENDIF
   1225  27000				   -	       lda	#0
   1226  27000				   -	       sta	trackn_audc+2+4
   1227  27000				   -qs4a
   1228  27000				   -	       txa
   1229  27000				   -	       ora	#$28
   1230  27000				   -	       tax
   1231  27000				   -	       ENDIF
   1232  27000				   -	       ENDIF
   1233  27000				   -qs5
   1234  27000				   -	       stx	v_audctl2
   1235  27000				   -	       ENDIF
   1236  27000				   -rmt_p5
   1237  27000				   -	       lda	smc_silence_instrspeed
   1238  27000				   -	       rts
   1239  27000				   -SetPokey
   1240  27000				   -	       IF	STEREO8T
   1241  27000				   -	       ldy	v_audctl2
   1242  27000				   -	       lda	trackn_audf+0+4
   1243  27000				   -	       ldx	trackn_audf+0
   1244  27000				   -	       sta	POKEY_BASE_S+$00
   1245  27000				   -	       stx	POKEY_BASE+$00
   1246  27000				   -	       lda	trackn_audc+0+4
   1247  27000				   -	       ldx	trackn_audc+0
   1248  27000				   -	       sta	POKEY_BASE_S+$01
   1249  27000				   -	       stx	POKEY_BASE+$01
   1250  27000				   -	       lda	trackn_audf+1+4
   1251  27000				   -	       ldx	trackn_audf+1
   1252  27000				   -	       sta	POKEY_BASE_S+$02
   1253  27000				   -	       stx	POKEY_BASE+$02
   1254  27000				   -	       lda	trackn_audc+1+4
   1255  27000				   -	       ldx	trackn_audc+1
   1256  27000				   -	       sta	POKEY_BASE_S+$03
   1257  27000				   -	       stx	POKEY_BASE+$03
   1258  27000				   -	       lda	trackn_audf+2+4
   1259  27000				   -	       ldx	trackn_audf+2
   1260  27000				   -	       sta	POKEY_BASE_S+$04
   1261  27000				   -	       stx	POKEY_BASE+$04
   1262  27000				   -	       lda	trackn_audc+2+4
   1263  27000				   -	       ldx	trackn_audc+2
   1264  27000				   -	       sta	POKEY_BASE_S+$05
   1265  27000				   -	       stx	POKEY_BASE+$05
   1266  27000				   -	       lda	trackn_audf+3+4
   1267  27000				   -	       ldx	trackn_audf+3
   1268  27000				   -	       sta	POKEY_BASE_S+$06
   1269  27000				   -	       stx	POKEY_BASE+$06
   1270  27000				   -	       lda	trackn_audc+3+4
   1271  27000				   -	       ldx	trackn_audc+3
   1272  27000				   -	       sta	POKEY_BASE_S+$07
   1273  27000				   -	       stx	POKEY_BASE+$07
   1274  27000				   -	       lda	v_audctl
   1275  27000				   -	       sty	POKEY_BASE_S+$08
   1276  27000				   -	       sta	POKEY_BASE+$08
   1277  27000				   -	       ELSE
   1278  27000				   -
   1279  27000				   -	       ifconst	RMTVOLUME
   1280  27000				   -	       lda	rmtvolume
   1281  27000				   -	       sta	fourbitfadevalueint
   1282  27000				   -	       endif
   1283  27000				   -	       ldy	v_audctl
   1284  27000				   -	       ldx	trackn_audf+0
   1285  27000				   -	       lda	trackn_audc+0
   1286  27000				   -	       ifconst	RMTVOLUME
   1287  27000				   -	       jsr	fourbitfadeint
   1288  27000				   -	       endif
   1289  27000				   -	       stx	POKEY_BASE+$00+0
   1290  27000				   -	       if	HARD_OF_HEARING
   1291  27000				   -	       stx	POKEY_BASE+$00+0
   1292  27000				   -	       endif
   1293  27000				   -	       sta	POKEY_BASE+$01+0
   1294  27000				   -	       if	HARD_OF_HEARING
   1295  27000				   -	       sta	POKEY_BASE+$01+0
   1296  27000				   -	       endif
   1297  27000				   -
   1298  27000				   -	       ldx	trackn_audf+1
   1299  27000				   -	       lda	trackn_audc+1
   1300  27000				   -	       ifconst	RMTVOLUME
   1301  27000				   -	       jsr	fourbitfadeint
   1302  27000				   -	       endif
   1303  27000				   -	       stx	POKEY_BASE+$00+2
   1304  27000				   -	       if	HARD_OF_HEARING
   1305  27000				   -	       stx	POKEY_BASE+$00+2
   1306  27000				   -	       endif
   1307  27000				   -	       sta	POKEY_BASE+$01+2
   1308  27000				   -	       if	HARD_OF_HEARING
   1309  27000				   -	       sta	POKEY_BASE+$01+2
   1310  27000				   -	       endif
   1311  27000				   -
   1312  27000				   -	       ldx	trackn_audf+2
   1313  27000				   -	       lda	trackn_audc+2
   1314  27000				   -	       ifconst	RMTVOLUME
   1315  27000				   -	       jsr	fourbitfadeint
   1316  27000				   -	       endif
   1317  27000				   -	       stx	POKEY_BASE+$00+4
   1318  27000				   -	       if	HARD_OF_HEARING
   1319  27000				   -	       stx	POKEY_BASE+$00+4
   1320  27000				   -	       endif
   1321  27000				   -	       sta	POKEY_BASE+$01+4
   1322  27000				   -	       if	HARD_OF_HEARING
   1323  27000				   -	       sta	POKEY_BASE+$01+4
   1324  27000				   -	       endif
   1325  27000				   -
   1326  27000				   -	       ldx	trackn_audf+3
   1327  27000				   -	       lda	trackn_audc+3
   1328  27000				   -	       ifconst	RMTVOLUME
   1329  27000				   -	       jsr	fourbitfadeint
   1330  27000				   -	       endif
   1331  27000				   -	       stx	POKEY_BASE+$00+6
   1332  27000				   -	       if	HARD_OF_HEARING
   1333  27000				   -	       stx	POKEY_BASE+$00+6
   1334  27000				   -	       endif
   1335  27000				   -	       sta	POKEY_BASE+$01+6
   1336  27000				   -	       if	HARD_OF_HEARING
   1337  27000				   -	       sta	POKEY_BASE+$01+6
   1338  27000				   -	       endif
   1339  27000				   -
   1340  27000				   -	       sty	POKEY_BASE+$08
   1341  27000				   -	       if	HARD_OF_HEARING
   1342  27000				   -	       sty	POKEY_BASE+$08
   1343  27000				   -	       endif
   1344  27000				   -
   1345  27000				   -	       ENDIF
   1346  27000				   -	       rts
   1347  27000				   -SetUpInstrumentY2
   1348  27000				   -	       lda	(p_instrstable),y
   1349  27000				   -	       sta	trackn_instrdb,x
   1350  27000				   -	       sta	_nt
   1351  27000				   -	       iny
   1352  27000				   -	       lda	(p_instrstable),y
   1353  27000				   -	       sta	trackn_instrhb,x
   1354  27000				   -	       sta	_nt+1
   1355  27000				   -	       ldy	#0
   1356  27000				   -	       lda	(_nt),y
   1357  27000				   -	       sta	trackn_tableend,x
   1358  27000				   -	       clc
   1359  27000				   -	       adc	#1
   1360  27000				   -	       sta	trackn_instridx,x
   1361  27000				   -	       iny
   1362  27000				   -	       lda	(_nt),y
   1363  27000				   -	       sta	trackn_tablelop,x
   1364  27000				   -	       iny
   1365  27000				   -	       lda	(_nt),y
   1366  27000				   -	       sta	trackn_instrlen,x
   1367  27000				   -	       iny
   1368  27000				   -	       lda	(_nt),y
   1369  27000				   -	       sta	trackn_instrlop,x
   1370  27000				   -	       iny
   1371  27000				   -	       lda	(_nt),y
   1372  27000				   -	       sta	trackn_tabletypespeed,x
   1373  27000				   -	       IF	FEAT_TABLETYPE||FEAT_TABLEMODE
   1374  27000				   -	       and	#$3f
   1375  27000				   -	       ENDIF
   1376  27000				   -	       sta	trackn_tablespeeda,x
   1377  27000				   -	       IF	FEAT_TABLEMODE
   1378  27000				   -	       lda	(_nt),y
   1379  27000				   -	       and	#$40
   1380  27000				   -	       sta	trackn_tablemode,x
   1381  27000				   -	       ENDIF
   1382  27000				   -	       iny
   1383  27000				   -	       IF	FEAT_AUDCTLMANUALSET
   1384  27000				   -	       lda	(_nt),y
   1385  27000				   -	       sta	trackn_audctl,x
   1386  27000				   -	       ENDIF
   1387  27000				   -	       iny
   1388  27000				   -	       lda	(_nt),y
   1389  27000				   -	       sta	trackn_volumeslidedepth,x
   1390  27000				   -	       iny
   1391  27000				   -	       lda	(_nt),y
   1392  27000				   -	       sta	trackn_volumemin,x
   1393  27000				   -	       iny
   1394  27000				   -	       lda	(_nt),y
   1395  27000				   -	       sta	trackn_effdelay,x
   1396  27000				   -	       iny
   1397  27000				   -	       lda	(_nt),y
   1398  27000				   -	       tay
   1399  27000				   -	       lda	vibtabbeg,y
   1400  27000				   -	       sta	trackn_effvibratoa,x
   1401  27000				   -	       sta	trackn_effvibratobeg,x
   1402  27000				   -	       lda	vibtabbeg+1,y
   1403  27000				   -	       sta	trackn_effvibratoend,x
   1404  27000				   -	       ldy	#10
   1405  27000				   -	       lda	(_nt),y
   1406  27000				   -	       sta	trackn_effshift,x
   1407  27000				   -	       lda	#128
   1408  27000				   -	       sta	trackn_volumeslidevalue,x
   1409  27000				   -	       lda	#0
   1410  27000				   -	       sta	trackn_instrreachend,x
   1411  27000				   -	       sta	trackn_shiftfrq,x
   1412  27000				   -	       lda	#INSTRPAR
   1413  27000				   -	       sta	trackn_tablea,x
   1414  27000				   -	       tay
   1415  27000				   -	       lda	(_nt),y
   1416  27000				   -	       sta	trackn_tablenote,x
   1417  27000				   -	       IF	FEAT_FILTER
   1418  27000				   -	       lda	#1
   1419  27000				   -	       sta	trackn_filter,x
   1420  27000				   -	       ENDIF
   1421  27000				   -	       rts
   1422  27000				   -InstrumentsEffects
   1423  27000				   -	       lda	trackn_effdelay,x
   1424  27000				   -	       beq	ei2
   1425  27000				   -	       tay
   1426  27000				   -	       dey
   1427  27000				   -	       bne	ei1
   1428  27000				   -	       lda	trackn_shiftfrq,x
   1429  27000				   -	       clc
   1430  27000				   -	       adc	trackn_effshift,x
   1431  27000				   -	       clc
   1432  27000				   -	       ldy	trackn_effvibratoa,x
   1433  27000				   -	       adc	vib0,y
   1434  27000				   -	       sta	trackn_shiftfrq,x
   1435  27000				   -	       iny
   1436  27000				   -	       tya
   1437  27000				   -	       cmp	trackn_effvibratoend,x
   1438  27000				   -	       bne	ei1a
   1439  27000				   -	       lda	trackn_effvibratobeg,x
   1440  27000				   -ei1a
   1441  27000				   -	       sta	trackn_effvibratoa,x
   1442  27000				   -	       jmp	ei2
   1443  27000				   -ei1
   1444  27000				   -	       tya
   1445  27000				   -	       sta	trackn_effdelay,x
   1446  27000				   -ei2
   1447  27000				   -	       lda	trackn_tableend,x
   1448  27000				   -	       cmp	#INSTRPAR
   1449  27000				   -	       beq	ei3
   1450  27000				   -	       lda	trackn_tablespeeda,x
   1451  27000				   -	       bpl	ei2f
   1452  27000				   -ei2c
   1453  27000				   -	       lda	trackn_tablea,x
   1454  27000				   -	       clc
   1455  27000				   -	       adc	#1
   1456  27000				   -	       cmp	trackn_tableend,x
   1457  27000				   -	       bcc	ei2a
   1458  27000				   -	       beq	ei2a
   1459  27000				   -	       lda	trackn_tablelop,x
   1460  27000				   -ei2a
   1461  27000				   -	       sta	trackn_tablea,x
   1462  27000				   -	       lda	trackn_instrdb,x
   1463  27000				   -	       sta	_nt
   1464  27000				   -	       lda	trackn_instrhb,x
   1465  27000				   -	       sta	_nt+1
   1466  27000				   -	       ldy	trackn_tablea,x
   1467  27000				   -	       lda	(_nt),y
   1468  27000				   -	       IF	FEAT_TABLEMODE
   1469  27000				   -	       ldy	trackn_tablemode,x
   1470  27000				   -	       beq	ei2e
   1471  27000				   -	       clc
   1472  27000				   -	       adc	trackn_tablenote,x
   1473  27000				   -ei2e
   1474  27000				   -	       ENDIF
   1475  27000				   -	       sta	trackn_tablenote,x
   1476  27000				   -	       lda	trackn_tabletypespeed,x
   1477  27000				   -	       IF	FEAT_TABLETYPE||FEAT_TABLEMODE
   1478  27000				   -	       and	#$3f
   1479  27000				   -	       ENDIF
   1480  27000				   -ei2f
   1481  27000				   -	       sec
   1482  27000				   -	       sbc	#1
   1483  27000				   -	       sta	trackn_tablespeeda,x
   1484  27000				   -ei3
   1485  27000				   -	       lda	trackn_instrreachend,x
   1486  27000				   -	       bpl	ei4
   1487  27000				   -	       lda	trackn_volume,x
   1488  27000				   -	       beq	ei4
   1489  27000				   -	       cmp	trackn_volumemin,x
   1490  27000				   -	       beq	ei4
   1491  27000				   -	       bcc	ei4
   1492  27000				   -	       tay
   1493  27000				   -	       lda	trackn_volumeslidevalue,x
   1494  27000				   -	       clc
   1495  27000				   -	       adc	trackn_volumeslidedepth,x
   1496  27000				   -	       sta	trackn_volumeslidevalue,x
   1497  27000				   -	       bcc	ei4
   1498  27000				   -	       tya
   1499  27000				   -	       sbc	#16
   1500  27000				   -	       sta	trackn_volume,x
   1501  27000				   -ei4
   1502  27000				   -	       jmp	returnfromInstrumentsEffects
   1503  27000				   -
   1504  27000				   -rmtmoduleend
   1505  27000				   -	       echo	"  (rmtplayer module is using ",[(rmtmoduleend-rmtmodulestart)]d," bytes of rom)"
   1506  27000				   -	       echo	"  (rmtplayer module is using ",[(MEMLOC-RMTRAM-1)]d," bytes of ram)"
   1507  27000				   -
   1508  27000					       endif		; RMT
------- FILE c:\Users\seany\Documents\irata\0087_Irata.78b.asm
   2384  27000					       endif
   2385  27000					       ifnconst	included.7800vox.asm
------- FILE 7800vox.asm LEVEL 2 PASS 3
      0  27000					       include	7800vox.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000							; AtariVox 7800basic wrapper
      4  27000
      5  27000							; to be called with
      6  27000							; A=# of bytes
      7  27000							;
      8  27000
      9  27000				   -	       ifconst	HSSUPPORT
     10  27000				   -
     11  27000				   -_7800voxstart
     12  27000				   -
     13  27000				   -AVoxReadBytes
     14  27000				   -	       sta	temp8
     15  27000				   -	       jsr	i2c_startwrite
     16  27000				   -	       bcs	eeprom_error
     17  27000				   -
     18  27000				   -	       lda	HSVoxHi
     19  27000				   -	       jsr	i2c_txbyte
     20  27000				   -	       lda	HSVoxLo
     21  27000				   -	       jsr	i2c_txbyte
     22  27000				   -	       jsr	i2c_stopwrite
     23  27000				   -
     24  27000				   -	       jsr	i2c_startread
     25  27000				   -
     26  27000				   -	       ldx	#0
     27  27000				   -AVoxReadBytesLoop
     28  27000				   -	       jsr	i2c_rxbyte
     29  27000				   -	       sta	eeprombuffer,x
     30  27000				   -	       inx
     31  27000				   -	       cpx	temp8
     32  27000				   -	       bne	AVoxReadBytesLoop
     33  27000				   -	       jsr	i2c_stopread
     34  27000				   -	       lda	#0
     35  27000				   -	       rts
     36  27000				   -
     37  27000				   -			; to be called with
     38  27000				   -			; A=# of bytes
     39  27000				   -			;
     40  27000				   -
     41  27000				   -AVoxWriteBytes
     42  27000				   -	       sta	temp8
     43  27000				   -	       jsr	i2c_startwrite
     44  27000				   -	       bcs	eeprom_error
     45  27000				   -
     46  27000				   -	       lda	HSVoxHi
     47  27000				   -	       jsr	i2c_txbyte
     48  27000				   -	       lda	HSVoxLo
     49  27000				   -	       jsr	i2c_txbyte
     50  27000				   -
     51  27000				   -	       ldx	#$00
     52  27000				   -AVoxWriteBytesLoop
     53  27000				   -	       lda	eeprombuffer,x
     54  27000				   -	       jsr	i2c_txbyte
     55  27000				   -	       inx
     56  27000				   -	       cpx	temp8
     57  27000				   -	       bne	AVoxWriteBytesLoop
     58  27000				   -	       jsr	i2c_stopwrite
     59  27000				   -
     60  27000				   -	       lda	#0
     61  27000				   -	       rts
     62  27000				   -
     63  27000				   -eeprom_error
     64  27000				   -	       lda	#$ff
     65  27000				   -	       rts
     66  27000				   -
     67  27000				   -AVoxDetect
     68  27000				   -
     69  27000				   -	       jsr	i2c_startwrite
     70  27000				   -	       bcs	eeprom_error
     71  27000				   -	       lda	#$30
     72  27000				   -	       jsr	i2c_txbyte
     73  27000				   -	       lda	#$00
     74  27000				   -	       jsr	i2c_txbyte
     75  27000				   -	       jsr	i2c_stopwrite
     76  27000				   -	       rts
     77  27000				   -
     78  27000				   -	       include	"i2c7800.inc"
     79  27000				   -	       I2C_SUBS	temp9
     80  27000				   -
     81  27000				   -_7800voxend
     82  27000				   -
     83  27000				   -	       echo	"  (7800vox module is using ",[(_7800voxend-_7800voxstart)]d," bytes)"
     84  27000				   -
     85  27000					       endif
     86  27000
------- FILE c:\Users\seany\Documents\irata\0087_Irata.78b.asm
   2387  27000					       endif
   2388  27000					       ifnconst	included.pokeysound.asm
------- FILE pokeysound.asm LEVEL 2 PASS 3
      0  27000					       include	pokeysound.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000
      4  27000				   -	       ifconst	pokeysupport
      5  27000				   -
      6  27000				   -pokeysoundmodulestart
      7  27000				   -
      8  27000				   -mutepokey
      9  27000				   -	       lda	#0
     10  27000				   -	       ldy	#7
     11  27000				   -mutepokeyloop
     12  27000				   -	       sta	pokey1pointlo,y
     13  27000				   -	       sta	(pokeybaselo),y
     14  27000				   -	       dey
     15  27000				   -	       bpl	mutepokeyloop
     16  27000				   -	       rts
     17  27000				   -
     18  27000				   -	       ifconst	pokeysfxsupport
     19  27000				   -
     20  27000				   -checkpokeyplaying
     21  27000				   -	       ldx	#6
     22  27000				   -checkpokeyplayingloop
     23  27000				   -	       lda	pokey1pointlo,x
     24  27000				   -	       ora	pokey1pointhi,x
     25  27000				   -	       beq	pokeychannelinactive
     26  27000				   -	       jsr	playpokeysfxA	; x=channel*2
     27  27000				   -pokeychannelinactive
     28  27000				   -	       dex
     29  27000				   -	       dex
     30  27000				   -	       bpl	checkpokeyplayingloop
     31  27000				   -	       rts
     32  27000				   -
     33  27000				   -playpokeysfxA
     34  27000				   -	       txa
     35  27000				   -	       tay
     36  27000				   -	       lda	pokey1tick,x
     37  27000				   -	       beq	playpokeysfxAcont
     38  27000				   -	       sec
     39  27000				   -	       sbc	#1
     40  27000				   -	       sta	pokey1tick,x	; sound resolution is >1 frame, and we're mid-tock...
     41  27000				   -	       rts
     42  27000				   -
     43  27000				   -playpokeysfxAcont
     44  27000				   -	       lda	pokey1frames,x	; set the frame countdown for this sound chunk
     45  27000				   -	       sta	pokey1tick,x
     46  27000				   -
     47  27000				   -	       lda	pokey1priority,x	; decrease the sound's priority if its non-zero
     48  27000				   -	       beq	playpokeysfxAcont2
     49  27000				   -	       sec
     50  27000				   -	       sbc	#1
     51  27000				   -	       sta	pokey1priority,x
     52  27000				   -playpokeysfxAcont2
     53  27000				   -
     54  27000				   -			; *** FREQUENCY
     55  27000				   -	       lda	(pokey1pointlo,x)
     56  27000				   -	       sta	inttemp1
     57  27000				   -	       clc
     58  27000				   -	       adc	pokey1offset,x	; take into account any pitch modification
     59  27000				   -	       sta	(pokeybaselo),y	; PAUDF0,0
     60  27000				   -
     61  27000				   -			;advance the data pointer +1
     62  27000				   -	       inc	pokey1pointlo,x
     63  27000				   -	       bne	skippokeyhiinc1
     64  27000				   -	       inc	pokey1pointhi,x
     65  27000				   -skippokeyhiinc1
     66  27000				   -
     67  27000				   -			; *** WAVE
     68  27000				   -	       lda	(pokey1pointlo,x)
     69  27000				   -	       asl
     70  27000				   -	       asl
     71  27000				   -	       asl
     72  27000				   -	       asl		; x16
     73  27000				   -
     74  27000				   -			;advance the data pointer +1
     75  27000				   -	       inc	pokey1pointlo,x
     76  27000				   -	       bne	skippokeyhiinc2
     77  27000				   -	       inc	pokey1pointhi,x
     78  27000				   -skippokeyhiinc2
     79  27000				   -
     80  27000				   -	       ora	(pokey1pointlo,x)
     81  27000				   -	       iny
     82  27000				   -	       sta	(pokeybaselo),y
     83  27000				   -
     84  27000				   -	       ora	inttemp1	; check if F|C|V=0
     85  27000				   -	       beq	zeropokeypoint	; if so, we're at the end of the sound.
     86  27000				   -
     87  27000				   -			; advance the pointer +1, on to the next sound chunk
     88  27000				   -	       inc	pokey1pointlo,x
     89  27000				   -	       bne	skippokeyhiinc3
     90  27000				   -	       inc	pokey1pointhi,x
     91  27000				   -skippokeyhiinc3
     92  27000				   -	       rts
     93  27000				   -
     94  27000				   -zeropokeypoint
     95  27000				   -	       sta	pokey1pointlo,x
     96  27000				   -	       sta	pokey1pointhi,x
     97  27000				   -	       sta	pokey1priority,x
     98  27000				   -	       rts
     99  27000				   -
    100  27000				   -schedulepokeysfx
    101  27000				   -	       ldx	#6
    102  27000				   -schedulepokeysfxloop
    103  27000				   -	       lda	pokey1pointlo,x
    104  27000				   -	       ora	pokey1pointhi,x
    105  27000				   -	       bne	schedulespokeysearch
    106  27000				   -	       jmp	schedulepokeyX	; we found an unused channel, so use it...
    107  27000				   -schedulespokeysearch
    108  27000				   -	       dex
    109  27000				   -	       dex
    110  27000				   -	       bpl	schedulepokeysfxloop
    111  27000				   -
    112  27000				   -			; if we're here, all 4 channels are presently playing a sound...
    113  27000				   -	       ldy	#1
    114  27000				   -	       lda	(sfxinstrumentlo),y	; peek at the priority of this sfx...
    115  27000				   -	       bne	schedulepokeysfxcont1
    116  27000				   -	       rts		; ...and skip it if it's 0 priority
    117  27000				   -schedulepokeysfxcont1
    118  27000				   -
    119  27000				   -			; figure out which current sound has the lowest priority...
    120  27000				   -	       lda	#0
    121  27000				   -	       sta	temp8
    122  27000				   -	       lda	pokey1priority
    123  27000				   -	       sta	temp9
    124  27000				   -	       ldx	#6
    125  27000				   -findlowprioritypokeyloop
    126  27000				   -	       lda	pokey1priority,x
    127  27000				   -	       cmp	temp9
    128  27000				   -	       bcs	findlowprioritypokeyloopcontinue
    129  27000				   -	       sta	temp9
    130  27000				   -	       stx	temp8
    131  27000				   -findlowprioritypokeyloopcontinue
    132  27000				   -	       dex
    133  27000				   -	       dex
    134  27000				   -	       bne	findlowprioritypokeyloop
    135  27000				   -	       ldx	temp8	; the low priority channel we'll interrupt
    136  27000				   -
    137  27000				   -schedulepokeyX
    138  27000				   -			;called with X=2*pokey channel to play on...
    139  27000				   -	       ldy	#1	; get priority and sound-resolution (in frames)
    140  27000				   -	       lda	(sfxinstrumentlo),y
    141  27000				   -	       sta	pokey1priority,x
    142  27000				   -	       iny
    143  27000				   -	       lda	(sfxinstrumentlo),y
    144  27000				   -	       sta	pokey1frames,x
    145  27000				   -
    146  27000				   -	       lda	sfxinstrumentlo
    147  27000				   -	       clc
    148  27000				   -	       adc	#3
    149  27000				   -	       sta	pokey1pointlo,x
    150  27000				   -	       lda	sfxinstrumenthi
    151  27000				   -	       adc	#0
    152  27000				   -	       sta	pokey1pointhi,x
    153  27000				   -	       lda	sfxpitchoffset
    154  27000				   -	       sta	pokey1offset,x
    155  27000				   -	       lda	#0
    156  27000				   -	       sta	pokey1tick,x
    157  27000				   -	       rts
    158  27000				   -	       else
    159  27000				   -schedulepokeysfx		; just some stubs
    160  27000				   -checkpokeyplaying
    161  27000				   -	       rts
    162  27000				   -	       endif		; pokeysfxsupport
    163  27000				   -
    164  27000				   -			; pokey detection routine. we check for pokey in the XBOARD/XM location,
    165  27000				   -			; and the standard $4000 location.
    166  27000				   -			; if pokey the pokey is present, this routine will reset it.
    167  27000				   -	       ifconst	pokeyaddress
    168  27000				   -detectpokeylocation
    169  27000				   -	       lda	#<pokeyaddress
    170  27000				   -	       sta	pokeybaselo
    171  27000				   -	       lda	#>pokeyaddress
    172  27000				   -	       sta	pokeybasehi
    173  27000				   -	       lda	#$ff
    174  27000				   -	       sta	pokeydetected
    175  27000				   -
    176  27000				   -	       if	pokeyaddress = $450
    177  27000				   -	       lda	XCTRL1s
    178  27000				   -	       ora	#%00010100
    179  27000				   -	       sta	XCTRL1s
    180  27000				   -	       sta	XCTRL1
    181  27000				   -	       endif
    182  27000				   -
    183  27000				   -
    184  27000				   -	       lda	#0
    185  27000				   -	       ldy	#15
    186  27000				   -clearpokeyloop
    187  27000				   -	       sta	(pokeybase),y
    188  27000				   -	       dey
    189  27000				   -	       bpl	clearpokeyloop
    190  27000				   -			; take pokey out of reset...
    191  27000				   -	       ldy	#PSKCTL
    192  27000				   -	       lda	#3
    193  27000				   -	       sta	(pokeybase),y
    194  27000				   -	       ldy	#PAUDCTL
    195  27000				   -	       lda	#0
    196  27000				   -	       sta	(pokeybase),y
    197  27000				   -	       rts
    198  27000				   -	       else		; !pokeyaddress
    199  27000				   -detectpokeylocation
    200  27000				   -			;XBoard/XM...
    201  27000				   -	       ldx	#2
    202  27000				   -detectpokeyloop
    203  27000				   -	       lda	XCTRL1s
    204  27000				   -	       ora	#%00010100
    205  27000				   -	       and	POKEYXMMASK,x
    206  27000				   -	       sta	XCTRL1s
    207  27000				   -	       sta	XCTRL1
    208  27000				   -
    209  27000				   -	       lda	POKEYCHECKLO,x
    210  27000				   -	       sta	pokeybaselo
    211  27000				   -	       lda	POKEYCHECKHI,x
    212  27000				   -	       sta	pokeybasehi
    213  27000				   -	       jsr	checkforpokey
    214  27000				   -	       lda	pokeydetected
    215  27000				   -	       beq	foundpokeychip
    216  27000				   -	       dex
    217  27000				   -	       bpl	detectpokeyloop
    218  27000				   -foundpokeychip
    219  27000				   -	       eor	#$ff	; invert state for 7800basic if...then test
    220  27000				   -	       sta	pokeydetected
    221  27000				   -	       rts
    222  27000				   -
    223  27000				   -POKEYXMMASK
    224  27000				   -			;     XM POKEY on    XM POKEY off   XM POKEY off
    225  27000				   -	       .byte	%11111111, %11101111, %11101111
    226  27000				   -
    227  27000				   -POKEYCHECKLO
    228  27000				   -	       .byte	<$0450, <$0450, <$4000
    229  27000				   -POKEYCHECKHI
    230  27000				   -	       .byte	>$0450, >$0450, >$4000
    231  27000				   -
    232  27000				   -checkforpokey
    233  27000				   -	       ldy	#$0f
    234  27000				   -	       lda	#$00
    235  27000				   -	       sta	pokeydetected	; start off by assuming pokey will be detected
    236  27000				   -resetpokeyregistersloop
    237  27000				   -	       sta	(pokeybase),y
    238  27000				   -	       dey
    239  27000				   -	       bpl	resetpokeyregistersloop
    240  27000				   -
    241  27000				   -	       ldy	#PAUDCTL
    242  27000				   -	       sta	(pokeybase),y
    243  27000				   -	       ldy	#PSKCTL
    244  27000				   -	       sta	(pokeybase),y
    245  27000				   -
    246  27000				   -			; let the dust settle...
    247  27000				   -	       nop
    248  27000				   -	       nop
    249  27000				   -	       nop
    250  27000				   -
    251  27000				   -	       lda	#4
    252  27000				   -	       sta	temp9
    253  27000				   -pokeycheckloop1
    254  27000				   -			; we're in reset, so the RANDOM register should read $ff...
    255  27000				   -	       ldy	#PRANDOM
    256  27000				   -	       lda	(pokeybase),y
    257  27000				   -	       cmp	#$ff
    258  27000				   -	       bne	nopokeydetected
    259  27000				   -	       dec	temp9
    260  27000				   -	       bne	pokeycheckloop1
    261  27000				   -
    262  27000				   -			; take pokey out of reset...
    263  27000				   -	       ldy	#PSKCTL
    264  27000				   -	       lda	#3
    265  27000				   -	       sta	(pokeybase),y
    266  27000				   -	       ldy	#PAUDCTL
    267  27000				   -	       lda	#0
    268  27000				   -	       sta	(pokeybase),y
    269  27000				   -
    270  27000				   -			; let the dust settle again...
    271  27000				   -	       nop
    272  27000				   -	       nop
    273  27000				   -	       nop
    274  27000				   -
    275  27000				   -	       lda	#4
    276  27000				   -	       sta	temp9
    277  27000				   -pokeycheckloop2
    278  27000				   -			; we're out of reset, so RANDOM should read non-$ff...
    279  27000				   -	       ldy	#PRANDOM
    280  27000				   -	       lda	(pokeybase),y
    281  27000				   -	       cmp	#$ff
    282  27000				   -	       beq	skippokeycheckreturn
    283  27000				   -	       rts
    284  27000				   -skippokeycheckreturn
    285  27000				   -	       dec	temp9
    286  27000				   -	       bne	pokeycheckloop2
    287  27000				   -nopokeydetected
    288  27000				   -	       dec	pokeydetected	; pokeydetected=#$ff
    289  27000				   -	       rts
    290  27000				   -
    291  27000				   -	       endif		; !pokeyaddress
    292  27000				   -
    293  27000				   -pokeysoundmoduleend
    294  27000				   -
    295  27000				   -	       echo	"  (pokeysound module is using ",[(pokeysoundmoduleend-pokeysoundmodulestart)]d," bytes of rom)"
    296  27000				   -
    297  27000					       endif		; pokeysupport
------- FILE c:\Users\seany\Documents\irata\0087_Irata.78b.asm
   2390  27000					       endif
   2391  27000					       ifnconst	included.snes2atari.asm
------- FILE snes2atari.asm LEVEL 2 PASS 3
      0  27000					       include	snes2atari.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000				   -	       ifconst	SNES2ATARISUPPORT
      4  27000				   -snes2atarimodulestart
      5  27000				   -
      6  27000				   -SNES_CLOCK_PORT_BIT
      7  27000				   -	       .byte	$10,$01
      8  27000				   -SNES_CTLSWA_MASK
      9  27000				   -	       .byte	$30,$03
     10  27000				   -SNES_CTLSWA_SIGNAL
     11  27000				   -	       .byte	$C0,$0C
     12  27000				   -
     13  27000				   -			; Probe each port for SNES, and see if autodetection succeeds anywhere.
     14  27000				   -SNES_AUTODETECT
     15  27000				   -	       ifconst	HSSUPPORT
     16  27000				   -			; ** an atarivox might be plugged in, so we skip scanning the second
     17  27000				   -			; ** port for a snes if vox was detected...
     18  27000				   -	       lda	hsdevice	; b1 high means atarivox/savekey was detected
     19  27000				   -	       lsr
     20  27000				   -	       and	#1
     21  27000				   -	       eor	#1
     22  27000				   -	       tax
     23  27000				   -	       else
     24  27000				   -	       ldx	#1
     25  27000				   -	       endif		; HSSUPPORT
     26  27000				   -
     27  27000				   -SNES_AUTODETECT_LOOP
     28  27000				   -	       ifnconst	MULTIBUTTON	; snesdetect shouldn't be used in multibutton mode
     29  27000				   -	       lda	#1	; proline
     30  27000				   -	       sta	port0control,x
     31  27000				   -	       jsr	setportforinput
     32  27000				   -	       jsr	setonebuttonmode
     33  27000				   -	       jsr	SNES_READ
     34  27000				   -	       lda	snesdetected0,x
     35  27000				   -	       bne	SNES_AUTODETECT_FOUND
     36  27000				   -			; detection failed
     37  27000				   -	       jsr	setportforinput
     38  27000				   -	       jsr	settwobuttonmode
     39  27000				   -	       dex
     40  27000				   -	       bpl	SNES_AUTODETECT_LOOP
     41  27000				   -	       rts
     42  27000				   -SNES_AUTODETECT_FOUND
     43  27000				   -	       lda	#11	; formally set the snes controller
     44  27000				   -	       sta	port0control,x
     45  27000				   -	       stx	snesport
     46  27000				   -	       endif		; !MULTIBUTTON
     47  27000				   -	       rts
     48  27000					       endif		; SNES2ATARISUPPORT
     49  27000
     50  27000				    snes2atarihandler
     51  27000				   -	       ifconst	SNES2ATARISUPPORT
     52  27000				   -SNES2ATARI
     53  27000				   -	       jsr	SNES_READ
     54  27000				   -	       jmp	buttonreadloopreturn
     55  27000				   -
     56  27000				   -SNES_READ
     57  27000				   -			; x=0 for left port, x=1 for right
     58  27000				   -	       lda	port0control,x
     59  27000				   -	       cmp	#11	; snes
     60  27000				   -	       bne	snes2atari_signal_go	; if this is a first auto-detection read, go ahead and signal
     61  27000				   -	       lda	snesdetected0,x
     62  27000				   -	       bne	snes2atari_signal_skip	; if snes was available in previous frames, skip signalling
     63  27000				   -snes2atari_signal_go
     64  27000				   -	       jsr	SNES2ATARI_SIGNAL
     65  27000				   -snes2atari_signal_skip
     66  27000				   -
     67  27000				   -	       lda	CTLSWA
     68  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
     69  27000				   -	       ora	SNES_CTLSWA_MASK,x
     70  27000				   -	       sta	CTLSWA	; enable pins UP/DOWN to work as outputs
     71  27000				   -
     72  27000				   -	       lda	SWCHA
     73  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
     74  27000				   -	       ora	SNES_CTLSWA_MASK,x
     75  27000				   -
     76  27000				   -	       sta	SWCHA	; latch+clock high
     77  27000				   -	       nop
     78  27000				   -	       nop
     79  27000				   -	       nop
     80  27000				   -	       nop
     81  27000				   -	       nop
     82  27000				   -	       nop
     83  27000				   -	       nop
     84  27000				   -	       lda	SWCHA
     85  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
     86  27000				   -	       sta	SWCHA	; latch and clock low
     87  27000				   -	       ldy	#16	; 16 bits
     88  27000				   -SNES2ATARILOOP
     89  27000				   -	       rol	INPT4,x	; sample data into carry
     90  27000				   -	       lda	SWCHA
     91  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
     92  27000				   -	       ora	SNES_CLOCK_PORT_BIT,x
     93  27000				   -	       sta	SWCHA	; clock low
     94  27000				   -	       rol	snes2atari0lo,x
     95  27000				   -	       rol	snes2atari0hi,x
     96  27000				   -	       lda	SWCHA
     97  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
     98  27000				   -	       sta	SWCHA	; latch and clock low
     99  27000				   -	       dey		; next bit
    100  27000				   -	       bne	SNES2ATARILOOP
    101  27000				   -	       rol	INPT4,x	; 17th bit should be lo if controller is there.
    102  27000				   -	       rol		; 17th snes bit into A low bit
    103  27000				   -	       eor	snes2atari0lo,x	; 16th bit should be hi if controller is there.
    104  27000				   -	       and	#1
    105  27000				   -	       sta	snesdetected0,x
    106  27000				   -	       beq	SNES_STOP_CLOCK	; if snes isn't detected, leave port in default state
    107  27000				   -	       stx	snesport	; snesport keeps the index of the latest autodetected controller
    108  27000				   -	       lda	SWCHA
    109  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
    110  27000				   -	       ora	SNES_CLOCK_PORT_BIT,x
    111  27000				   -	       jmp	SNES_STOP_CLOCK
    112  27000				   -SNES_STOP_CLOCK
    113  27000				   -	       sta	SWCHA	; clock low
    114  27000				   -	       lda	CTLSWA
    115  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
    116  27000				   -			;ora SNES_CLOCK_PORT_BIT,x
    117  27000				   -	       sta	CTLSWA	; set port bits to input avoid conflict with other drivers
    118  27000				   -	       ifconst	MULTIBUTTON
    119  27000				   -	       lda	snesdetected0,x
    120  27000				   -	       bne	snesexit
    121  27000				   -	       lda	#1	; proline
    122  27000				   -	       sta	port0control,x
    123  27000				   -	       jmp	settwobuttonmode
    124  27000				   -snesexit
    125  27000				   -	       lda	#6
    126  27000				   -	       sta	multibuttoncount0,x
    127  27000				   -			; stuff directions into sSWCHA nibble and buttons into sINPT1,x...
    128  27000				   -	       lda	s2a_joyshiftcount,x
    129  27000				   -	       tay
    130  27000				   -	       lda	snes2atari0hi,x
    131  27000				   -snesjoypadloop
    132  27000				   -	       lsr
    133  27000				   -	       rol	inttemp6
    134  27000				   -	       dey
    135  27000				   -	       bpl	snesjoypadloop
    136  27000				   -	       lda	sSWCHA
    137  27000				   -	       ora	SWCHA_DIRMASK,x	; turn off the bits for this port
    138  27000				   -	       sta	sSWCHA
    139  27000				   -	       lda	inttemp6
    140  27000				   -	       ora	SWCHA_DIRMASK+1,x	; don't change the other port
    141  27000				   -	       and	sSWCHA
    142  27000				   -	       sta	sSWCHA
    143  27000				   -
    144  27000				   -			; snes2atari0hi = B  Y  Se St *  *  *	*
    145  27000				   -			; snes2atari0lo = A  X  Ls Rs
    146  27000				   -			; sINPT1	 = B  A  Y  X  Ls Rs Se St
    147  27000				   -	       lda	snes2atari0lo,x
    148  27000				   -	       sta	inttemp5
    149  27000				   -	       lda	snes2atari0hi,x
    150  27000				   -	       sta	inttemp6
    151  27000				   -	       asl	inttemp5	; A
    152  27000				   -	       rol
    153  27000				   -	       asl	inttemp6	; B
    154  27000				   -	       rol
    155  27000				   -	       asl	inttemp6	; Y
    156  27000				   -	       rol
    157  27000				   -	       asl	inttemp5	; X
    158  27000				   -	       rol
    159  27000				   -	       asl	inttemp5	; Ls
    160  27000				   -	       rol
    161  27000				   -	       asl	inttemp5	; Rs
    162  27000				   -	       rol
    163  27000				   -	       asl	inttemp6	; Ls
    164  27000				   -	       rol
    165  27000				   -	       asl	inttemp6	; Rs
    166  27000				   -	       rol
    167  27000				   -	       eor	#%11000000	; invert to match proline
    168  27000				   -	       sta	sINPT1,x
    169  27000				   -	       endif		; MULTIBUTTON
    170  27000				   -	       rts
    171  27000				   -SNES2ATARI_SIGNAL
    172  27000				   -			; signal to SNES2ATARI++ that we want SNES mode...
    173  27000				   -	       lda	CTLSWA
    174  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
    175  27000				   -	       ora	SNES_CTLSWA_SIGNAL,x
    176  27000				   -	       sta	CTLSWA
    177  27000				   -	       lda	SWCHA
    178  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other nibble
    179  27000				   -	       sta	SWCHA
    180  27000				   -	       ldy	#16
    181  27000				   -SNES_SIGNAL_LOOP
    182  27000				   -	       dey
    183  27000				   -	       bne	SNES_SIGNAL_LOOP
    184  27000				   -	       lda	SWCHA
    185  27000				   -	       ora	SWCHA_DIRMASK,x
    186  27000				   -	       sta	SWCHA
    187  27000				   -	       rts
    188  27000				   -s2a_joyshiftcount
    189  27000				   -	       .byte	7,3
    190  27000				   -snes2atarimoduleend
    191  27000				   -	       echo	"  (snes2atari module is using ",[(snes2atarimoduleend-snes2atarimodulestart)]d," bytes of rom)"
    192  27000					       endif		; SNES2ATARISUPPORT
    193  27000
    194  27000
------- FILE c:\Users\seany\Documents\irata\0087_Irata.78b.asm
   2393  27000					       endif
   2394  27000					       ifnconst	included.mega7800.asm
------- FILE mega7800.asm LEVEL 2 PASS 3
      0  27000					       include	mega7800.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000				    mega7800handlerstart
      4  27000				    mega7800handler
      5  27000				   -	       ifconst	MEGA7800SUPPORT
      6  27000				   -
      7  27000				   -			; ** stuff the joyick directions into the shadow register
      8  27000				   -	       lda	sSWCHA	; clear previous dirs for this pad, from
      9  27000				   -	       ora	SWCHA_DIRMASK,x	; our sSWCHA nibble.
     10  27000				   -	       sta	sSWCHA
     11  27000				   -	       lda	SWCHA	; load the actual joystick dirs, ensuring
     12  27000				   -	       ora	SWCHA_DIRMASK+1,x	; we don't change the other nibble.
     13  27000				   -	       and	sSWCHA
     14  27000				   -	       sta	sSWCHA
     15  27000				   -
     16  27000				   -			; x=0 for left port, x=1 for right
     17  27000				   -
     18  27000				   -	       lda	#0
     19  27000				   -	       sta	inttemp5	; temporary button-state storage
     20  27000				   -	       sta	inttemp6	; temporary button-state storage
     21  27000				   -
     22  27000				   -	       lda	CTLSWA
     23  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other port nibble
     24  27000				   -	       ora	MEGA_INIT,x
     25  27000				   -	       sta	CTLSWA	; enable pins UP/DOWN to work as outputs
     26  27000				   -
     27  27000				   -			; the controller type bits take a few cycles to get set after we start
     28  27000				   -			; an extended read, so we'll start the first extended read early...
     29  27000				   -	       lda	SWCHA
     30  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other port nibble
     31  27000				   -	       sta	SWCHA	; all bits are low, which STARTS the extended read
     32  27000				   -	       nop
     33  27000				   -	       nop
     34  27000				   -
     35  27000				   -			; first read  will be pad state (mega7800 connect and controller type)
     36  27000				   -			; second read will be 3 button support (SACB)
     37  27000				   -			; third read  will be 6 button support (MXYZ)
     38  27000				   -
     39  27000				   -	       ldy	#5	; read 6x states, with the first 2x being the controller type
     40  27000				   -m7readloop
     41  27000				   -	       lda	SWCHA
     42  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other port nibble
     43  27000				   -	       sta	SWCHA	; all bits are low, which STARTS the read
     44  27000				   -
     45  27000				   -	       lda	SWCHA
     46  27000				   -	       cpx	#1
     47  27000				   -	       bne	m7skipp1shift
     48  27000				   -	       asl
     49  27000				   -	       asl
     50  27000				   -	       asl
     51  27000				   -	       asl
     52  27000				   -m7skipp1shift
     53  27000				   -	       asl		; button bit 1 into carry
     54  27000				   -	       rol	inttemp6
     55  27000				   -	       rol	inttemp5
     56  27000				   -	       asl		; button bit 0 into carry
     57  27000				   -	       rol	inttemp6
     58  27000				   -	       rol	inttemp5
     59  27000				   -
     60  27000				   -	       lda	SWCHA
     61  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other port nibble
     62  27000				   -	       ora	MEGA_NEXT,x
     63  27000				   -	       sta	SWCHA
     64  27000				   -
     65  27000				   -	       dey
     66  27000				   -	       bpl	m7readloop
     67  27000				   -
     68  27000				   -	       lda	CTLSWA
     69  27000				   -	       and	SWCHA_DIRMASK+1,x	; preserve other port nibble
     70  27000				   -	       sta	CTLSWA	; set this port back to input
     71  27000				   -
     72  27000				   -			; if mega7800 isn't detected this frame, unpress any buttons...
     73  27000				   -	       lda	inttemp5
     74  27000				   -	       and	#%00000011
     75  27000				   -	       beq	m7skipscuttle
     76  27000				   -	       lda	#$ff
     77  27000				   -	       sta	inttemp6
     78  27000				   -	       ifconst	MULTIBUTTON
     79  27000				   -			; the controller isn't present... revert to proline
     80  27000				   -	       lda	#1	; proline
     81  27000				   -	       sta	port0control,x
     82  27000				   -	       rts
     83  27000				   -	       endif		; MULTIBUTTON
     84  27000				   -m7skipscuttle
     85  27000				   -	       ifconst	MULTIBUTTON
     86  27000				   -	       lda	inttemp5
     87  27000				   -	       lsr
     88  27000				   -	       lsr
     89  27000				   -	       and	#3
     90  27000				   -	       tay
     91  27000				   -	       lda	megabuttons,y
     92  27000				   -	       sta	multibuttoncount0,x
     93  27000				   -	       endif		; MULTIBUTTON
     94  27000				   -
     95  27000				   -	       lda	inttemp5
     96  27000				   -	       sta	mega7800state0,x
     97  27000				   -	       lda	inttemp6
     98  27000				   -	       sta	mega7800data0,x
     99  27000				   -
    100  27000				   -	       ifconst	MULTIBUTTON
    101  27000				   -			; now update the genric multi-button bits...
    102  27000				   -	       ldy	#7
    103  27000				   -m7shuffleloop
    104  27000				   -	       lda	inttemp6
    105  27000				   -	       and	m7reorder,y
    106  27000				   -	       clc
    107  27000				   -	       adc	#$FF	; bit value in carry
    108  27000				   -	       rol	inttemp5
    109  27000				   -	       dey
    110  27000				   -	       bpl	m7shuffleloop
    111  27000				   -	       lda	inttemp5
    112  27000				   -	       eor	#%11000000
    113  27000				   -	       sta	sINPT1,x
    114  27000				   -	       rts
    115  27000				   -
    116  27000				   -megabuttons
    117  27000				   -	       .byte	6,2,3,2
    118  27000				   -m7reorder
    119  27000				   -			;	  S	     M	       Z	 Y
    120  27000				   -	       .byte	%00100000,%00000010,%00000100,%00001000
    121  27000				   -			;	  X	     C	       A	 B
    122  27000				   -	       .byte	%00000001,%10000000,%00010000,%01000000
    123  27000				   -	       else		;  !MULTIBUTTON
    124  27000				   -	       rts
    125  27000				   -	       endif		; !MULTIBUTTON
    126  27000				   -
    127  27000				   -MEGA_INIT
    128  27000				   -	       .byte	%00110000,%00000011
    129  27000				   -MEGA_NEXT
    130  27000				   -	       .byte	%00100000,%00000010
    131  27000				   -
    132  27000				   -mega7800handlerend
    133  27000				   -	       echo	"  (mega7800 module is using ",[(mega7800handlerend-mega7800handlerstart)]d," bytes of rom)"
    134  27000				   -
    135  27000					       endif		; MEGA7800SUPPORT
    136  27000
------- FILE c:\Users\seany\Documents\irata\0087_Irata.78b.asm
   2396  27000					       endif
   2397  27000					       ifnconst	included.tracker.asm
------- FILE tracker.asm LEVEL 2 PASS 3
      0  27000					       include	tracker.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000
      4  27000				   -	       ifconst	MUSICTRACKER
      5  27000				   -
      6  27000				   -trackerstart
      7  27000				   -
      8  27000				   -			; ** songtempo lists how many 256ths of a frame a 16th note lasts
      9  27000				   -			; ** the player operates on a 16th note grid.
     10  27000				   -
     11  27000				   -servicesongover
     12  27000				   -	       rts
     13  27000				   -servicesong
     14  27000				   -	       ifconst	PAUSESILENT
     15  27000				   -	       lda	pausestate
     16  27000				   -	       bne	servicesongover
     17  27000				   -	       endif
     18  27000				   -	       lda	songtempo
     19  27000				   -	       beq	servicesongover	; ** if song is off/paused then return
     20  27000				   -servicesongcontinue
     21  27000				   -	       lda	sfxschedulelock
     22  27000				   -	       sta	sfxschedulemissed
     23  27000				   -	       bne	servicesongover
     24  27000				   -	       lda	songtempo
     25  27000				   -	       clc
     26  27000				   -	       adc	songtick	; add songtempo to songtick until it rolls over
     27  27000				   -	       sta	songtick	; this is how we break away from 50/60Hz timing.
     28  27000				   -	       bcc	servicesongover
     29  27000				   -			; ** if we're here a new 16th note has passed
     30  27000				   -			; ** check if a new note is due on any of the 4 channels
     31  27000				   -servicesongredo
     32  27000				   -	       ldx	#3
     33  27000				   -checkchannelloop
     34  27000				   -	       dec	songchannel1busywait,x
     35  27000				   -	       bpl	carryoncheckingchannel
     36  27000				   -	       txa
     37  27000				   -	       pha		; save X for the loop
     38  27000				   -	       jsr	processsongdata
     39  27000				   -	       pla		; restore X for the loop
     40  27000				   -	       tax
     41  27000				   -carryoncheckingchannel
     42  27000				   -	       dex
     43  27000				   -	       bpl	checkchannelloop
     44  27000				   -	       lda	inactivechannelcount
     45  27000				   -	       cmp	#15
     46  27000				   -	       bne	skipstopsong
     47  27000				   -	       lda	songloops
     48  27000				   -	       bne	doasongloop
     49  27000				   -			;lda #0
     50  27000				   -	       sta	songtempo	; all channels are done. stop the song
     51  27000				   -	       rts
     52  27000				   -doasongloop
     53  27000				   -	       bmi	skipsongloopadjust
     54  27000				   -	       dec	songloops
     55  27000				   -skipsongloopadjust
     56  27000				   -	       jsr	setsongchannels
     57  27000				   -	       jmp	servicesongredo
     58  27000				   -skipstopsong
     59  27000				   -	       rts
     60  27000				   -
     61  27000				   -processsongdata
     62  27000				   -			; channel needs processing
     63  27000				   -			; X=channel #
     64  27000				   -
     65  27000				   -	       txa
     66  27000				   -	       clc
     67  27000				   -	       adc	songchannel1stackdepth,x	; stack depth value will be 0, 4, or 8
     68  27000				   -	       tay
     69  27000				   -
     70  27000				   -
     71  27000				   -			; ** indirect x is cumbersome with mult-byte commands.
     72  27000				   -			; ** setup a pointer to the song data for indirect y addressing.
     73  27000				   -	       lda	songchannel1layer1lo,y
     74  27000				   -	       sta	songdatalo
     75  27000				   -	       lda	songchannel1layer1hi,y
     76  27000				   -	       sta	songdatahi
     77  27000				   -			;ora songdatalo
     78  27000				   -	       bne	channelhasdata
     79  27000				   -			;channel data is pointing at $0000
     80  27000				   -	       lda	#$7F
     81  27000				   -	       sta	songchannel1busywait,x	; skip a bunch of notes
     82  27000				   -setchannelcountbits
     83  27000				   -	       lda	channel2bits,x
     84  27000				   -	       ora	inactivechannelcount
     85  27000				   -	       sta	inactivechannelcount
     86  27000				   -	       rts
     87  27000				   -channelhasdata
     88  27000				   -
     89  27000				   -	       sty	songstackindex
     90  27000				   -	       ldy	#0
     91  27000				   -	       lda	(songdatalo),y	; ** load in the next byte of song data, so we can decode it
     92  27000				   -	       cmp	#$ff
     93  27000				   -	       bne	carryoncheckingdatatype	; ** $ff=pattern end marker
     94  27000				   -	       jmp	handlechannelEOD
     95  27000				   -
     96  27000				   -carryoncheckingdatatype
     97  27000				   -	       and	#$F0
     98  27000				   -	       cmp	#$C0
     99  27000				   -	       beq	handlechannelrest	; 0000XXXX=rest
    100  27000				   -	       cmp	#$F0
    101  27000				   -	       beq	handlemultibytecommand
    102  27000				   -	       cmp	#$D0
    103  27000				   -	       beq	handlesemiup
    104  27000				   -	       cmp	#$E0
    105  27000				   -	       beq	handlesemidown
    106  27000				   -handlenotedata
    107  27000				   -			; ** TODO: note playing is a terrible choice for fall-through
    108  27000				   -
    109  27000				   -			; ** its simple note data, prepare arguments for schedulesfx
    110  27000				   -
    111  27000				   -			; ** set the note length
    112  27000				   -	       lda	(songdatalo),y
    113  27000				   -	       and	#$0F
    114  27000				   -	       sta	songchannel1busywait,x
    115  27000				   -
    116  27000				   -			; ** load the instrument
    117  27000				   -	       lda	songchannel1instrumentlo,x
    118  27000				   -	       sta	sfxinstrumentlo
    119  27000				   -	       lda	songchannel1instrumenthi,x
    120  27000				   -	       sta	sfxinstrumenthi
    121  27000				   -
    122  27000				   -			; ** get the note, and transpose
    123  27000				   -	       lda	(songdatalo),y
    124  27000				   -	       lsr
    125  27000				   -	       lsr
    126  27000				   -	       lsr
    127  27000				   -	       lsr
    128  27000				   -	       clc
    129  27000				   -	       adc	songchannel1transpose,x	; ** add it to the transpose index
    130  27000				   -			; ** its up the respective SFX scheduler to handle and save the note data
    131  27000				   -	       sta	sfxnoteindex
    132  27000				   -
    133  27000				   -	       lda	#0
    134  27000				   -	       sta	sfxpitchoffset
    135  27000				   -
    136  27000				   -	       jsr	schedulesfx
    137  27000				   -skipnoteschedule
    138  27000				   -	       jmp	advancethesongpointer1byte	; advance to the next data byte and exit
    139  27000				   -
    140  27000				   -handlechannelrest
    141  27000				   -			; ** set the note length
    142  27000				   -	       lda	(songdatalo),y
    143  27000				   -	       and	#$0F
    144  27000				   -	       sta	songchannel1busywait,x
    145  27000				   -	       jmp	advancethesongpointer1byte	; advance to the next data byte and exit
    146  27000				   -
    147  27000				   -handlesemiup
    148  27000				   -	       lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    149  27000				   -	       and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    150  27000				   -	       clc
    151  27000				   -handlesemidownentry
    152  27000				   -	       adc	songchannel1transpose,x	; ** add it to the transpose index
    153  27000				   -	       sta	songchannel1transpose,x
    154  27000				   -	       jsr	advancethesongpointer1byte
    155  27000				   -	       jmp	processsongdata	; semi doesn't have note length, so process the next data byte...
    156  27000				   -
    157  27000				   -handlesemidown
    158  27000				   -	       lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    159  27000				   -	       and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    160  27000				   -	       eor	#$ff	; ** its easier if we negate it, and then add it instead.
    161  27000				   -	       sec
    162  27000				   -	       jmp	handlesemidownentry
    163  27000				   -
    164  27000				   -handlemultibytecommand
    165  27000				   -	       lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    166  27000				   -	       and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    167  27000				   -	       cmp	#$08	; ** load new instrument?
    168  27000				   -	       bne	nothandleinstrumentchange
    169  27000				   -handleinstrumentchange
    170  27000				   -	       iny
    171  27000				   -	       lda	(songdatalo),y
    172  27000				   -	       sta	songchannel1instrumentlo,x
    173  27000				   -	       iny
    174  27000				   -	       lda	(songdatalo),y
    175  27000				   -	       sta	songchannel1instrumenthi,x
    176  27000				   -	       lda	#3
    177  27000				   -	       jsr	advancethesongpointerNbytes	; advance 3 bytes
    178  27000				   -	       jmp	processsongdata
    179  27000				   -
    180  27000				   -nothandleinstrumentchange
    181  27000				   -	       cmp	#$09	; ** absolute tempo change?
    182  27000				   -	       bne	nothandletempochange
    183  27000				   -	       lda	#0
    184  27000				   -	       sta	songtempo
    185  27000				   -handlerelativetempochange
    186  27000				   -	       iny
    187  27000				   -	       lda	(songdatalo),y
    188  27000				   -	       clc
    189  27000				   -	       adc	songtempo
    190  27000				   -	       sta	songtempo
    191  27000				   -	       lda	#2
    192  27000				   -	       jsr	advancethesongpointerNbytes	; advance 2 bytes
    193  27000				   -	       jmp	processsongdata
    194  27000				   -
    195  27000				   -nothandletempochange
    196  27000				   -	       cmp	#$0A	; ** relative tempo change?:
    197  27000				   -	       beq	handlerelativetempochange
    198  27000				   -	       cmp	#$0B	; ** octave/semi change?
    199  27000				   -	       beq	handleoctavesemichange
    200  27000				   -handlepatterndata
    201  27000				   -			; ** if we're here its a pattern/loop "subroutine"
    202  27000				   -			; ** move the channel's "stack" pointer and populate the new stack level
    203  27000				   -
    204  27000				   -	       lda	#4
    205  27000				   -	       clc
    206  27000				   -	       adc	songchannel1stackdepth,x
    207  27000				   -	       sta	songchannel1stackdepth,x	; stack depth value will be 0, 4, or 8
    208  27000				   -
    209  27000				   -	       stx	inttemp6	; about to invalidate x. save it.
    210  27000				   -	       lda	songstackindex
    211  27000				   -	       adc	#4
    212  27000				   -	       tax
    213  27000				   -
    214  27000				   -	       lda	(songdatalo),y
    215  27000				   -	       and	#$7
    216  27000				   -	       sta	songchannel1layer1loops,x
    217  27000				   -	       iny
    218  27000				   -	       lda	(songdatalo),y
    219  27000				   -	       sta	songchannel1layer1lo,x
    220  27000				   -	       iny
    221  27000				   -	       lda	(songdatalo),y
    222  27000				   -	       sta	songchannel1layer1hi,x
    223  27000				   -
    224  27000				   -	       ldx	inttemp6	; restore x with the channel #
    225  27000				   -
    226  27000				   -			; ** advance will operate on the old stack level, since we didn't store the updated songstackindex...
    227  27000				   -	       lda	#3
    228  27000				   -	       jsr	advancethesongpointerNbytes	; advance 3 bytes
    229  27000				   -
    230  27000				   -			; ** ...but the new stack level will be correctly picked up when we process the next byte.
    231  27000				   -	       jmp	processsongdata
    232  27000				   -
    233  27000				   -handlechannelEOD
    234  27000				   -			; ** check if there are loops remaining on the pattern
    235  27000				   -	       stx	inttemp6
    236  27000				   -	       ldx	songstackindex
    237  27000				   -	       dec	songchannel1layer1loops,x
    238  27000				   -	       bmi	handlechannelEODnoloop
    239  27000				   -			; ** loops are remaining. set the pattern pointer to the pattern start, which is contained after the EOD
    240  27000				   -	       iny
    241  27000				   -	       lda	(songdatalo),y
    242  27000				   -	       sta	songchannel1layer1lo,x
    243  27000				   -	       iny
    244  27000				   -	       lda	(songdatalo),y
    245  27000				   -	       sta	songchannel1layer1hi,x
    246  27000				   -	       ldx	inttemp6
    247  27000				   -	       jmp	processsongdata	; EOD handling doesn't have note length, so process the next data byte...
    248  27000				   -
    249  27000				   -handlechannelEODnoloop
    250  27000				   -			; this pattern/loop is done playing. "pop" the stack
    251  27000				   -	       ldx	inttemp6
    252  27000				   -	       lda	songchannel1stackdepth,x
    253  27000				   -	       beq	handlerootchannelEOD
    254  27000				   -	       sec
    255  27000				   -	       sbc	#4
    256  27000				   -	       sta	songchannel1stackdepth,x
    257  27000				   -	       jmp	processsongdata	; EOD handling doesn't have note length, so process the next data byte...
    258  27000				   -
    259  27000				   -handlerootchannelEOD
    260  27000				   -			; this channel is done. point it to $ff data so we no longer process this channel.
    261  27000				   -	       lda	#0
    262  27000				   -	       sta	songchannel1layer1lo,x
    263  27000				   -	       sta	songchannel1layer1hi,x
    264  27000				   -	       sta	songchannel1busywait,x
    265  27000				   -	       jmp	setchannelcountbits
    266  27000				   -	       rts
    267  27000				   -
    268  27000				   -nothandlepatternchange
    269  27000				   -handleoctavesemichange
    270  27000				   -	       iny
    271  27000				   -	       lda	(songdatalo),y
    272  27000				   -	       sta	songchannel1transpose,x
    273  27000				   -	       lda	#2
    274  27000				   -	       jsr	advancethesongpointerNbytes	; advance 2 bytes
    275  27000				   -	       jmp	processsongdata
    276  27000				   -
    277  27000				   -advancethesongpointer1byte
    278  27000				   -	       txa
    279  27000				   -	       ldx	songstackindex
    280  27000				   -	       inc	songchannel1layer1lo,x
    281  27000				   -	       bne	skiphiadvancethesongpointer1byte
    282  27000				   -	       inc	songchannel1layer1hi,x
    283  27000				   -skiphiadvancethesongpointer1byte
    284  27000				   -	       tax
    285  27000				   -	       rts
    286  27000				   -
    287  27000				   -advancethesongpointerNbytes
    288  27000				   -			; entered with A=# of byte to advance
    289  27000				   -	       stx	inttemp6
    290  27000				   -	       ldx	songstackindex
    291  27000				   -	       clc
    292  27000				   -	       adc	songchannel1layer1lo,x
    293  27000				   -	       sta	songchannel1layer1lo,x
    294  27000				   -	       lda	#0
    295  27000				   -	       adc	songchannel1layer1hi,x
    296  27000				   -	       sta	songchannel1layer1hi,x
    297  27000				   -	       ldx	inttemp6
    298  27000				   -	       rts
    299  27000				   -
    300  27000				   -clearsongmemory
    301  27000				   -	       lda	#0
    302  27000				   -	       ldx	#(songchannel4instrumenthi-songchannel1layer1lo)
    303  27000				   -clearsongmemoryloop1
    304  27000				   -	       sta	songchannel1layer1lo,x
    305  27000				   -	       dex
    306  27000				   -	       bpl	clearsongmemoryloop1
    307  27000				   -
    308  27000				   -	       ldx	#(songchannel4stackdepth-songchannel1layer1loops)
    309  27000				   -clearsongmemoryloop2
    310  27000				   -	       sta	songchannel1layer1loops,x
    311  27000				   -	       dex
    312  27000				   -	       bpl	clearsongmemoryloop2
    313  27000				   -
    314  27000				   -	       lda	#$ff
    315  27000				   -	       ldx	#3
    316  27000				   -clearsongmemoryloop3
    317  27000				   -	       sta	songchannel1busywait,x
    318  27000				   -	       dex
    319  27000				   -	       bpl	clearsongmemoryloop3
    320  27000				   -	       rts
    321  27000				   -
    322  27000				   -setsongchannels
    323  27000				   -	       jsr	clearsongmemory
    324  27000				   -	       ldy	#7
    325  27000				   -	       ldx	#3
    326  27000				   -setsongchannelsloop
    327  27000				   -	       lda	(songpointerlo),y
    328  27000				   -	       sta	songchannel1layer1hi,x
    329  27000				   -	       dey
    330  27000				   -	       lda	(songpointerlo),y
    331  27000				   -	       sta	songchannel1layer1lo,x
    332  27000				   -	       dex
    333  27000				   -	       dey
    334  27000				   -	       bpl	setsongchannelsloop
    335  27000				   -	       rts
    336  27000				   -
    337  27000				   -channel2bits
    338  27000				   -	       .byte	1,2,4,8
    339  27000				   -
    340  27000				   -tiatrackeroctavenotes
    341  27000				   -	       ifconst	BUZZBASS
    342  27000				   -LOWC       =	15
    343  27000				   -	       else
    344  27000				   -LOWC       =	14
    345  27000				   -	       endif
    346  27000				   -			; ****** ELECTRONIC (0 to 11)
    347  27000				   -	       .byte	LOWC,20	; c0	 16.1Hz
    348  27000				   -	       .byte	LOWC,18	; c#0
    349  27000				   -	       .byte	LOWC,17	; d0
    350  27000				   -	       .byte	LOWC,16	; d#0
    351  27000				   -	       .byte	LOWC,15	; e0
    352  27000				   -	       .byte	LOWC,14	; f0  (very off)
    353  27000				   -	       .byte	LOWC,14	; f#0
    354  27000				   -	       .byte	LOWC,13	; g0
    355  27000				   -	       .byte	LOWC,12	; g#0
    356  27000				   -	       .byte	LOWC,11	; a0
    357  27000				   -	       .byte	LOWC,11	; a#0 (very off)
    358  27000				   -	       .byte	LOWC,10	; b0	 30.7Hz
    359  27000				   -
    360  27000				   -			; ****** SLIGHTLY BUZZY (12 to 23)
    361  27000				   -	       .byte	6,30	; c1	 32.7Hz
    362  27000				   -	       .byte	6,28	; c#1
    363  27000				   -	       .byte	6,27	; d1
    364  27000				   -	       .byte	6,25	; d#1
    365  27000				   -	       .byte	6,24	; e1
    366  27000				   -	       .byte	6,22	; f1
    367  27000				   -	       .byte	6,21	; f#1
    368  27000				   -	       .byte	6,20	; g1
    369  27000				   -	       .byte	6,18	; g#1
    370  27000				   -	       .byte	6,17	; a1
    371  27000				   -	       .byte	6,16	; a#1
    372  27000				   -	       .byte	6,15	; b1	 63.4Hz
    373  27000				   -
    374  27000				   -			; ****** BUZZY (24 to 39)
    375  27000				   -	       .byte	1,31	; c2	 65.5
    376  27000				   -	       .byte	1,30	; c#2	 67.6
    377  27000				   -	       .byte	1,27	; d2	 72.3
    378  27000				   -	       .byte	1,26	; d#2	 77.6
    379  27000				   -	       .byte	1,24	; e2
    380  27000				   -	       .byte	1,23	; f2
    381  27000				   -	       .byte	1,22	; f#2
    382  27000				   -	       .byte	1,20	; g2
    383  27000				   -	       .byte	1,19	; g#2
    384  27000				   -	       .byte	1,18	; a2
    385  27000				   -	       .byte	1,17	; a#2
    386  27000				   -	       .byte	1,16	; b2
    387  27000				   -	       .byte	1,15	; c3	126.8Hz
    388  27000				   -	       .byte	1,14	; c#3
    389  27000				   -	       .byte	1,13	; d3	149.7Hz
    390  27000				   -	       .byte	1,12	; d#3	161.2Hz (very off)
    391  27000				   -			; ****** PURE (40 to 71) - best key is A3 Major
    392  27000				   -	       .byte	12,31	; e3	163.8Hz
    393  27000				   -	       .byte	12,29	; f3
    394  27000				   -	       .byte	12,28	; f#3
    395  27000				   -	       .byte	12,26	; g3
    396  27000				   -	       .byte	12,24	; g#3
    397  27000				   -	       .byte	12,23	; a3  songs in key of A benefit from Perceptual Tuning
    398  27000				   -	       .byte	12,22	; a#3
    399  27000				   -	       .byte	12,20	; b3
    400  27000				   -	       .byte	12,19	; c4  (middle C)
    401  27000				   -	       .byte	12,18	; c#4
    402  27000				   -	       .byte	12,17	; d4
    403  27000				   -	       .byte	12,16	; d#4
    404  27000				   -	       .byte	12,15	; e4
    405  27000				   -	       .byte	12,14	; f4
    406  27000				   -	       .byte	12,13	; f#4
    407  27000				   -	       .byte	12,12	; g4  (very off)
    408  27000				   -	       .byte	12,12	; g#4
    409  27000				   -	       .byte	12,11	; a4
    410  27000				   -	       .byte	12,10	; a#4
    411  27000				   -	       .byte	4,31	; b4
    412  27000				   -	       .byte	4,29	; c5
    413  27000				   -	       .byte	4,28	; c#5
    414  27000				   -	       .byte	4,26	; d5
    415  27000				   -	       .byte	4,24	; d#5
    416  27000				   -	       .byte	4,23	; e5
    417  27000				   -	       .byte	4,22	; f5
    418  27000				   -	       .byte	4,20	; f#5
    419  27000				   -	       .byte	4,19	; g5
    420  27000				   -	       .byte	4,18	; g#5
    421  27000				   -	       .byte	4,17	; a5
    422  27000				   -	       .byte	4,16	; a#5
    423  27000				   -	       .byte	4,15	; b5
    424  27000				   -
    425  27000				   -			; ****** TUNED WIND (72 to 83)
    426  27000				   -	       .byte	8,30	; c
    427  27000				   -	       .byte	8,28	; c#
    428  27000				   -	       .byte	8,27	; d
    429  27000				   -	       .byte	8,25	; d#
    430  27000				   -	       .byte	8,24	; e
    431  27000				   -	       .byte	8,22	; f
    432  27000				   -	       .byte	8,21	; f#
    433  27000				   -	       .byte	8,20	; g
    434  27000				   -	       .byte	8,18	; g#
    435  27000				   -	       .byte	8,17	; a
    436  27000				   -	       .byte	8,16	; a#
    437  27000				   -	       .byte	8,15	; b
    438  27000				   -
    439  27000				   -	       include	"tiadrumkit.asm"
    440  27000				   -
    441  27000				   -trackerend
    442  27000				   -
    443  27000				   -	       echo	"  (tracker module is using ",[(trackerend-trackerstart)]d," bytes)"
    444  27000				   -
    445  27000					       endif		;MUSICTRACKER
------- FILE c:\Users\seany\Documents\irata\0087_Irata.78b.asm
   2399  27000					       endif
   2400  27000					       ifnconst	included.hiscore.asm
------- FILE hiscore.asm LEVEL 2 PASS 3
      0  27000					       include	hiscore.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000				   -	       ifconst	HSSUPPORT
      4  27000				   -
      5  27000				   -	       ifconst	BANKSETROM
      6  27000				   -	       ifconst	isBANKSETBANK
      7  27000				   -HSCHARSHERE =	1
      8  27000				   -	       endif
      9  27000				   -	       else		; !BANKSETROM so embed the character strings
     10  27000				   -HSCHARSHERE =	1
     11  27000				   -	       endif
     12  27000				   -
     13  27000				   -	       ifnconst	isBANKSETBANK
     14  27000				   -hiscorestart
     15  27000				   -
     16  27000				   -detectatarivoxeeprom
     17  27000				   -hiscoremodulestart
     18  27000				   -			; do a test to see if atarivox eeprom can be accessed, and save results
     19  27000				   -	       jsr	AVoxDetect
     20  27000				   -	       eor	#$ff	; invert for easy 7800basic if...then logic
     21  27000				   -	       sta	avoxdetected
     22  27000				   -	       lda	#$0
     23  27000				   -	       sta	SWACNT
     24  27000				   -	       lda	avoxdetected
     25  27000				   -	       rts
     26  27000				   -
     27  27000				   -detecthsc
     28  27000				   -			; check for the HSC ROM signature...
     29  27000				   -	       lda	XCTRL1s
     30  27000				   -	       ora	#%00001100
     31  27000				   -	       sta	XCTRL1s
     32  27000				   -	       sta	XCTRL1
     33  27000				   -
     34  27000				   -	       lda	$3900
     35  27000				   -	       eor	#$C6
     36  27000				   -	       bne	detecthscfail
     37  27000				   -	       lda	$3904
     38  27000				   -	       eor	#$FE
     39  27000				   -	       bne	detecthscfail
     40  27000				   -
     41  27000				   -			; check if it's initialized...
     42  27000				   -	       ldy	#0
     43  27000				   -	       lda	#$ff
     44  27000				   -checkhscinit
     45  27000				   -	       and	$1000,y
     46  27000				   -	       dey
     47  27000				   -	       bne	checkhscinit
     48  27000				   -	       cmp	#$ff
     49  27000				   -	       beq	dominimalhscinit
     50  27000				   -			; Y is 0
     51  27000				   -	       lda	#0
     52  27000				   -checkhscinit2
     53  27000				   -	       ora	$1000,y
     54  27000				   -	       dey
     55  27000				   -	       bne	checkhscinit2
     56  27000				   -	       cmp	#0
     57  27000				   -	       bne	hscisalreadyinit
     58  27000				   -dominimalhscinit
     59  27000				   -			; if we're here, we need to do a minimal HSC init...
     60  27000				   -	       ldy	#$28
     61  27000				   -hscinitloop1
     62  27000				   -	       lda	hscheader,y
     63  27000				   -	       sta	$1000,y
     64  27000				   -	       dey
     65  27000				   -	       bpl	hscinitloop1
     66  27000				   -	       ldy	#$89
     67  27000				   -	       lda	#$7F
     68  27000				   -hscinitloop2
     69  27000				   -	       sta	$10B3,y
     70  27000				   -	       dey
     71  27000				   -	       cpy	#$ff
     72  27000				   -	       bne	hscinitloop2
     73  27000				   -hscisalreadyinit
     74  27000				   -	       lda	#$ff
     75  27000				   -	       rts
     76  27000				   -hscheader
     77  27000				   -	       .byte	$00,$00,$68,$83,$AA,$55,$9C,$FF,$07,$12,$02,$1F,$00,$00,$00,$00
     78  27000				   -	       .byte	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
     79  27000				   -	       .byte	$00,$00,$00,$00,$00,$00,$00,$00,$03
     80  27000				   -detecthscfail
     81  27000				   -	       lda	XCTRL1s
     82  27000				   -	       and	#%11110111
     83  27000				   -	       sta	XCTRL1s
     84  27000				   -	       lda	#0
     85  27000				   -	       rts
     86  27000				   -	       endif		; isBANKSETBANK
     87  27000				   -
     88  27000				   -	       ifnconst	hiscorefont
     89  27000				   -	       echo	""
     90  27000				   -	       echo	"WARNING: High score support is enabled, but the hiscorefont.png was"
     91  27000				   -	       echo	" NOT imported with incgraphic. The high score display code"
     92  27000				   -	       echo	" has been omitted from this build."
     93  27000				   -	       echo	""
     94  27000				   -	       else		; hiscorefont
     95  27000				   -	       ifnconst	isBANKSETBANK
     96  27000				   -hscdrawscreen
     97  27000				   -
     98  27000				   -			; we use 20 lines on a 24 line display
     99  27000				   -			; HSSCOREY to dynamically centers based on
    100  27000				   -			;HSSCOREY = 0
    101  27000				   -HSSCOREY   =	((WZONECOUNT*WZONEHEIGHT/8)-22)/2
    102  27000				   -HSCURSORY  =	((HSSCOREY/(WZONEHEIGHT/8))*WZONEHEIGHT)
    103  27000				   -
    104  27000				   -	       ifconst	HSSCORESIZE
    105  27000				   -SCORESIZE  =	HSSCORESIZE
    106  27000				   -	       else
    107  27000				   -SCORESIZE  =	6
    108  27000				   -	       endif
    109  27000				   -
    110  27000				   -	       jsr	mutetia
    111  27000				   -	       ifconst	pokeysupport
    112  27000				   -	       jsr	mutepokey
    113  27000				   -	       endif		; pokeysupport
    114  27000				   -
    115  27000				   -			;save shadow registers for later return...
    116  27000				   -	       lda	sCTRL
    117  27000				   -	       pha
    118  27000				   -	       lda	sCHARBASE
    119  27000				   -	       pha
    120  27000				   -
    121  27000				   -	       jsr	blacken320colors
    122  27000				   -	       jsr	drawoverwait
    123  27000				   -	       jsr	drawwait
    124  27000				   -	       jsr	hiscorecleardlmem
    125  27000				   -	       jsr	clearscreen
    126  27000				   -
    127  27000				   -	       lda	#$60
    128  27000				   -	       sta	charactermode
    129  27000				   -
    130  27000				   -			;set the character base to the HSC font
    131  27000				   -	       lda	#>hiscorefont
    132  27000				   -	       sta	CHARBASE
    133  27000				   -	       sta	sCHARBASE
    134  27000				   -	       lda	#%01000011	;Enable DMA, mode=320A
    135  27000				   -	       sta	CTRL
    136  27000				   -	       sta	sCTRL
    137  27000				   -
    138  27000				   -	       lda	#60
    139  27000				   -	       sta	hsjoydebounce
    140  27000				   -
    141  27000				   -	       lda	#0
    142  27000				   -	       sta	hscursorx
    143  27000				   -	       sta	framecounter
    144  27000				   -
    145  27000				   -	       ifnconst	HSCOLORCHASESTART
    146  27000				   -	       lda	#$8D	; default is blue. why not?
    147  27000				   -	       else
    148  27000				   -	       lda	#HSCOLORCHASESTART
    149  27000				   -	       endif
    150  27000				   -	       sta	hscolorchaseindex
    151  27000				   -	       lda	#$0F
    152  27000				   -	       sta	P0C2	; base text is white
    153  27000				   -	       jsr	hschasecolors
    154  27000				   -
    155  27000				   -			; ** plot all of the initials
    156  27000				   -	       lda	#<HSRAMInitials
    157  27000				   -	       sta	temp1	; charmaplo
    158  27000				   -	       lda	#>HSRAMInitials
    159  27000				   -	       sta	temp2	; charmaphi
    160  27000				   -	       lda	#32+29	; palette=0-29 | 32-(width=3)
    161  27000				   -	       sta	temp3	; palette/width
    162  27000				   -	       lda	#104
    163  27000				   -	       sta	temp4	; X
    164  27000				   -	       lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    165  27000				   -	       sta	temp5	; Y
    166  27000				   -plothsinitialsloop
    167  27000				   -	       jsr	plotcharacters
    168  27000				   -	       clc
    169  27000				   -	       lda	temp3
    170  27000				   -	       adc	#32
    171  27000				   -	       sta	temp3
    172  27000				   -	       inc	temp5
    173  27000				   -	       if	WZONEHEIGHT = 8
    174  27000				   -	       inc	temp5
    175  27000				   -	       endif
    176  27000				   -	       clc
    177  27000				   -	       lda	#3
    178  27000				   -	       adc	temp1
    179  27000				   -	       sta	temp1
    180  27000				   -	       cmp	#(<(HSRAMInitials+15))
    181  27000				   -	       bcc	plothsinitialsloop
    182  27000				   -
    183  27000				   -	       ifconst	HSGAMENAMELEN
    184  27000				   -			;plot the game name...
    185  27000				   -	       lda	#<HSGAMENAMEtable
    186  27000				   -	       sta	temp1	; charmaplo
    187  27000				   -	       lda	#>HSGAMENAMEtable
    188  27000				   -	       sta	temp2	; charmaphi
    189  27000				   -	       lda	#(32-HSGAMENAMELEN)	; palette=0*29 | 32-(width=3)
    190  27000				   -	       sta	temp3	; palette/width
    191  27000				   -	       lda	#(80-(HSGAMENAMELEN*2))
    192  27000				   -	       sta	temp4	; X
    193  27000				   -	       lda	#((HSSCOREY+0)/(WZONEHEIGHT/8))
    194  27000				   -	       sta	temp5	; Y
    195  27000				   -	       jsr	plotcharacters
    196  27000				   -	       endif		; HSGAMENAMELEN
    197  27000				   -
    198  27000				   -			;plot "difficulty"...
    199  27000				   -	       ldy	gamedifficulty
    200  27000				   -	       ifnconst	HSNOLEVELNAMES
    201  27000				   -	       lda	highscoredifficultytextlo,y
    202  27000				   -	       sta	temp1
    203  27000				   -	       lda	highscoredifficultytexthi,y
    204  27000				   -	       sta	temp2
    205  27000				   -	       sec
    206  27000				   -	       lda	#32
    207  27000				   -	       sbc	highscoredifficultytextlen,y
    208  27000				   -	       sta	temp3	; palette/width
    209  27000				   -	       sec
    210  27000				   -	       lda	#40
    211  27000				   -	       sbc	highscoredifficultytextlen,y
    212  27000				   -	       asl
    213  27000				   -	       sta	temp4	; X
    214  27000				   -	       else
    215  27000				   -	       lda	#<HSHIGHSCOREStext
    216  27000				   -	       sta	temp1	; charmaplo
    217  27000				   -	       lda	#>HSHIGHSCOREStext
    218  27000				   -	       sta	temp2	; charmaphi
    219  27000				   -	       lda	#(32-11)	; palette=0*29 | 32-(width=3)
    220  27000				   -	       sta	temp3	; palette/width
    221  27000				   -	       lda	#(80-(11*2))
    222  27000				   -	       sta	temp4	; X
    223  27000				   -	       endif		; HSNOLEVELNAMES
    224  27000				   -
    225  27000				   -	       lda	#((HSSCOREY+2)/(WZONEHEIGHT/8))
    226  27000				   -	       sta	temp5	; Y
    227  27000				   -	       jsr	plotcharacters
    228  27000				   -	       ldy	hsdisplaymode	; 0=attact mode, 1=player eval, 2=player 1 eval, 3=player 2 player eval, 4=player 2 player evel (joy1)
    229  27000				   -	       bne	carronwithscoreevaluation
    230  27000				   -	       jmp	donoscoreevaluation
    231  27000				   -carronwithscoreevaluation
    232  27000				   -	       dey
    233  27000				   -	       lda	highscorelabeltextlo,y
    234  27000				   -	       sta	temp1
    235  27000				   -	       lda	highscorelabeltexthi,y
    236  27000				   -	       sta	temp2
    237  27000				   -	       sec
    238  27000				   -	       lda	#(32-15)	; palette=0*29 | 32-(width=3)
    239  27000				   -	       sta	temp3	; palette/width
    240  27000				   -	       lda	highscorelabeladjust1,y
    241  27000				   -	       sta	temp4	; X
    242  27000				   -	       lda	#((HSSCOREY+18)/(WZONEHEIGHT/8))
    243  27000				   -	       sta	temp5	; Y
    244  27000				   -	       jsr	plotcharacters
    245  27000				   -
    246  27000				   -	       ldy	hsdisplaymode	; 0=attact mode, 1=player eval, 2=player 1 eval, 3=player 2 player eval, 4=player 2 player evel (joy1)
    247  27000				   -	       dey
    248  27000				   -			;plot the current player score...
    249  27000				   -	       lda	#(32-SCORESIZE)	; palette=0*32
    250  27000				   -	       sta	temp3	; palette/width
    251  27000				   -	       lda	highscorelabeladjust2,y
    252  27000				   -	       sta	temp4	; X
    253  27000				   -	       lda	#((HSSCOREY+18)/(WZONEHEIGHT/8))
    254  27000				   -	       sta	temp5	; Y
    255  27000				   -
    256  27000				   -	       lda	scorevarlo,y
    257  27000				   -	       sta	temp7	; score variable lo
    258  27000				   -	       lda	scorevarhi,y
    259  27000				   -	       sta	temp8	; score variable hi
    260  27000				   -
    261  27000				   -	       lda	#(hiscorefont_mode | %01100000)	; charactermode
    262  27000				   -	       sta	temp9
    263  27000				   -
    264  27000				   -	       lda	#<(hiscorefont+33)	; +33 to get to '0' character
    265  27000				   -	       sta	temp1	; charmaplo
    266  27000				   -	       lda	#>(hiscorefont+33)
    267  27000				   -	       sta	temp2	; charmaphi
    268  27000				   -	       lda	#SCORESIZE
    269  27000				   -	       sta	temp6
    270  27000				   -	       ifnconst	DOUBLEWIDE
    271  27000				   -	       jsr	plotvalue
    272  27000				   -	       else
    273  27000				   -	       jsr	plotvaluedw
    274  27000				   -	       endif
    275  27000				   -
    276  27000				   -USED_PLOTVALUE =	1	; ensure that plotvalue gets compiled in
    277  27000				   -
    278  27000				   -	       ifconst	HSGAMERANKS
    279  27000				   -
    280  27000				   -	       ldx	#$ff	; start at 0 after the inx...
    281  27000				   -comparescore2rankloop
    282  27000				   -	       inx
    283  27000				   -	       ldy	#0
    284  27000				   -	       lda	rankvalue_0,x
    285  27000				   -	       cmp	(temp7),y
    286  27000				   -	       bcc	score2rankloopdone
    287  27000				   -	       bne	comparescore2rankloop
    288  27000				   -	       iny
    289  27000				   -	       lda	rankvalue_1,x
    290  27000				   -	       cmp	(temp7),y
    291  27000				   -	       bcc	score2rankloopdone
    292  27000				   -	       bne	comparescore2rankloop
    293  27000				   -	       iny
    294  27000				   -	       lda	(temp7),y
    295  27000				   -	       cmp	rankvalue_2,x
    296  27000				   -	       bcs	score2rankloopdone
    297  27000				   -	       jmp	comparescore2rankloop
    298  27000				   -score2rankloopdone
    299  27000				   -	       stx	hsnewscorerank
    300  27000				   -
    301  27000				   -	       lda	ranklabello,x
    302  27000				   -	       sta	temp1
    303  27000				   -	       lda	ranklabelhi,x
    304  27000				   -	       sta	temp2
    305  27000				   -	       sec
    306  27000				   -	       lda	#32	; palette=0*29 | 32-(width=3)
    307  27000				   -	       sbc	ranklabellengths,x
    308  27000				   -	       sta	temp3	; palette/width
    309  27000				   -	       sec
    310  27000				   -	       lda	#(40+6)
    311  27000				   -	       sbc	ranklabellengths,x
    312  27000				   -	       asl
    313  27000				   -	       sta	temp4	; X
    314  27000				   -	       lda	#((HSSCOREY+20)/(WZONEHEIGHT/8))
    315  27000				   -	       sta	temp5	; Y
    316  27000				   -	       jsr	plotcharacters
    317  27000				   -
    318  27000				   -	       ldx	hsnewscorerank
    319  27000				   -
    320  27000				   -	       lda	#<highscoreranklabel
    321  27000				   -	       sta	temp1
    322  27000				   -	       lda	#>highscoreranklabel
    323  27000				   -	       sta	temp2
    324  27000				   -
    325  27000				   -	       lda	#(32-5)	; palette=0*29 | 32-(width=3)
    326  27000				   -	       sta	temp3	; palette/width
    327  27000				   -	       lda	#(40-6)
    328  27000				   -	       sec
    329  27000				   -	       sbc	ranklabellengths,x
    330  27000				   -	       asl
    331  27000				   -	       sta	temp4	; X
    332  27000				   -	       lda	#((HSSCOREY+20)/(WZONEHEIGHT/8))
    333  27000				   -	       sta	temp5	; Y
    334  27000				   -	       jsr	plotcharacters
    335  27000				   -	       endif		; HSGAMERANKS
    336  27000				   -
    337  27000				   -
    338  27000				   -			; ** which line did this player beat?
    339  27000				   -	       lda	#$ff
    340  27000				   -	       sta	hsnewscoreline
    341  27000				   -	       ldx	#$fd
    342  27000				   -comparescoreadd2x
    343  27000				   -	       inx
    344  27000				   -comparescoreadd1x
    345  27000				   -	       inx
    346  27000				   -comparescore2lineloop
    347  27000				   -	       inc	hsnewscoreline
    348  27000				   -	       inx		; initialrun, x=0
    349  27000				   -	       cpx	#15
    350  27000				   -	       beq	nohighscoreforyou
    351  27000				   -	       ldy	#0
    352  27000				   -	       lda	HSRAMScores,x
    353  27000				   -	       cmp	(temp7),y	; first score digit
    354  27000				   -	       bcc	score2lineloopdonedel1x
    355  27000				   -	       bne	comparescoreadd2x
    356  27000				   -	       iny
    357  27000				   -	       inx
    358  27000				   -	       lda	HSRAMScores,x
    359  27000				   -	       cmp	(temp7),y
    360  27000				   -	       bcc	score2lineloopdonedel2x
    361  27000				   -	       bne	comparescoreadd1x
    362  27000				   -	       iny
    363  27000				   -	       inx
    364  27000				   -	       lda	(temp7),y
    365  27000				   -	       cmp	HSRAMScores,x
    366  27000				   -	       bcs	score2lineloopdonedel3x
    367  27000				   -	       jmp	comparescore2lineloop
    368  27000				   -nohighscoreforyou
    369  27000				   -	       lda	#$ff
    370  27000				   -	       sta	hsnewscoreline
    371  27000				   -	       sta	countdownseconds
    372  27000				   -	       jmp	donoscoreevaluation
    373  27000				   -score2lineloopdonedel3x
    374  27000				   -	       dex
    375  27000				   -score2lineloopdonedel2x
    376  27000				   -	       dex
    377  27000				   -score2lineloopdonedel1x
    378  27000				   -	       dex
    379  27000				   -
    380  27000				   -			; 0 1 2
    381  27000				   -			; 3 4 5
    382  27000				   -			; 6 7 8
    383  27000				   -			; 9 0 1
    384  27000				   -			; 2 3 4
    385  27000				   -
    386  27000				   -	       stx	temp9
    387  27000				   -	       cpx	#11
    388  27000				   -	       beq	postsortscoresuploop
    389  27000				   -	       ldx	#11
    390  27000				   -sortscoresuploop
    391  27000				   -	       lda	HSRAMScores,x
    392  27000				   -	       sta	HSRAMScores+3,x
    393  27000				   -	       lda	HSRAMInitials,x
    394  27000				   -	       sta	HSRAMInitials+3,x
    395  27000				   -	       dex
    396  27000				   -	       cpx	temp9
    397  27000				   -	       bne	sortscoresuploop
    398  27000				   -postsortscoresuploop
    399  27000				   -
    400  27000				   -			;stick the score and cleared initials in the slot...
    401  27000				   -	       inx
    402  27000				   -	       ldy	#0
    403  27000				   -	       sty	hsinitialhold
    404  27000				   -	       lda	(temp7),y
    405  27000				   -	       sta	HSRAMScores,x
    406  27000				   -	       iny
    407  27000				   -	       lda	(temp7),y
    408  27000				   -	       sta	HSRAMScores+1,x
    409  27000				   -	       iny
    410  27000				   -	       lda	(temp7),y
    411  27000				   -	       sta	HSRAMScores+2,x
    412  27000				   -	       lda	#0
    413  27000				   -	       sta	HSRAMInitials,x
    414  27000				   -	       lda	#29
    415  27000				   -	       sta	HSRAMInitials+1,x
    416  27000				   -	       sta	HSRAMInitials+2,x
    417  27000				   -
    418  27000				   -	       stx	hsinitialpos
    419  27000				   -
    420  27000				   -	       ifconst	vox_highscore
    421  27000				   -	       lda	<#vox_highscore
    422  27000				   -	       sta	speech_addr
    423  27000				   -	       lda	>#vox_highscore
    424  27000				   -	       sta	speech_addr+1
    425  27000				   -	       endif		; vox_highscore
    426  27000				   -	       ifconst	sfx_highscore
    427  27000				   -	       lda	<#sfx_highscore
    428  27000				   -	       sta	temp1
    429  27000				   -	       lda	>#sfx_highscore
    430  27000				   -	       sta	temp2
    431  27000				   -	       lda	#0
    432  27000				   -	       sta	temp3
    433  27000				   -	       jsr	schedulesfx
    434  27000				   -	       endif		; sfx_highscore
    435  27000				   -	       ifconst	songdatastart_song_highscore
    436  27000				   -	       lda	#<songchanneltable_song_highscore
    437  27000				   -	       sta	songpointerlo
    438  27000				   -	       lda	#>songchanneltable_song_highscore
    439  27000				   -	       sta	songpointerhi
    440  27000				   -	       lda	#73
    441  27000				   -	       sta	songtempo
    442  27000				   -	       jsr	setsongchannels
    443  27000				   -	       endif		; songdatastart_song_highscore
    444  27000				   -
    445  27000				   -
    446  27000				   -donoscoreevaluation
    447  27000				   -
    448  27000				   -	       lda	#(32+(32-SCORESIZE))	; palette=0*32 | 32-(width=6)
    449  27000				   -	       sta	temp3	; palette/width
    450  27000				   -	       lda	#(72+(4*(6-SCORESIZE)))
    451  27000				   -	       sta	temp4	; X
    452  27000				   -	       lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    453  27000				   -	       sta	temp5	; Y
    454  27000				   -	       lda	#<HSRAMScores
    455  27000				   -	       sta	temp7	; score variable lo
    456  27000				   -	       lda	#>HSRAMScores
    457  27000				   -	       sta	temp8	; score variable hi
    458  27000				   -	       lda	#(hiscorefont_mode | %01100000)	; charactermode
    459  27000				   -	       sta	temp9
    460  27000				   -plothsscoresloop
    461  27000				   -	       lda	#<(hiscorefont+33)	; +33 to get to '0' character
    462  27000				   -	       sta	temp1	; charmaplo
    463  27000				   -	       lda	#>(hiscorefont+33)
    464  27000				   -	       sta	temp2	; charmaphi
    465  27000				   -	       lda	#6
    466  27000				   -	       sta	temp6
    467  27000				   -	       ifnconst	DOUBLEWIDE
    468  27000				   -	       jsr	plotvalue
    469  27000				   -	       else
    470  27000				   -	       jsr	plotvaluedw
    471  27000				   -	       endif
    472  27000				   -	       clc
    473  27000				   -	       lda	temp3
    474  27000				   -	       adc	#32
    475  27000				   -	       sta	temp3
    476  27000				   -	       inc	temp5
    477  27000				   -	       if	WZONEHEIGHT = 8
    478  27000				   -	       inc	temp5
    479  27000				   -	       endif
    480  27000				   -	       clc
    481  27000				   -	       lda	#3
    482  27000				   -	       adc	temp7
    483  27000				   -	       sta	temp7
    484  27000				   -	       cmp	#(<(HSRAMScores+15))
    485  27000				   -	       bcc	plothsscoresloop
    486  27000				   -plothsindex
    487  27000				   -	       lda	#32+31	; palette=0*32 | 32-(width=1)
    488  27000				   -	       sta	temp3	; palette/width
    489  27000				   -	       lda	#44
    490  27000				   -	       sta	temp4	; X
    491  27000				   -	       lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    492  27000				   -	       sta	temp5	; Y
    493  27000				   -	       lda	#<hsgameslotnumbers
    494  27000				   -	       sta	temp7	; score variable lo
    495  27000				   -	       lda	#>hsgameslotnumbers
    496  27000				   -	       sta	temp8	; score variable hi
    497  27000				   -	       lda	#(hiscorefont_mode | %01100000)	; charactermode
    498  27000				   -	       sta	temp9
    499  27000				   -plothsindexloop
    500  27000				   -	       lda	#<(hiscorefont+33)
    501  27000				   -	       sta	temp1	; charmaplo
    502  27000				   -	       lda	#>(hiscorefont+33)
    503  27000				   -	       sta	temp2	; charmaphi
    504  27000				   -	       lda	#1
    505  27000				   -	       sta	temp6	; number of characters
    506  27000				   -	       ifnconst	DOUBLEWIDE
    507  27000				   -	       jsr	plotvalue
    508  27000				   -	       else
    509  27000				   -	       jsr	plotvaluedw
    510  27000				   -	       endif
    511  27000				   -	       clc
    512  27000				   -	       lda	temp3
    513  27000				   -	       adc	#32
    514  27000				   -	       sta	temp3
    515  27000				   -	       inc	temp5
    516  27000				   -	       if	WZONEHEIGHT = 8
    517  27000				   -	       inc	temp5
    518  27000				   -	       endif
    519  27000				   -	       inc	temp7
    520  27000				   -	       lda	temp7
    521  27000				   -	       cmp	#(<(hsgameslotnumbers+5))
    522  27000				   -	       bcc	plothsindexloop
    523  27000				   -
    524  27000				   -	       jsr	savescreen
    525  27000				   -	       ifnconst	HSSECONDS
    526  27000				   -	       lda	#6
    527  27000				   -	       else
    528  27000				   -	       lda	#HSSECONDS
    529  27000				   -	       endif
    530  27000				   -
    531  27000				   -	       sta	countdownseconds
    532  27000				   -
    533  27000				   -keepdisplayinghs
    534  27000				   -	       jsr	restorescreen
    535  27000				   -
    536  27000				   -	       jsr	setuphsinpt1
    537  27000				   -
    538  27000				   -	       lda	hsnewscoreline
    539  27000				   -	       bpl	carryonkeepdisplayinghs
    540  27000				   -	       jmp	skipenterscorecontrol
    541  27000				   -carryonkeepdisplayinghs
    542  27000				   -
    543  27000				   -
    544  27000				   -	       ifnconst	HSSECONDS
    545  27000				   -	       lda	#6
    546  27000				   -	       else
    547  27000				   -	       lda	#HSSECONDS
    548  27000				   -	       endif
    549  27000				   -
    550  27000				   -	       sta	countdownseconds
    551  27000				   -
    552  27000				   -			;plot the "cursor" initial sprite...
    553  27000				   -	       lda	hsinitialhold
    554  27000				   -
    555  27000				   -	       sta	temp1
    556  27000				   -	       lda	#>(hiscorefont+32)
    557  27000				   -	       sta	temp2
    558  27000				   -	       lda	#31	; palette=0*32 | 32-(width=1)
    559  27000				   -	       sta	temp3	; palette/width
    560  27000				   -	       lda	hscursorx
    561  27000				   -	       asl
    562  27000				   -	       asl
    563  27000				   -	       clc
    564  27000				   -	       adc	#104
    565  27000				   -	       sta	temp4	; X
    566  27000				   -	       lda	hsnewscoreline
    567  27000				   -	       asl
    568  27000				   -	       asl
    569  27000				   -	       asl
    570  27000				   -	       asl
    571  27000				   -	       adc	#((3*16)+HSCURSORY)
    572  27000				   -	       sta	temp5	; Y
    573  27000				   -	       lda	#%01000000
    574  27000				   -	       sta	temp6
    575  27000				   -	       jsr	plotsprite
    576  27000				   -
    577  27000				   -	       ldx	hscursorx
    578  27000				   -	       ldy	hsdisplaymode
    579  27000				   -	       ifnconst	.HSup
    580  27000				   -	       lda	sSWCHA
    581  27000				   -	       cpy	#3
    582  27000				   -	       bne	hsskipadjustjoystick1
    583  27000				   -	       asl
    584  27000				   -	       asl
    585  27000				   -	       asl
    586  27000				   -	       asl
    587  27000				   -hsskipadjustjoystick1
    588  27000				   -	       sta	hsswcha
    589  27000				   -	       else		; there are user-defined routines!
    590  27000				   -	       jsr	.HSdown
    591  27000				   -	       lda	hsreturn	; b0
    592  27000				   -	       asl
    593  27000				   -	       pha
    594  27000				   -	       jsr	.HSup
    595  27000				   -	       pla
    596  27000				   -	       ora	hsreturn
    597  27000				   -	       asl
    598  27000				   -	       asl
    599  27000				   -	       asl
    600  27000				   -	       asl
    601  27000				   -	       eor	#$FF
    602  27000				   -	       sta	hsswcha
    603  27000				   -	       endif		; .HSup
    604  27000				   -	       lda	SWCHB
    605  27000				   -	       and	#%00000010
    606  27000				   -	       bne	hsskipselectswitch
    607  27000				   -	       lda	#%00010000
    608  27000				   -	       sta	hsswcha
    609  27000				   -	       bne	hsdodebouncecheck
    610  27000				   -hsskipselectswitch
    611  27000				   -	       lda	hsswcha
    612  27000				   -	       and	#%00110000
    613  27000				   -	       cmp	#%00110000
    614  27000				   -	       beq	hsjoystickskipped
    615  27000				   -hsdodebouncecheck
    616  27000				   -	       lda	hsjoydebounce
    617  27000				   -	       beq	hsdontdebounce
    618  27000				   -	       jmp	hspostjoystick
    619  27000				   -hsdontdebounce
    620  27000				   -	       ldx	#1	; small tick sound
    621  27000				   -	       jsr	playhssfx
    622  27000				   -	       lda	hsswcha
    623  27000				   -	       and	#%00110000
    624  27000				   -	       ldx	hscursorx
    625  27000				   -	       cmp	#%00100000	; check down
    626  27000				   -	       bne	hsjoycheckup
    627  27000				   -	       ldy	hsinitialhold
    628  27000				   -	       cpx	#0
    629  27000				   -	       bne	skipavoid31_1
    630  27000				   -	       cpy	#0	; if we're about to change to the <- char (#31) then double-decrement to skip over it
    631  27000				   -	       bne	skipavoid31_1
    632  27000				   -	       dey
    633  27000				   -skipavoid31_1
    634  27000				   -	       dey
    635  27000				   -	       jmp	hssetdebounce
    636  27000				   -hsjoycheckup
    637  27000				   -	       cmp	#%00010000	; check up
    638  27000				   -	       bne	hsjoystickskipped
    639  27000				   -	       ldy	hsinitialhold
    640  27000				   -	       cpx	#0
    641  27000				   -	       bne	skipavoid31_2
    642  27000				   -	       cpy	#30	; if we're about to change to the <- char (#31) then double-increment to skip over it
    643  27000				   -	       bne	skipavoid31_2
    644  27000				   -	       iny
    645  27000				   -skipavoid31_2
    646  27000				   -	       iny
    647  27000				   -hssetdebounce
    648  27000				   -	       tya
    649  27000				   -	       and	#31
    650  27000				   -	       sta	hsinitialhold
    651  27000				   -	       lda	#15
    652  27000				   -	       sta	hsjoydebounce
    653  27000				   -	       bne	hspostjoystick
    654  27000				   -hsjoystickskipped
    655  27000				   -			; check the fire button only when the stick isn't engaged
    656  27000				   -	       lda	hsinpt1
    657  27000				   -	       bpl	hsbuttonskipped
    658  27000				   -	       lda	hsjoydebounce
    659  27000				   -	       bne	hspostjoystick
    660  27000				   -hsfiredontdebounce
    661  27000				   -	       lda	hsinitialhold
    662  27000				   -	       cmp	#31
    663  27000				   -	       beq	hsmovecursorback
    664  27000				   -	       inc	hscursorx
    665  27000				   -	       inc	hsinitialpos
    666  27000				   -	       lda	hscursorx
    667  27000				   -	       cmp	#3
    668  27000				   -	       bne	skiphsentryisdone
    669  27000				   -	       lda	#0
    670  27000				   -	       sta	framecounter
    671  27000				   -	       lda	#$ff
    672  27000				   -	       sta	hsnewscoreline
    673  27000				   -	       dec	hsinitialpos
    674  27000				   -	       bne	skiphsentryisdone
    675  27000				   -hsmovecursorback
    676  27000				   -	       lda	hscursorx
    677  27000				   -	       beq	skiphsmovecursorback
    678  27000				   -	       lda	#29
    679  27000				   -	       ldx	hsinitialpos
    680  27000				   -	       sta	HSRAMInitials,x
    681  27000				   -	       dec	hsinitialpos
    682  27000				   -	       dec	hscursorx
    683  27000				   -	       dex
    684  27000				   -	       lda	HSRAMInitials,x
    685  27000				   -	       sta	hsinitialhold
    686  27000				   -skiphsmovecursorback
    687  27000				   -skiphsentryisdone
    688  27000				   -	       ldx	#0
    689  27000				   -	       jsr	playhssfx
    690  27000				   -	       lda	#20
    691  27000				   -	       sta	hsjoydebounce
    692  27000				   -	       bne	hspostjoystick
    693  27000				   -
    694  27000				   -hsbuttonskipped
    695  27000				   -	       lda	#0
    696  27000				   -	       sta	hsjoydebounce
    697  27000				   -hspostjoystick
    698  27000				   -
    699  27000				   -	       ldx	hsinitialpos
    700  27000				   -	       lda	hsinitialhold
    701  27000				   -	       sta	HSRAMInitials,x
    702  27000				   -
    703  27000				   -	       jmp	skiphschasecolors
    704  27000				   -
    705  27000				   -skipenterscorecontrol
    706  27000				   -	       jsr	hschasecolors
    707  27000				   -	       jsr	setuphsinpt1
    708  27000				   -	       lda	hsjoydebounce
    709  27000				   -	       bne	skiphschasecolors
    710  27000				   -	       lda	hsinpt1
    711  27000				   -	       bmi	returnfromhs
    712  27000				   -skiphschasecolors
    713  27000				   -
    714  27000				   -	       jsr	drawscreen
    715  27000				   -
    716  27000				   -	       lda	countdownseconds
    717  27000				   -	       beq	returnfromhs
    718  27000				   -	       jmp	keepdisplayinghs
    719  27000				   -returnfromhs
    720  27000				   -
    721  27000				   -	       ifconst	songdatastart_song_highscore
    722  27000				   -	       lda	hsdisplaymode
    723  27000				   -	       beq	skipclearHSCsong
    724  27000				   -	       lda	#0
    725  27000				   -	       sta	songtempo
    726  27000				   -skipclearHSCsong
    727  27000				   -	       endif
    728  27000				   -	       jsr	drawwait
    729  27000				   -	       jsr	clearscreen
    730  27000				   -	       lda	#0
    731  27000				   -	       ldy	#7
    732  27000				   -	       jsr	blacken320colors
    733  27000				   -			;lda ssCHARBASE
    734  27000				   -	       pla
    735  27000				   -	       sta	sCHARBASE
    736  27000				   -			;lda ssCTRL
    737  27000				   -	       pla
    738  27000				   -	       sta	sCTRL
    739  27000				   -	       rts
    740  27000				   -
    741  27000				   -setuphsinpt1
    742  27000				   -	       lda	#$ff
    743  27000				   -	       sta	hsinpt1
    744  27000				   -	       lda	hsjoydebounce
    745  27000				   -	       beq	skipdebounceadjust
    746  27000				   -	       dec	hsjoydebounce
    747  27000				   -	       bne	skipstorefirebuttonstatus
    748  27000				   -skipdebounceadjust
    749  27000				   -	       lda	SWCHB
    750  27000				   -	       and	#%00000001
    751  27000				   -	       bne	hscheckresetover
    752  27000				   -	       lda	#$ff
    753  27000				   -	       sta	hsinpt1
    754  27000				   -	       rts
    755  27000				   -hscheckresetover
    756  27000				   -	       ifnconst	.HSselect
    757  27000				   -	       ldx	hsdisplaymode
    758  27000				   -	       cpx	#3
    759  27000				   -	       bne	hsskipadjustjoyfire1
    760  27000				   -	       lda	sINPT3
    761  27000				   -	       jmp	hsskipadjustjoyfire1done
    762  27000				   -hsskipadjustjoyfire1
    763  27000				   -	       lda	sINPT1
    764  27000				   -hsskipadjustjoyfire1done
    765  27000				   -	       sta	hsinpt1
    766  27000				   -	       else		; there are user-defined routines!
    767  27000				   -	       jsr	.HSselect
    768  27000				   -	       lda	hsreturn
    769  27000				   -	       ror		; carry
    770  27000				   -	       ror		; b7
    771  27000				   -	       sta	hsinpt1
    772  27000				   -	       endif		; .HSselect
    773  27000				   -skipstorefirebuttonstatus
    774  27000				   -	       rts
    775  27000				   -
    776  27000				   -blacken320colors
    777  27000				   -	       ldy	#7
    778  27000				   -blacken320colorsloop
    779  27000				   -	       sta	P0C2,y
    780  27000				   -	       dey
    781  27000				   -	       bpl	blacken320colorsloop
    782  27000				   -	       rts
    783  27000				   -
    784  27000				   -hschasecolors
    785  27000				   -	       lda	framecounter
    786  27000				   -	       and	#3
    787  27000				   -	       bne	hschasecolorsreturn
    788  27000				   -	       inc	hscolorchaseindex
    789  27000				   -	       lda	hscolorchaseindex
    790  27000				   -
    791  27000				   -	       sta	P5C2
    792  27000				   -	       sbc	#$02
    793  27000				   -	       sta	P4C2
    794  27000				   -	       sbc	#$02
    795  27000				   -	       sta	P3C2
    796  27000				   -	       sbc	#$02
    797  27000				   -	       sta	P2C2
    798  27000				   -	       sbc	#$02
    799  27000				   -	       sta	P1C2
    800  27000				   -hschasecolorsreturn
    801  27000				   -	       rts
    802  27000				   -
    803  27000				   -playhssfx
    804  27000				   -	       lda	hssfx_lo,x
    805  27000				   -	       sta	temp1
    806  27000				   -	       lda	hssfx_hi,x
    807  27000				   -	       sta	temp2
    808  27000				   -	       lda	#0
    809  27000				   -	       sta	temp3
    810  27000				   -	       jmp	schedulesfx
    811  27000				   -
    812  27000				   -hssfx_lo
    813  27000				   -	       .byte	<sfx_hsletterpositionchange, <sfx_hslettertick
    814  27000				   -hssfx_hi
    815  27000				   -	       .byte	>sfx_hsletterpositionchange, >sfx_hslettertick
    816  27000				   -
    817  27000				   -sfx_hsletterpositionchange
    818  27000				   -	       .byte	$10,$18,$00
    819  27000				   -	       .byte	$02,$06,$08
    820  27000				   -	       .byte	$02,$06,$04
    821  27000				   -	       .byte	$00,$00,$00
    822  27000				   -sfx_hslettertick
    823  27000				   -	       .byte	$10,$18,$00
    824  27000				   -	       .byte	$00,$00,$0a
    825  27000				   -	       .byte	$00,$00,$00
    826  27000				   -
    827  27000				   -highscorelabeladjust1
    828  27000				   -	       .byte	(80-(14*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2))
    829  27000				   -highscorelabeladjust2
    830  27000				   -	       .byte	(80+(14*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2))
    831  27000				   -
    832  27000				   -scorevarlo
    833  27000				   -	       .byte	<(score0+((6-SCORESIZE)/2)),<(score0+((6-SCORESIZE)/2)),<(score1+((6-SCORESIZE)/2)),<(score1+((6-SCORESIZE)/2))
    834  27000				   -scorevarhi
    835  27000				   -	       .byte	>(score0+((6-SCORESIZE)/2)),>(score0+((6-SCORESIZE)/2)),>(score1+((6-SCORESIZE)/2)),>(score1+((6-SCORESIZE)/2))
    836  27000				   -
    837  27000				   -	       endif		; !isBANKSETBANK
    838  27000				   -
    839  27000				   -	       ifnconst	HSNOLEVELNAMES
    840  27000				   -	       ifnconst	isBANKSETBANK
    841  27000				   -highscoredifficultytextlo
    842  27000				   -	       .byte	<easylevelname, <mediumlevelname, <hardlevelname, <expertlevelname
    843  27000				   -highscoredifficultytexthi
    844  27000				   -	       .byte	>easylevelname, >mediumlevelname, >hardlevelname, >expertlevelname
    845  27000				   -	       endif		; !isBANKSETBANK
    846  27000				   -
    847  27000				   -	       ifnconst	HSCUSTOMLEVELNAMES
    848  27000				   -	       ifnconst	isBANKSETBANK
    849  27000				   -highscoredifficultytextlen
    850  27000				   -	       .byte	22, 30, 26, 24
    851  27000				   -	       endif		; !isBANKSETBANK
    852  27000				   -
    853  27000				   -	       ifconst	HSCHARSHERE
    854  27000				   -
    855  27000				   -easylevelname
    856  27000				   -	       .byte	$04,$00,$12,$18,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    857  27000				   -mediumlevelname
    858  27000				   -	       .byte	$08,$0d,$13,$04,$11,$0c,$04,$03,$08,$00,$13,$04,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    859  27000				   -hardlevelname
    860  27000				   -	       .byte	$00,$03,$15,$00,$0d,$02,$04,$03,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    861  27000				   -expertlevelname
    862  27000				   -	       .byte	$04,$17,$0f,$04,$11,$13,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    863  27000				   -	       endif		; HSCHARSHERE
    864  27000				   -	       else		; HSCUSTOMLEVELNAMES
    865  27000				   -	       include	"7800hsgamediffnames.asm"
    866  27000				   -	       endif		; HSCUSTOMLEVELNAMES
    867  27000				   -	       else		; HSNOLEVELNAMES
    868  27000				   -	       ifconst	HSCHARSHERE
    869  27000				   -HSHIGHSCOREStext
    870  27000				   -	       .byte	$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    871  27000				   -	       endif		; HSCHARSHERE
    872  27000				   -	       endif		; HSNOLEVELNAMES
    873  27000				   -
    874  27000				   -	       ifnconst	isBANKSETBANK
    875  27000				   -highscorelabeltextlo
    876  27000				   -	       .byte	<player0label, <player1label, <player2label, <player2label
    877  27000				   -highscorelabeltexthi
    878  27000				   -	       .byte	>player0label, >player1label, >player2label, >player2label
    879  27000				   -	       endif		; !isBANKSETBANK
    880  27000				   -
    881  27000				   -	       ifconst	HSCHARSHERE
    882  27000				   -player0label
    883  27000				   -	       .byte	$0f,$0b,$00,$18,$04,$11,$1d,$12,$02,$0e,$11,$04,$1a,$1d,$1d
    884  27000				   -
    885  27000				   -player1label
    886  27000				   -	       .byte	$0f,$0b,$00,$18,$04,$11,$1d,$22,$1d,$12,$02,$0e,$11,$04,$1a
    887  27000				   -
    888  27000				   -player2label
    889  27000				   -	       .byte	$0f,$0b,$00,$18,$04,$11,$1d,$23,$1d,$12,$02,$0e,$11,$04,$1a
    890  27000				   -	       endif		; HSCHARSHERE
    891  27000				   -
    892  27000				   -
    893  27000				   -	       ifconst	HSGAMENAMELEN
    894  27000				   -	       ifconst	HSCHARSHERE
    895  27000				   -HSGAMENAMEtable
    896  27000				   -	       include	"7800hsgamename.asm"
    897  27000				   -	       endif		; HSCHARSHERE
    898  27000				   -	       endif		; HSGAMENAMELEN
    899  27000				   -	       ifconst	HSGAMERANKS
    900  27000				   -	       include	"7800hsgameranks.asm"
    901  27000				   -	       ifconst	HSCHARSHERE
    902  27000				   -highscoreranklabel
    903  27000				   -	       .byte	$11,$00,$0d,$0a,$1a
    904  27000				   -	       endif		; HSCHARSHERE
    905  27000				   -	       endif		; HSGAMERANKS
    906  27000				   -
    907  27000				   -			;ensure our table doesn't wrap a page...
    908  27000				   -	       if	((<*)>251)
    909  27000				   -	       align	256
    910  27000				   -	       endif
    911  27000				   -hsgameslotnumbers
    912  27000				   -	       .byte	33,34,35,36,37
    913  27000				   -	       endif		; hiscorefont
    914  27000				   -
    915  27000				   -
    916  27000				   -	       ifnconst	isBANKSETBANK
    917  27000				   -loaddifficultytable
    918  27000				   -	       lda	gamedifficulty
    919  27000				   -	       and	#$03	; ensure the user hasn't selected an invalid difficulty
    920  27000				   -	       sta	gamedifficulty
    921  27000				   -	       cmp	hsdifficulty	; check game difficulty is the same as RAM table
    922  27000				   -	       bne	loaddifficultytablecontinue1
    923  27000				   -	       rts		; this high score difficulty table is already loaded
    924  27000				   -loaddifficultytablecontinue1
    925  27000				   -	       lda	gamedifficulty
    926  27000				   -	       sta	hsdifficulty
    927  27000				   -			;we need to check the device for the table
    928  27000				   -	       lda	hsdevice
    929  27000				   -	       bne	loaddifficultytablecontinue2
    930  27000				   -			; there's no save device. clear out this table.
    931  27000				   -	       jmp	cleardifficultytablemem
    932  27000				   -loaddifficultytablecontinue2
    933  27000				   -	       lda	hsdevice
    934  27000				   -	       and	#1
    935  27000				   -	       beq	memdeviceisntHSC
    936  27000				   -	       jmp	loaddifficultytableHSC
    937  27000				   -memdeviceisntHSC
    938  27000				   -	       jmp	loaddifficultytableAVOX
    939  27000				   -
    940  27000				   -savedifficultytable
    941  27000				   -			;*** we need to check which device we should use...
    942  27000				   -	       lda	hsdevice
    943  27000				   -	       bne	savedifficultytablerealdevice
    944  27000				   -	       rts		; its a ram device
    945  27000				   -savedifficultytablerealdevice
    946  27000				   -	       and	#1
    947  27000				   -	       beq	savememdeviceisntHSC
    948  27000				   -	       jmp	savedifficultytableHSC
    949  27000				   -savememdeviceisntHSC
    950  27000				   -	       jmp	savedifficultytableAVOX
    951  27000				   -
    952  27000				   -savedifficultytableAVOX
    953  27000				   -			; the load call already setup the memory structure and atarivox memory location
    954  27000				   -	       jsr	savealoadedHSCtablecontinue
    955  27000				   -savedifficultytableAVOXskipconvert
    956  27000				   -	       lda	#HSIDHI
    957  27000				   -	       sta	eeprombuffer
    958  27000				   -	       lda	#HSIDLO
    959  27000				   -	       sta	eeprombuffer+1
    960  27000				   -	       lda	hsdifficulty
    961  27000				   -	       sta	eeprombuffer+2
    962  27000				   -	       lda	#32
    963  27000				   -	       jsr	AVoxWriteBytes
    964  27000				   -	       rts
    965  27000				   -
    966  27000				   -savedifficultytableHSC
    967  27000				   -			;we always load a table before reaching here, so the
    968  27000				   -			;memory structures from the load should be intact...
    969  27000				   -	       ldy	hsgameslot
    970  27000				   -	       bpl	savealoadedHSCtable
    971  27000				   -	       rts
    972  27000				   -savealoadedHSCtable
    973  27000				   -	       lda	HSCGameDifficulty,y
    974  27000				   -	       cmp	#$7F
    975  27000				   -	       bne	savealoadedHSCtablecontinue
    976  27000				   -	       jsr	initializeHSCtableentry
    977  27000				   -savealoadedHSCtablecontinue
    978  27000				   -			;convert our RAM table to HSC format and write it out...
    979  27000				   -	       ldy	#0
    980  27000				   -	       ldx	#0
    981  27000				   -savedifficultytableScores
    982  27000				   -
    983  27000				   -	       lda	HSRAMInitials,x
    984  27000				   -	       sta	temp3
    985  27000				   -	       lda	HSRAMInitials+1,x
    986  27000				   -	       sta	temp4
    987  27000				   -	       lda	HSRAMInitials+2,x
    988  27000				   -	       sta	temp5
    989  27000				   -	       jsr	encodeHSCInitials	; takes 3 byte initials from temp3,4,5 and stores 2 byte initials in temp1,2
    990  27000				   -
    991  27000				   -	       lda	temp1
    992  27000				   -	       sta	(HSGameTableLo),y
    993  27000				   -	       iny
    994  27000				   -	       lda	temp2
    995  27000				   -	       sta	(HSGameTableLo),y
    996  27000				   -	       iny
    997  27000				   -
    998  27000				   -	       lda	HSRAMScores,x
    999  27000				   -	       sta	(HSGameTableLo),y
   1000  27000				   -	       iny
   1001  27000				   -	       lda	HSRAMScores+1,x
   1002  27000				   -	       sta	(HSGameTableLo),y
   1003  27000				   -	       iny
   1004  27000				   -	       lda	HSRAMScores+2,x
   1005  27000				   -	       sta	(HSGameTableLo),y
   1006  27000				   -	       iny
   1007  27000				   -	       inx
   1008  27000				   -	       inx
   1009  27000				   -	       inx		; +3
   1010  27000				   -	       cpx	#15
   1011  27000				   -	       bne	savedifficultytableScores
   1012  27000				   -	       rts
   1013  27000				   -
   1014  27000				   -loaddifficultytableHSC
   1015  27000				   -			; routine responsible for loading the difficulty table from HSC
   1016  27000				   -	       jsr	findindexHSC
   1017  27000				   -	       ldy	hsgameslot
   1018  27000				   -	       lda	HSCGameDifficulty,y
   1019  27000				   -	       cmp	#$7F
   1020  27000				   -	       bne	loaddifficultytableHSCcontinue
   1021  27000				   -			;there was an error. use a new RAM table instead...
   1022  27000				   -	       jsr	initializeHSCtableentry
   1023  27000				   -	       jmp	cleardifficultytablemem
   1024  27000				   -loaddifficultytableHSCcontinue
   1025  27000				   -			; parse the data into the HS memory...
   1026  27000				   -	       ldy	#0
   1027  27000				   -	       ldx	#0
   1028  27000				   -loaddifficultytableScores
   1029  27000				   -	       lda	(HSGameTableLo),y
   1030  27000				   -	       sta	temp1
   1031  27000				   -	       iny
   1032  27000				   -	       lda	(HSGameTableLo),y
   1033  27000				   -	       sta	temp2
   1034  27000				   -	       jsr	decodeHSCInitials	; takes 2 byte initials from temp1,2 and stores 3 byte initials in temp3,4,5
   1035  27000				   -	       iny
   1036  27000				   -	       lda	(HSGameTableLo),y
   1037  27000				   -	       sta	HSRAMScores,x
   1038  27000				   -	       lda	temp3
   1039  27000				   -	       sta	HSRAMInitials,x
   1040  27000				   -	       inx
   1041  27000				   -	       iny
   1042  27000				   -	       lda	(HSGameTableLo),y
   1043  27000				   -	       sta	HSRAMScores,x
   1044  27000				   -	       lda	temp4
   1045  27000				   -	       sta	HSRAMInitials,x
   1046  27000				   -	       inx
   1047  27000				   -	       iny
   1048  27000				   -	       lda	(HSGameTableLo),y
   1049  27000				   -	       sta	HSRAMScores,x
   1050  27000				   -	       lda	temp5
   1051  27000				   -	       sta	HSRAMInitials,x
   1052  27000				   -	       inx
   1053  27000				   -	       iny
   1054  27000				   -	       cpx	#15
   1055  27000				   -	       bne	loaddifficultytableScores
   1056  27000				   -	       ldx	#14
   1057  27000				   -	       lda	#$ff
   1058  27000				   -validatescoresloop
   1059  27000				   -	       and	HSRAMScores,x
   1060  27000				   -	       dex
   1061  27000				   -	       bpl	validatescoresloop
   1062  27000				   -	       cmp	#$ff
   1063  27000				   -	       bne	exitloaddifficultytableScores
   1064  27000				   -	       jmp	cleardifficultytablemem
   1065  27000				   -exitloaddifficultytableScores
   1066  27000				   -	       rts
   1067  27000				   -
   1068  27000				   -decodeHSCInitials
   1069  27000				   -			; takes 2 byte initials from temp1,2 and stores 3 byte initials in temp3,4,5
   1070  27000				   -			; 2 bytes are packed in the form: 22211111 22_33333
   1071  27000				   -	       lda	#0
   1072  27000				   -	       sta	temp4
   1073  27000				   -	       lda	temp1
   1074  27000				   -	       and	#%00011111
   1075  27000				   -	       sta	temp3
   1076  27000				   -
   1077  27000				   -	       lda	temp2
   1078  27000				   -	       and	#%00011111
   1079  27000				   -	       sta	temp5
   1080  27000				   -
   1081  27000				   -	       lda	temp1
   1082  27000				   -	       asl
   1083  27000				   -	       rol	temp4
   1084  27000				   -	       asl
   1085  27000				   -	       rol	temp4
   1086  27000				   -	       asl
   1087  27000				   -	       rol	temp4
   1088  27000				   -	       lda	temp2
   1089  27000				   -	       asl
   1090  27000				   -	       rol	temp4
   1091  27000				   -	       asl
   1092  27000				   -	       rol	temp4
   1093  27000				   -	       rts
   1094  27000				   -encodeHSCInitials
   1095  27000				   -			; takes 3 byte initials from temp3,4,5 and stores 2 byte initials in temp1,2
   1096  27000				   -			; 2 bytes are packed in the form: 22211111 22_33333
   1097  27000				   -			; start with packing temp1...
   1098  27000				   -	       lda	temp4
   1099  27000				   -	       and	#%00011100
   1100  27000				   -	       sta	temp1
   1101  27000				   -	       asl	temp1
   1102  27000				   -	       asl	temp1
   1103  27000				   -	       asl	temp1
   1104  27000				   -	       lda	temp3
   1105  27000				   -	       and	#%00011111
   1106  27000				   -	       ora	temp1
   1107  27000				   -	       sta	temp1
   1108  27000				   -			; ...temp1 is now packed, on to temp2...
   1109  27000				   -	       lda	temp5
   1110  27000				   -	       asl
   1111  27000				   -	       asl
   1112  27000				   -	       ror	temp4
   1113  27000				   -	       ror
   1114  27000				   -	       ror	temp4
   1115  27000				   -	       ror
   1116  27000				   -	       sta	temp2
   1117  27000				   -	       rts
   1118  27000				   -
   1119  27000				   -findindexHSCerror
   1120  27000				   -			;the HSC is stuffed. return the bad slot flag
   1121  27000				   -	       ldy	#$ff
   1122  27000				   -	       sty	hsgameslot
   1123  27000				   -	       rts
   1124  27000				   -
   1125  27000				   -findindexHSC
   1126  27000				   -HSCGameID1 =	$1029
   1127  27000				   -HSCGameID2 =	$106E
   1128  27000				   -HSCGameDifficulty =	$10B3
   1129  27000				   -HSCGameIndex =	$10F8
   1130  27000				   -			; routine responsible for finding the game index from HSC
   1131  27000				   -			; call with x=0 to create a new table if none exist, call with x=$ff to avoid creating new tables
   1132  27000				   -			; the HS loading routine will use x=$ff, the HS saving routine will use x=0
   1133  27000				   -	       ldy	#69	; start +1 to account for the dey
   1134  27000				   -findindexHSCloop
   1135  27000				   -	       dey
   1136  27000				   -	       bmi	findindexHSCerror
   1137  27000				   -	       lda	HSCGameDifficulty,y
   1138  27000				   -	       cmp	#$7F
   1139  27000				   -	       beq	findourindexHSC
   1140  27000				   -	       cmp	gamedifficulty
   1141  27000				   -	       bne	findindexHSCloop
   1142  27000				   -	       lda	HSCGameID1,y
   1143  27000				   -	       cmp	#HSIDHI
   1144  27000				   -	       bne	findindexHSCloop
   1145  27000				   -	       lda	HSCGameID2,y
   1146  27000				   -	       cmp	#HSIDLO
   1147  27000				   -	       bne	findindexHSCloop
   1148  27000				   -findourindexHSC
   1149  27000				   -			; if we're here we found our index in the table
   1150  27000				   -			; or we found the first empty one
   1151  27000				   -	       sty	hsgameslot
   1152  27000				   -	       jsr	setupHSCGamepointer	; setup the pointer to the HS Table for this game...
   1153  27000				   -	       rts
   1154  27000				   -
   1155  27000				   -
   1156  27000				   -initializeHSCtableentry
   1157  27000				   -	       ldy	hsgameslot
   1158  27000				   -			; we need to make a new entry...
   1159  27000				   -	       lda	#HSIDHI
   1160  27000				   -	       sta	HSCGameID1,y
   1161  27000				   -	       lda	#HSIDLO
   1162  27000				   -	       sta	HSCGameID2,y
   1163  27000				   -	       lda	gamedifficulty
   1164  27000				   -	       sta	HSCGameDifficulty,y
   1165  27000				   -	       ldx	#0
   1166  27000				   -fixHSDGameDifficultylistLoop
   1167  27000				   -	       inx
   1168  27000				   -	       txa
   1169  27000				   -	       sta	HSCGameIndex,y
   1170  27000				   -	       iny
   1171  27000				   -	       cpy	#69
   1172  27000				   -	       bne	fixHSDGameDifficultylistLoop
   1173  27000				   -	       rts
   1174  27000				   -
   1175  27000				   -setupHSCGamepointer
   1176  27000				   -			; this routines sets (HSGameTableLo) pointing to the game's HS table
   1177  27000				   -	       lda	#$17
   1178  27000				   -	       sta	HSGameTableHi
   1179  27000				   -	       lda	#$FA
   1180  27000				   -	       sta	HSGameTableLo
   1181  27000				   -setupHSCGamepointerLoop
   1182  27000				   -	       lda	HSGameTableLo
   1183  27000				   -	       sec
   1184  27000				   -	       sbc	#25
   1185  27000				   -	       sta	HSGameTableLo
   1186  27000				   -	       lda	HSGameTableHi
   1187  27000				   -	       sbc	#0
   1188  27000				   -	       sta	HSGameTableHi
   1189  27000				   -	       iny
   1190  27000				   -	       cpy	#69
   1191  27000				   -	       bne	setupHSCGamepointerLoop
   1192  27000				   -	       rts
   1193  27000				   -
   1194  27000				   -loaddifficultytableAVOX
   1195  27000				   -			; routine responsible for loading the difficulty table from Avox
   1196  27000				   -			; we reuse HSC routines to format data to/from our Avox RAM buffer...
   1197  27000				   -	       lda	#>(eeprombuffer+3)
   1198  27000				   -	       sta	HSGameTableHi
   1199  27000				   -	       lda	#<(eeprombuffer+3)
   1200  27000				   -	       sta	HSGameTableLo
   1201  27000				   -
   1202  27000				   -			; the start location in EEPROM, subtract 32...
   1203  27000				   -	       lda	#$5F
   1204  27000				   -	       sta	HSVoxHi
   1205  27000				   -	       lda	#$E0
   1206  27000				   -	       sta	HSVoxLo
   1207  27000				   -	       lda	#0
   1208  27000				   -	       sta	temp1
   1209  27000				   -loaddifficultytableAVOXloop
   1210  27000				   -	       inc	temp1
   1211  27000				   -	       beq	loaddifficultytableAVOXfull
   1212  27000				   -	       clc
   1213  27000				   -	       lda	HSVoxLo
   1214  27000				   -	       adc	#32
   1215  27000				   -	       sta	HSVoxLo
   1216  27000				   -	       lda	HSVoxHi
   1217  27000				   -	       adc	#0
   1218  27000				   -	       sta	HSVoxHi
   1219  27000				   -	       lda	#3
   1220  27000				   -	       jsr	AVoxReadBytes	; read in 3 bytes, ID1,ID2,Difficulty
   1221  27000				   -	       lda	eeprombuffer
   1222  27000				   -	       cmp	#$FF
   1223  27000				   -	       beq	loaddifficultytableAVOXempty
   1224  27000				   -	       cmp	#HSIDHI
   1225  27000				   -	       bne	loaddifficultytableAVOXloop
   1226  27000				   -	       lda	eeprombuffer+1
   1227  27000				   -	       cmp	#HSIDLO
   1228  27000				   -	       bne	loaddifficultytableAVOXloop
   1229  27000				   -	       lda	eeprombuffer+2
   1230  27000				   -	       cmp	gamedifficulty
   1231  27000				   -	       bne	loaddifficultytableAVOXloop
   1232  27000				   -loaddifficultytableAVOXdone
   1233  27000				   -	       lda	#32
   1234  27000				   -	       jsr	AVoxReadBytes
   1235  27000				   -	       jsr	loaddifficultytableHSCcontinue
   1236  27000				   -	       rts
   1237  27000				   -loaddifficultytableAVOXfull
   1238  27000				   -	       lda	#0
   1239  27000				   -	       sta	hsdevice	; looks like all 255 entries are taken... disable it.
   1240  27000				   -loaddifficultytableAVOXempty
   1241  27000				   -	       jmp	cleardifficultytablemem
   1242  27000				   -	       rts
   1243  27000				   -
   1244  27000				   -cleardifficultytablemem
   1245  27000				   -	       ldy	#29
   1246  27000				   -	       lda	#0
   1247  27000				   -cleardifficultytablememloop
   1248  27000				   -	       sta	HSRAMTable,y
   1249  27000				   -	       dey
   1250  27000				   -	       bpl	cleardifficultytablememloop
   1251  27000				   -	       rts
   1252  27000				   -hiscoremoduleend
   1253  27000				   -
   1254  27000				   -hiscorecleardlmem
   1255  27000				   -	       ldx	#(WZONECOUNT-1)
   1256  27000				   -hiscorecleardlmemloop1
   1257  27000				   -	       lda	DLPOINTL,x
   1258  27000				   -	       sta	dlpnt
   1259  27000				   -	       lda	DLPOINTH,x
   1260  27000				   -	       sta	dlpnt+1
   1261  27000				   -	       lda	#0
   1262  27000				   -	       ldy	#17
   1263  27000				   -hiscorecleardlmemloop2
   1264  27000				   -	       sta	(dlpnt),y
   1265  27000				   -	       dey
   1266  27000				   -	       bpl	hiscorecleardlmemloop2
   1267  27000				   -	       dex
   1268  27000				   -	       bpl	hiscorecleardlmemloop1
   1269  27000				   -	       rts
   1270  27000				   -
   1271  27000				   -	       ifconst	DOUBLEWIDE
   1272  27000				   -plotvaluedw
   1273  27000				   -plotdigitcount =	temp6
   1274  27000				   -	       lda	#0
   1275  27000				   -	       tay
   1276  27000				   -	       ldx	valbufend
   1277  27000				   -
   1278  27000				   -	       lda	plotdigitcount
   1279  27000				   -	       and	#1
   1280  27000				   -	       beq	pvnibble2chardw
   1281  27000				   -	       lda	#0
   1282  27000				   -	       sta	VALBUFFER,x	; just in case we skip this digit
   1283  27000				   -	       beq	pvnibble2char_skipnibbledw
   1284  27000				   -
   1285  27000				   -pvnibble2chardw
   1286  27000				   -			; high nibble...
   1287  27000				   -	       lda	(temp7),y
   1288  27000				   -	       and	#$f0
   1289  27000				   -	       lsr
   1290  27000				   -	       lsr
   1291  27000				   -	       lsr
   1292  27000				   -	       lsr
   1293  27000				   -
   1294  27000				   -	       clc
   1295  27000				   -	       adc	temp1	; add the offset to character graphics to our value
   1296  27000				   -	       sta	VALBUFFER,x
   1297  27000				   -	       inx
   1298  27000				   -	       dec	plotdigitcount
   1299  27000				   -pvnibble2char_skipnibbledw
   1300  27000				   -			; low nibble...
   1301  27000				   -	       lda	(temp7),y
   1302  27000				   -	       and	#$0f
   1303  27000				   -	       clc
   1304  27000				   -	       adc	temp1	; add the offset to character graphics to our value
   1305  27000				   -	       sta	VALBUFFER,x
   1306  27000				   -	       inx
   1307  27000				   -	       iny
   1308  27000				   -
   1309  27000				   -	       dec	plotdigitcount
   1310  27000				   -	       bne	pvnibble2chardw
   1311  27000				   -			;point to the start of our valuebuffer
   1312  27000				   -	       clc
   1313  27000				   -	       lda	#<VALBUFFER
   1314  27000				   -	       adc	valbufend
   1315  27000				   -	       sta	temp1
   1316  27000				   -	       lda	#>VALBUFFER
   1317  27000				   -	       adc	#0
   1318  27000				   -	       sta	temp2
   1319  27000				   -
   1320  27000				   -			;advance valbufend to the end of our value buffer
   1321  27000				   -	       stx	valbufend
   1322  27000				   -
   1323  27000				   -	       ifnconst	plotvalueonscreen
   1324  27000				   -	       jmp	plotcharacters
   1325  27000				   -	       else
   1326  27000				   -	       jmp	plotcharacterslive
   1327  27000				   -	       endif
   1328  27000				   -	       endif		; DOUBLEWIDE
   1329  27000				   -
   1330  27000				   -hiscoreend
   1331  27000				   -	       echo	" (hiscore module is using ",[(hiscoreend-hiscorestart)]d," bytes)"
   1332  27000				   -	       endif		; !isBANKSETBANK
   1333  27000					       endif		; HSSUPPORT
   1334  27000
------- FILE c:\Users\seany\Documents\irata\0087_Irata.78b.asm
   2402  27000					       endif
   2403  27000					       ifnconst	included.fourbitfade.asm
------- FILE fourbitfade.asm LEVEL 2 PASS 3
      0  27000					       include	fourbitfade.asm
      1  27000							; ** fourbit fade, which is useful for audio levels and brightness fades
      2  27000							; ** input:  A=value to fade, fourbitfadevalue=global fade value
      3  27000							; **	      N.B. the global fade value is in the upper nibble. i.e. $Fx-0x
      4  27000							; ** output: A=faded value in lo nibble. orig top nibble is preserved,
      5  27000							; **	      other registers are preserved
      6  27000
      7  27000				   -	       ifconst	FOURBITFADE
      8  27000				   -
      9  27000				   -			; non-interrupt routine
     10  27000				   -
     11  27000				   -fourbitfade
     12  27000				   -	       sty	fourbittemp1
     13  27000				   -	       pha
     14  27000				   -	       and	#$0F
     15  27000				   -	       ora	fourbitfadevalue
     16  27000				   -	       tay
     17  27000				   -	       pla
     18  27000				   -	       and	#$F0
     19  27000				   -	       ora	fourbitfadelut,y
     20  27000				   -	       ldy	fourbittemp1	; restore Y
     21  27000				   -	       rts
     22  27000				   -
     23  27000				   -			; interrupt routine
     24  27000				   -
     25  27000				   -fourbitfadeint
     26  27000				   -	       sty	fourbittemp1int
     27  27000				   -	       pha
     28  27000				   -	       and	#$0F
     29  27000				   -	       ora	fourbitfadevalueint
     30  27000				   -	       tay
     31  27000				   -	       pla
     32  27000				   -	       and	#$F0
     33  27000				   -	       ora	fourbitfadelut,y
     34  27000				   -	       ldy	fourbittemp1int	; restore Y
     35  27000				   -	       rts
     36  27000				   -
     37  27000				   -fourbitfadelut
     38  27000				   -	       .byte	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
     39  27000				   -	       .byte	$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01
     40  27000				   -	       .byte	$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$02,$02,$02,$02,$02
     41  27000				   -	       .byte	$00,$00,$00,$00,$01,$01,$01,$01,$02,$02,$02,$02,$03,$03,$03,$03
     42  27000				   -	       .byte	$00,$00,$00,$00,$01,$01,$01,$02,$02,$02,$03,$03,$03,$04,$04,$04
     43  27000				   -	       .byte	$00,$00,$00,$01,$01,$01,$02,$02,$03,$03,$03,$04,$04,$04,$05,$05
     44  27000				   -	       .byte	$00,$00,$00,$01,$01,$02,$02,$03,$03,$03,$04,$04,$05,$05,$06,$06
     45  27000				   -	       .byte	$00,$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07
     46  27000				   -	       .byte	$00,$00,$01,$01,$02,$02,$03,$03,$04,$05,$05,$06,$06,$07,$07,$08
     47  27000				   -	       .byte	$00,$00,$01,$01,$02,$03,$03,$04,$05,$05,$06,$06,$07,$08,$08,$09
     48  27000				   -	       .byte	$00,$00,$01,$02,$02,$03,$04,$04,$05,$06,$06,$07,$08,$08,$09,$0a
     49  27000				   -	       .byte	$00,$00,$01,$02,$03,$03,$04,$05,$06,$06,$07,$08,$09,$09,$0a,$0b
     50  27000				   -	       .byte	$00,$00,$01,$02,$03,$04,$04,$05,$06,$07,$08,$08,$09,$0a,$0b,$0c
     51  27000				   -	       .byte	$00,$00,$01,$02,$03,$04,$05,$06,$07,$07,$08,$09,$0a,$0b,$0c,$0d
     52  27000				   -	       .byte	$00,$00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0a,$0b,$0c,$0d,$0e
     53  27000				   -	       .byte	$00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0a,$0b,$0c,$0d,$0e,$0f
     54  27000				   -
     55  27000				   -fourbitfadeend
     56  27000				   -
     57  27000				   -	       echo	"  (fourbitfade module is using ",[(fourbitfadeend-fourbitfade)]d," bytes of rom)"
     58  27000				   -
     59  27000					       endif
------- FILE c:\Users\seany\Documents\irata\0087_Irata.78b.asm
   2405  27000					       endif
   2406  27000					       ifnconst	included.plotsprite4.asm
------- FILE plotsprite4.asm LEVEL 2 PASS 3
      0  27000					       include	plotsprite4.asm
      1  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  27000
      3  27000				   -	       ifconst	PLOTSP4
      4  27000				   -
      5  27000				   -plotsprite4
      6  27000				   -	       ifnconst	NODRAWWAIT
      7  27000				   -	       ifconst	DOUBLEBUFFER
      8  27000				   -	       lda	doublebufferstate
      9  27000				   -	       bne	skipplotsprite4wait
     10  27000				   -	       endif		; DOUBLEBUFFER
     11  27000				   -	       ifconst	DEBUGWAITCOLOR
     12  27000				   -	       lda	#$41
     13  27000				   -	       sta	BACKGRND
     14  27000				   -	       endif
     15  27000				   -plotsprite4wait
     16  27000				   -	       lda	visibleover
     17  27000				   -	       bne	plotsprite4wait
     18  27000				   -skipplotsprite4wait
     19  27000				   -	       ifconst	DEBUGWAITCOLOR
     20  27000				   -	       lda	#$0
     21  27000				   -	       sta	BACKGRND
     22  27000				   -	       endif
     23  27000				   -	       endif
     24  27000				   -
     25  27000				   -			;arguments:
     26  27000				   -			; temp1=lo graphicdata
     27  27000				   -			; temp2=hi graphicdata
     28  27000				   -			; temp3=palette | width byte
     29  27000				   -			; temp4=x
     30  27000				   -			; temp5=y
     31  27000				   -
     32  27000				   -	       lda	temp5	;Y position
     33  27000				   -	       lsr		; 2 - Divide by 8 or 16
     34  27000				   -	       lsr		; 2
     35  27000				   -	       lsr		; 2
     36  27000				   -	       if	WZONEHEIGHT = 16
     37  27000				   -	       lsr		; 2
     38  27000				   -	       endif
     39  27000				   -
     40  27000				   -	       tax
     41  27000				   -
     42  27000				   -	       ifnconst	NOLIMITCHECKING
     43  27000				   -
     44  27000				   -			; the next block allows for vertical masking, and ensures we don't overwrite non-DL memory
     45  27000				   -
     46  27000				   -	       cmp	#WZONECOUNT
     47  27000				   -
     48  27000				   -	       bcc	continueplotsprite41	; the sprite is fully on-screen, so carry on...
     49  27000				   -			; otherwise, check to see if the bottom half is in zone 0...
     50  27000				   -
     51  27000				   -	       if	WZONEHEIGHT = 16
     52  27000				   -	       cmp	#15
     53  27000				   -	       else
     54  27000				   -	       cmp	#31
     55  27000				   -	       endif
     56  27000				   -
     57  27000				   -	       bne	exitplotsprite41
     58  27000				   -	       ldx	#0
     59  27000				   -	       jmp	continueplotsprite42
     60  27000				   -exitplotsprite41
     61  27000				   -	       rts
     62  27000				   -	       endif
     63  27000				   -
     64  27000				   -continueplotsprite41
     65  27000				   -
     66  27000				   -	       ifconst	VSCROLL
     67  27000				   -	       ldy	Xx3,x
     68  27000				   -	       lda	DLLMEM+11,y
     69  27000				   -	       else		; !VSCROLL
     70  27000				   -	       lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
     71  27000				   -	       endif		; !VSCROLL
     72  27000				   -	       ifconst	DOUBLEBUFFER
     73  27000				   -	       clc
     74  27000				   -	       adc	doublebufferdloffset
     75  27000				   -	       endif		; DOUBLEBUFFER
     76  27000				   -	       sta	dlpnt
     77  27000				   -	       ifconst	VSCROLL
     78  27000				   -	       lda	DLLMEM+10,y
     79  27000				   -	       else		; !VSCROLL
     80  27000				   -	       lda	DLPOINTH,x
     81  27000				   -	       endif		; !VSCROLL
     82  27000				   -	       ifconst	DOUBLEBUFFER
     83  27000				   -	       adc	#0
     84  27000				   -	       endif		; DOUBLEBUFFER
     85  27000				   -	       sta	dlpnt+1
     86  27000				   -
     87  27000				   -			;Create DL entry for upper part of sprite
     88  27000				   -
     89  27000				   -	       ldy	dlend,x	;Get the index to the end of this DL
     90  27000				   -
     91  27000				   -	       ifconst	CHECKOVERWRITE
     92  27000				   -	       cpy	#DLLASTOBJ
     93  27000				   -	       beq	checkcontinueplotsprite42
     94  27000				   -continueplotsprite41a
     95  27000				   -	       endif
     96  27000				   -
     97  27000				   -	       lda	temp1	; graphic data, lo byte
     98  27000				   -	       sta	(dlpnt),y	;Low byte of data address
     99  27000				   -
    100  27000				   -	       iny
    101  27000				   -	       lda	temp3	;palette|width
    102  27000				   -	       sta	(dlpnt),y
    103  27000				   -
    104  27000				   -	       iny
    105  27000				   -	       lda	temp5	;Y position
    106  27000				   -	       and	#(WZONEHEIGHT - 1)
    107  27000				   -	       cmp	#1	; clear carry if our sprite is just in this zone
    108  27000				   -	       ora	temp2	; graphic data, hi byte
    109  27000				   -	       sta	(dlpnt),y
    110  27000				   -
    111  27000				   -	       iny
    112  27000				   -	       lda	temp4	;Horizontal position
    113  27000				   -	       sta	(dlpnt),y
    114  27000				   -
    115  27000				   -	       iny
    116  27000				   -	       sty	dlend,x
    117  27000				   -
    118  27000				   -	       ifconst	ALWAYSTERMINATE
    119  27000				   -	       iny
    120  27000				   -	       lda	#0
    121  27000				   -	       sta	(dlpnt),y
    122  27000				   -	       endif
    123  27000				   -
    124  27000				   -checkcontinueplotsprite42
    125  27000				   -
    126  27000				   -	       bcc	doneSPDL4	;branch if the sprite was fully in the last zone
    127  27000				   -
    128  27000				   -			;Create DL entry for lower part of sprite
    129  27000				   -
    130  27000				   -	       inx		;Next region
    131  27000				   -
    132  27000				   -	       ifnconst	NOLIMITCHECKING
    133  27000				   -	       cpx	#WZONECOUNT
    134  27000				   -
    135  27000				   -	       bcc	continueplotsprite42	; the second half of the sprite is fully on-screen, so carry on...
    136  27000				   -	       rts
    137  27000				   -continueplotsprite42
    138  27000				   -	       endif
    139  27000				   -
    140  27000				   -	       ifconst	VSCROLL
    141  27000				   -	       ldy	Xx3,x
    142  27000				   -	       lda	DLLMEM+11,y
    143  27000				   -	       else		; !VSCROLL
    144  27000				   -	       lda	DLPOINTL,x	;Get pointer to next DL
    145  27000				   -	       endif		; !VSCROLL
    146  27000				   -	       ifconst	DOUBLEBUFFER
    147  27000				   -	       clc
    148  27000				   -	       adc	doublebufferdloffset
    149  27000				   -	       endif		; DOUBLEBUFFER
    150  27000				   -	       sta	dlpnt
    151  27000				   -	       ifconst	VSCROLL
    152  27000				   -	       lda	DLLMEM+10,y
    153  27000				   -	       else		; !VSCROLL
    154  27000				   -	       lda	DLPOINTH,x
    155  27000				   -	       endif		; !VSCROLL
    156  27000				   -	       ifconst	DOUBLEBUFFER
    157  27000				   -	       adc	#0
    158  27000				   -	       endif		; DOUBLEBUFFER
    159  27000				   -	       sta	dlpnt+1
    160  27000				   -	       ldy	dlend,x	;Get the index to the end of this DL
    161  27000				   -
    162  27000				   -	       ifconst	CHECKOVERWRITE
    163  27000				   -	       cpy	#DLLASTOBJ
    164  27000				   -	       bne	continueplotsprite42a
    165  27000				   -	       rts
    166  27000				   -continueplotsprite42a
    167  27000				   -	       endif
    168  27000				   -
    169  27000				   -	       lda	temp1	; graphic data, lo byte
    170  27000				   -	       sta	(dlpnt),y
    171  27000				   -
    172  27000				   -	       iny
    173  27000				   -	       lda	temp3	;palette|width
    174  27000				   -	       sta	(dlpnt),y
    175  27000				   -
    176  27000				   -	       iny
    177  27000				   -	       lda	temp5	;Y position
    178  27000				   -	       anc	#(WZONEHEIGHT - 1)	; undocumented. A=A&IMM, then move bit 7 into carry
    179  27000				   -	       ora	temp2	; graphic data, hi byte
    180  27000				   -	       sbc	#(WZONEHEIGHT-1)	; start at the DMA hole. -1 because carry is clear
    181  27000				   -	       sta	(dlpnt),y
    182  27000				   -
    183  27000				   -	       iny
    184  27000				   -	       lda	temp4	;Horizontal position
    185  27000				   -	       sta	(dlpnt),y
    186  27000				   -
    187  27000				   -	       iny
    188  27000				   -	       sty	dlend,x
    189  27000				   -
    190  27000				   -	       ifconst	ALWAYSTERMINATE
    191  27000				   -	       iny
    192  27000				   -	       lda	#0
    193  27000				   -	       sta	(dlpnt),y
    194  27000				   -	       endif
    195  27000				   -
    196  27000				   -doneSPDL4
    197  27000				   -	       rts
    198  27000				   -
    199  27000					       endif		; PLOTSP4
------- FILE c:\Users\seany\Documents\irata\0087_Irata.78b.asm
   2408  27000					       endif
   2409  27000					       ifnconst	included.lzsa1compression.asm
------- FILE lzsa1compression.asm LEVEL 2 PASS 3
      0  27000					       include	lzsa1compression.asm
      1  27000							; ***************************************************************************
      2  27000							; ***************************************************************************
      3  27000							;
      4  27000							; lzsa1_6502.s
      5  27000							;
      6  27000							; NMOS 6502 decompressor for data stored in Emmanuel Marty's LZSA1 format.
      7  27000							;
      8  27000							; Decompresses a raw LZSA1 block, created with the command-line lzsa utility:
      9  27000							;     lzsa -r <original_file> <compressed_file>
     10  27000							;
     11  27000							; in:
     12  27000							; * LZSA_SRC_LO and LZSA_SRC_HI contain the compressed raw block address
     13  27000							; * LZSA_DST_LO and LZSA_DST_HI contain the destination buffer address
     14  27000							;
     15  27000							; out:
     16  27000							; * the destination buffer will contain the decompressed data
     17  27000							; * LZSA_DST_LO and LZSA_DST_HI contain the last decompressed byte address +1
     18  27000							;
     19  27000							; ***************************************************************************
     20  27000							;
     21  27000							; This code is written for the ACME assembler.
     22  27000							;
     23  27000							; The code is 165 bytes for the small version, and 191 bytes for the normal.
     24  27000							;
     25  27000							; Copyright John Brandwood 2021.
     26  27000							;
     27  27000							; Changes intruduced by Mike Saarna, 2023:
     28  27000							;    -converted to DASM format.
     29  27000							;    -generalised memory locations, for easier incorporation into 7800basic
     30  27000							;    -removed self-modifying code, for execution from rom.
     31  27000							;    -added LZSAFASTCOPYBYTE optimisation ; +24 bytes rom, ~10% quicker
     32  27000							;
     33  27000							; get the original unmodified code from:
     34  27000							; https://raw.githubusercontent.com/emmanuel-marty/lzsa
     35  27000							;
     36  27000							; Distributed under the Boost Software License, Version 1.0.
     37  27000							; (See accompanying file LICENSE_1_0.txt or copy at
     38  27000							; http://www.boost.org/LICENSE_1_0.txt)
     39  27000							;
     40  27000							; ***************************************************************************
     41  27000							; ***************************************************************************
     42  27000
     43  27000
     44  27000
     45  27000							; ***************************************************************************
     46  27000							; ***************************************************************************
     47  27000							;
     48  27000							; Decompression Options & Macros
     49  27000							;
     50  27000
     51  27000							;
     52  27000							; Choose size over decompression speed (within sane limits)?
     53  27000							;
     54  27000
     55  27000			00 00	    LZSA_SMALL_SIZE =	0
     56  27000			00 01	    LZSAFASTCOPYBYTE =	1	; +24 bytes rom, ~10% quicker
     57  27000
     58  27000							; ***************************************************************************
     59  27000							; ***************************************************************************
     60  27000							;
     61  27000							; ZP memory allocations... (temp1-temp9 are 7800basic ZP locations)
     62  27000			00 42	    LSZA1ZPRAM =	temp1
     63  27000			00 42	    lzsa_winptr =	LSZA1ZPRAM	; 1 word (temp1+temp2)
     64  27000			00 44	    lzsa_srcptr =	LSZA1ZPRAM + 2	; 1 word (temp3+temp4)
     65  27000			00 46	    lzsa_dstptr =	LSZA1ZPRAM + 4	; 1 word (temp5+temp6)
     66  27000
     67  27000							; Doesn't need to be ZP allocations...
     68  27000			00 48	    LSZA1TEMPRAM =	temp7
     69  27000			00 48	    lzsa_cmdbuf =	LSZA1TEMPRAM	; 1 byte (temp7)
     70  27000			00 49	    lzsa_cp_npages =	LSZA1TEMPRAM + 1	; 1 byte (temp8)
     71  27000			00 4a	    lzsa_lz_npages =	LSZA1TEMPRAM + 2	; 1 byte (temp9)
     72  27000
     73  27000							; Alternate names for previous allocations...
     74  27000			00 42	    lzsa_offset =	lzsa_winptr
     75  27000			00 44	    LZSA_SRC_LO =	lzsa_srcptr
     76  27000			00 45	    LZSA_SRC_HI =	lzsa_srcptr+1
     77  27000			00 46	    LZSA_DST_LO =	lzsa_dstptr
     78  27000			00 47	    LZSA_DST_HI =	lzsa_dstptr+1
     79  27000
     80  27000				   -	       ifconst	lzsa1support
     81  27000				   -
     82  27000				   -lzsa1modulestart
     83  27000				   -
     84  27000				   -	       if	LZSAFASTCOPYBYTE = 1
     85  27000				   -.cp_fixpointer
     86  27000				   -			; the optimised pointer adjustment fails if .cp_byte copied a whole page.
     87  27000				   -			; so we deal with it as a special case here, out of the regular .cp_byte flow.
     88  27000				   -			; this only happens rarely.
     89  27000				   -	       inc	lzsa_srcptr+1	; CC
     90  27000				   -	       inc	lzsa_dstptr+1
     91  27000				   -	       bcc	.cp_skip3	; always taken
     92  27000				   -			; each of these happen infrequently (~1 in 256 byte copies)
     93  27000				   -.cp_fixsrc1
     94  27000				   -	       inc	lzsa_srcptr+1
     95  27000				   -	       clc
     96  27000				   -	       bcc	.cp_skip1
     97  27000				   -.cp_fixsrc2
     98  27000				   -	       inc	lzsa_dstptr+1
     99  27000				   -	       clc
    100  27000				   -	       bcc	.cp_skip2
    101  27000				   -	       endif
    102  27000				   -
    103  27000				   -			; ***************************************************************************
    104  27000				   -			; ***************************************************************************
    105  27000				   -			;
    106  27000				   -			; lzsa1_unpack - Decompress data stored in Emmanuel Marty's LZSA1 format.
    107  27000				   -			;
    108  27000				   -			; Args: lzsa_srcptr = ptr to compessed data
    109  27000				   -			; Args: lzsa_dstptr = ptr to output buffer
    110  27000				   -			;
    111  27000				   -
    112  27000				   -
    113  27000				   -DECOMPRESS_LZSA1_FAST
    114  27000				   -lzsa1_unpack
    115  27000				   -	       ldy	#0	; Initialize source index.
    116  27000				   -	       ldx	#0	; Initialize hi-byte of length.
    117  27000				   -	       stx	lzsa_cp_npages
    118  27000				   -	       stx	lzsa_lz_npages
    119  27000				   -
    120  27000				   -			;
    121  27000				   -			; Copy bytes from compressed source data.
    122  27000				   -			;
    123  27000				   -			; N.B. X=0 is expected and guaranteed when we get here.
    124  27000				   -			;
    125  27000				   -
    126  27000				   -.cp_length
    127  27000				   -	       if	LZSA_SMALL_SIZE = 1
    128  27000				   -
    129  27000				   -	       jsr	.get_byte
    130  27000				   -
    131  27000				   -	       else		; !LZSA_SMALL_SIZE
    132  27000				   -
    133  27000				   -	       lda	(lzsa_srcptr),y
    134  27000				   -	       inc	lzsa_srcptr+0
    135  27000				   -	       bne	.cp_skip0
    136  27000				   -	       inc	lzsa_srcptr+1
    137  27000				   -
    138  27000				   -	       endif		; !LZSA_SMALL_SIZE
    139  27000				   -
    140  27000				   -.cp_skip0
    141  27000				   -	       sta	lzsa_cmdbuf	; Preserve this for later.
    142  27000				   -	       and	#$70	; Extract literal length.
    143  27000				   -	       lsr		; Set CC before ...
    144  27000				   -	       beq	.lz_offset	; Skip directly to match?
    145  27000				   -
    146  27000				   -	       lsr		; Get 3-bit literal length.
    147  27000				   -	       lsr
    148  27000				   -	       lsr
    149  27000				   -	       cmp	#$07	; Extended length?
    150  27000				   -	       bcc	.cp_got_len
    151  27000				   -
    152  27000				   -	       jsr	.get_length	; X=0, CS from CMP, returns CC.
    153  27000				   -	       stx	lzsa_cp_npages	; Hi-byte of length.
    154  27000				   -
    155  27000				   -.cp_got_len
    156  27000				   -	       tax		; Lo-byte of length.
    157  27000				   -
    158  27000				   -	       if	LZSAFASTCOPYBYTE = 0
    159  27000				   -
    160  27000				   -.cp_byte		; CC throughout the execution of this .cp_page loop.
    161  27000				   -	       lda	(lzsa_srcptr),y	; 5
    162  27000				   -	       sta	(lzsa_dstptr),y	; 5
    163  27000				   -	       inc	lzsa_srcptr+0	; 5
    164  27000				   -	       bne	.cp_skip1	; 3
    165  27000				   -	       inc	lzsa_srcptr+1
    166  27000				   -.cp_skip1
    167  27000				   -	       inc	lzsa_dstptr+0	; 5
    168  27000				   -	       bne	.cp_skip2	; 3
    169  27000				   -	       inc	lzsa_dstptr+1
    170  27000				   -.cp_skip2
    171  27000				   -	       dex		; 2
    172  27000				   -	       bne	.cp_byte	; 3
    173  27000				   -			;  ~29 cycles overall for X=1
    174  27000				   -			;  ~58 cycles overall for X=2
    175  27000				   -			;  ~87 cycles overall for X=3
    176  27000				   -			; ...
    177  27000				   -			; ~174 cycles overall for X=6
    178  27000				   -
    179  27000				   -	       else		; LZSAFASTCOPYBYTE != 0
    180  27000				   -
    181  27000				   -			; according to 7800heat, this loop is hot. It runs on average ~6x.
    182  27000				   -
    183  27000				   -.cp_byte		; CC throughout the execution of this .cp_page loop.
    184  27000				   -	       lda	(lzsa_srcptr),y	; 5+
    185  27000				   -	       sta	(lzsa_dstptr),y	; 5+
    186  27000				   -	       iny		; 2
    187  27000				   -	       dex		; 2
    188  27000				   -	       bne	.cp_byte	; 3/2
    189  27000				   -			; ~17 cycles each iteration
    190  27000				   -	       tya		; 2
    191  27000				   -	       beq	.cp_fixpointer	; 2 unlikely branch - only if we copied a full page
    192  27000				   -	       adc	lzsa_srcptr+0	; 3
    193  27000				   -	       sta	lzsa_srcptr+0	; 3
    194  27000				   -	       bcs	.cp_fixsrc1	; 2 (typical)
    195  27000				   -.cp_skip1
    196  27000				   -	       tya		; 2
    197  27000				   -	       adc	lzsa_dstptr+0	; 3
    198  27000				   -	       sta	lzsa_dstptr+0	; 3
    199  27000				   -	       bcs	.cp_fixsrc2	; 2 (typical)
    200  27000				   -.cp_skip2
    201  27000				   -	       ldy	#0	; 2
    202  27000				   -.cp_skip3
    203  27000				   -			; ~24 cycles overhead, typical
    204  27000				   -
    205  27000				   -			; ~41	cycles for X=1 (+12  cycles vs non-optimized)
    206  27000				   -			; ~58	cycles for X=2 (  0  cycles vs non-optimized)
    207  27000				   -			; ~75	cycles for X=3 (-12  cycles vs non-optimized)
    208  27000				   -			; ...
    209  27000				   -			; ~126 cycles for X=6 (-48  cycles vs non-optimized)
    210  27000				   -	       endif		; ! LZSAFASTCOPYBYTE = 0
    211  27000				   -
    212  27000				   -.cp_npages
    213  27000				   -	       lda	lzsa_cp_npages	; Any full pages left to copy?
    214  27000				   -	       beq	.lz_offset
    215  27000				   -
    216  27000				   -	       dec	lzsa_cp_npages	; Unlikely, so can be slow.
    217  27000				   -	       bcc	.cp_byte	; Always true!
    218  27000				   -
    219  27000				   -	       if	LZSA_SMALL_SIZE = 1
    220  27000				   -
    221  27000				   -			; Copy bytes from decompressed window.
    222  27000				   -			;
    223  27000				   -			; Shorter but slower version.
    224  27000				   -			;
    225  27000				   -			; N.B. X=0 is expected and guaranteed when we get here.
    226  27000				   -			;
    227  27000				   -
    228  27000				   -.lz_offset
    229  27000				   -	       jsr	.get_byte	; Get offset-lo.
    230  27000				   -
    231  27000				   -.offset_lo
    232  27000				   -	       adc	lzsa_dstptr+0	; Always CC from .cp_page loop.
    233  27000				   -	       sta	lzsa_winptr+0
    234  27000				   -
    235  27000				   -	       lda	#$FF
    236  27000				   -	       bit	lzsa_cmdbuf
    237  27000				   -	       bpl	.offset_hi
    238  27000				   -
    239  27000				   -	       jsr	.get_byte	; Get offset-hi.
    240  27000				   -
    241  27000				   -.offset_hi
    242  27000				   -	       adc	lzsa_dstptr+1	; lzsa_winptr < lzsa_dstptr, so
    243  27000				   -	       sta	lzsa_winptr+1	; always leaves CS.
    244  27000				   -
    245  27000				   -.lz_length
    246  27000				   -	       lda	lzsa_cmdbuf	; X=0 from previous loop.
    247  27000				   -	       and	#$0F
    248  27000				   -	       adc	#$03 - 1	; CS from previous ADC.
    249  27000				   -	       cmp	#$12	; Extended length?
    250  27000				   -	       bcc	.lz_got_len
    251  27000				   -
    252  27000				   -	       jsr	.get_length	; CS from CMP, X=0, returns CC.
    253  27000				   -	       stx	lzsa_lz_npages	; Hi-byte of length.
    254  27000				   -
    255  27000				   -.lz_got_len
    256  27000				   -	       tax		; Lo-byte of length.
    257  27000				   -
    258  27000				   -.lz_byte
    259  27000				   -	       lda	(lzsa_winptr),y	; CC throughout the execution of
    260  27000				   -	       sta	(lzsa_dstptr),y	; of this .lz_page loop.
    261  27000				   -	       inc	lzsa_winptr+0
    262  27000				   -	       bne	.lz_skip1
    263  27000				   -	       inc	lzsa_winptr+1
    264  27000				   -.lz_skip1
    265  27000				   -	       inc	lzsa_dstptr+0
    266  27000				   -	       bne	.lz_skip2
    267  27000				   -	       inc	lzsa_dstptr+1
    268  27000				   -.lz_skip2
    269  27000				   -	       dex
    270  27000				   -	       bne	.lz_byte
    271  27000				   -.lz_npages
    272  27000				   -	       lda	lzsa_lz_npages	; Any full pages left to copy?
    273  27000				   -	       beq	.cp_length
    274  27000				   -
    275  27000				   -	       dec	lzsa_lz_npages	; Unlikely, so can be slow.
    276  27000				   -	       bcc	.lz_byte	; Always true!
    277  27000				   -
    278  27000				   -	       else		; !LZSA_SMALL_SIZE
    279  27000				   -
    280  27000				   -			;
    281  27000				   -			; Copy bytes from decompressed window.
    282  27000				   -			;
    283  27000				   -			; Longer but faster.
    284  27000				   -			;
    285  27000				   -			; N.B. X=0 is expected and guaranteed when we get here.
    286  27000				   -			;
    287  27000				   -
    288  27000				   -.lz_offset
    289  27000				   -	       lda	(lzsa_srcptr),y	; Get offset-lo.
    290  27000				   -	       inc	lzsa_srcptr+0
    291  27000				   -	       bne	.offset_lo
    292  27000				   -	       inc	lzsa_srcptr+1
    293  27000				   -
    294  27000				   -.offset_lo
    295  27000				   -	       sta	lzsa_offset+0
    296  27000				   -
    297  27000				   -	       lda	#$FF	; Get offset-hi.
    298  27000				   -	       bit	lzsa_cmdbuf
    299  27000				   -	       bpl	.offset_hi
    300  27000				   -
    301  27000				   -	       lda	(lzsa_srcptr),y
    302  27000				   -	       inc	lzsa_srcptr+0
    303  27000				   -	       bne	.offset_hi
    304  27000				   -	       inc	lzsa_srcptr+1
    305  27000				   -
    306  27000				   -.offset_hi
    307  27000				   -	       sta	lzsa_offset+1
    308  27000				   -
    309  27000				   -.lz_length
    310  27000				   -	       lda	lzsa_cmdbuf	; X=0 from previous loop.
    311  27000				   -	       and	#$0F
    312  27000				   -	       adc	#$03	; Always CC from .cp_page loop.
    313  27000				   -	       cmp	#$12	; Extended length?
    314  27000				   -	       bcc	.got_lz_len
    315  27000				   -
    316  27000				   -	       jsr	.get_length	; X=0, CS from CMP, returns CC.
    317  27000				   -
    318  27000				   -.got_lz_len
    319  27000				   -	       inx		; Hi-byte of length+256.
    320  27000				   -
    321  27000				   -	       eor	#$FF	; Negate the lo-byte of length
    322  27000				   -	       tay
    323  27000				   -	       eor	#$FF
    324  27000				   -
    325  27000				   -.get_lz_dst
    326  27000				   -	       adc	lzsa_dstptr+0	; Calc address of partial page.
    327  27000				   -	       sta	lzsa_dstptr+0	; Always CC from previous CMP.
    328  27000				   -	       iny
    329  27000				   -	       bcs	.get_lz_win
    330  27000				   -	       beq	.get_lz_win	; Is lo-byte of length zero?
    331  27000				   -	       dec	lzsa_dstptr+1
    332  27000				   -
    333  27000				   -.get_lz_win
    334  27000				   -	       clc		; Calc address of match.
    335  27000				   -	       adc	lzsa_offset+0	; N.B. Offset is negative!
    336  27000				   -	       sta	lzsa_winptr+0
    337  27000				   -	       lda	lzsa_dstptr+1
    338  27000				   -	       adc	lzsa_offset+1
    339  27000				   -	       sta	lzsa_winptr+1
    340  27000				   -
    341  27000				   -			; according to 7800heat, this loop is hot. It runs on average ~7.5x.
    342  27000				   -			; TODO: see if there's a chance to unroll it.
    343  27000				   -.lz_byte
    344  27000				   -	       lda	(lzsa_winptr),y
    345  27000				   -	       sta	(lzsa_dstptr),y
    346  27000				   -	       iny
    347  27000				   -	       bne	.lz_byte
    348  27000				   -
    349  27000				   -	       inc	lzsa_dstptr+1
    350  27000				   -	       dex		; Any full pages left to copy?
    351  27000				   -	       bne	.lz_more
    352  27000				   -
    353  27000				   -	       jmp	.cp_length	; Loop around to the beginning.
    354  27000				   -
    355  27000				   -.lz_more
    356  27000				   -	       inc	lzsa_winptr+1	; Unlikely, so can be slow.
    357  27000				   -	       bne	.lz_byte	; Always true!
    358  27000				   -
    359  27000				   -	       endif		; !LZSA_SMALL_SIZE
    360  27000				   -
    361  27000				   -			;
    362  27000				   -			; Get 16-bit length in X:A register pair, return with CC.
    363  27000				   -			;
    364  27000				   -			; N.B. X=0 is expected and guaranteed when we get here.
    365  27000				   -			;
    366  27000				   -
    367  27000				   -.get_length
    368  27000				   -	       clc		; Add on the next byte to get
    369  27000				   -	       adc	(lzsa_srcptr),y	; the length.
    370  27000				   -	       inc	lzsa_srcptr+0
    371  27000				   -	       bne	.skip_inc
    372  27000				   -	       inc	lzsa_srcptr+1
    373  27000				   -.skip_inc
    374  27000				   -
    375  27000				   -	       bcc	.got_length	; No overflow means done.
    376  27000				   -	       clc		; MUST return CC!
    377  27000				   -	       tax		; Preserve overflow value.
    378  27000				   -
    379  27000				   -.extra_byte
    380  27000				   -	       jsr	.get_byte	; So rare, this can be slow!
    381  27000				   -	       pha
    382  27000				   -	       txa		; Overflow to 256 or 257?
    383  27000				   -	       beq	.extra_word
    384  27000				   -
    385  27000				   -.check_length
    386  27000				   -	       pla		; Length-lo.
    387  27000				   -	       bne	.got_length	; Check for zero.
    388  27000				   -	       dex		; Do one less page loop if so.
    389  27000				   -.got_length
    390  27000				   -	       rts
    391  27000				   -
    392  27000				   -.extra_word
    393  27000				   -	       jsr	.get_byte	; So rare, this can be slow!
    394  27000				   -	       tax
    395  27000				   -	       bne	.check_length	; Length-hi == 0 at EOF.
    396  27000				   -
    397  27000				   -.finished
    398  27000				   -	       pla		; Length-lo.
    399  27000				   -	       pla		; Decompression completed, pop
    400  27000				   -	       pla		; return address.
    401  27000				   -	       rts
    402  27000				   -
    403  27000				   -.get_byte
    404  27000				   -	       lda	(lzsa_srcptr),y	; Subroutine version for when
    405  27000				   -	       inc	lzsa_srcptr+0	; inlining isn't advantageous.
    406  27000				   -	       bne	.got_byte
    407  27000				   -	       inc	lzsa_srcptr+1	; Inc & test for bank overflow.
    408  27000				   -.got_byte
    409  27000				   -	       rts
    410  27000				   -
    411  27000				   -lzsa1moduleend
    412  27000				   -
    413  27000				   -	       echo	"  (lzsa1compression module is using ",[(lzsa1moduleend-lzsa1modulestart)]d," bytes of rom)"
    414  27000				   -
    415  27000					       endif		; lzsa1support
------- FILE c:\Users\seany\Documents\irata\0087_Irata.78b.asm
   2411  27000					       endif
   2412  27000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2413  27000
   2414  27000							;standard routimes needed for pretty much all games
   2415  27000
   2416  27000							; some definitions used with "set debug color"
   2417  27000			00 91	    DEBUGCALC  =	$91
   2418  27000			00 41	    DEBUGWASTE =	$41
   2419  27000			00 c1	    DEBUGDRAW  =	$C1
   2420  27000
   2421  27000							;NMI and IRQ handlers
   2422  27000				    NMI
   2423  27000							;VISIBLEOVER is 255 while the screen is drawn, and 0 right after the visible screen is done.
   2424  27000			48		       pha		; save A
   2425  27001			d8		       cld
   2426  27002			a5 4d		       lda	visibleover
   2427  27004			49 ff		       eor	#255
   2428  27006			85 4d		       sta	visibleover
   2429  27008				   -	       ifconst	DEBUGINTERRUPT
   2430  27008				   -	       and	#$93
   2431  27008				   -	       sta	BACKGRND
   2432  27008					       endif
   2433  27008			8a		       txa		; save X
   2434  27009			48		       pha
   2435  2700a			98		       tya		; save Y
   2436  2700b			48		       pha
   2437  2700c			ce b2 01	       dec	interruptindex
   2438  2700f			d0 03		       bne	skipreallyoffvisible
   2439  27011			4c 6b f0	       jmp	reallyoffvisible
   2440  27014				    skipreallyoffvisible
   2441  27014			a5 4d		       lda	visibleover
   2442  27016			d0 03		       bne	carryontopscreenroutine
   2443  27018				   -	       ifconst	.bottomscreenroutine
   2444  27018				   -	       lda	interrupthold
   2445  27018				   -	       beq	skipbottomroutine
   2446  27018				   -	       jsr	.bottomscreenroutine
   2447  27018				   -skipbottomroutine
   2448  27018					       endif
   2449  27018			4c 79 f0	       jmp	NMIexit
   2450  2701b				    carryontopscreenroutine
   2451  2701b				   -	       ifconst	.topscreenroutine
   2452  2701b				   -	       lda	interrupthold
   2453  2701b				   -	       beq	skiptoproutine
   2454  2701b				   -	       jsr	.topscreenroutine
   2455  2701b				   -skiptoproutine
   2456  2701b					       endif
   2457  2701b					       ifnconst	CANARYOFF
   2458  2701b			ad c2 01	       lda	canary
   2459  2701e			f0 07		       beq	skipcanarytriggered
   2460  27020			a9 45		       lda	#$45
   2461  27022			85 20		       sta	BACKGRND
   2462  27024			4c 63 f0	       jmp	skipbrkolorset	; common crash dump routine, if available
   2463  27027				    skipcanarytriggered
   2464  27027					       endif
   2465  27027
   2466  27027			ee 3e 21	       inc	frameslost	; this is balanced with a "dec frameslost" when drawscreen is called.
   2467  2702a
   2468  2702a							; ** Other important routines that need to regularly run, and can run onscreen.
   2469  2702a							; ** Atarivox can't go here, because Maria might interrupt it while it's bit-banging.
   2470  2702a
   2471  2702a				   -	       ifconst	LONGCONTROLLERREAD
   2472  2702a				   -longcontrollerreads 		; ** controllers that take a lot of time to read. We use much of the visible screen here.
   2473  2702a				   -	       ldy	port1control
   2474  2702a				   -	       lda	longreadtype,y
   2475  2702a				   -	       beq	LLRET1
   2476  2702a				   -	       tay
   2477  2702a				   -	       lda	longreadroutinehiP1,y
   2478  2702a				   -	       sta	inttemp4
   2479  2702a				   -	       lda	longreadroutineloP1,y
   2480  2702a				   -	       sta	inttemp3
   2481  2702a				   -	       jmp	(inttemp3)
   2482  2702a				   -LLRET1
   2483  2702a				   -	       ldy	port0control
   2484  2702a				   -	       lda	longreadtype,y
   2485  2702a				   -	       beq	LLRET0
   2486  2702a				   -	       tay
   2487  2702a				   -	       lda	longreadroutinehiP0,y
   2488  2702a				   -	       sta	inttemp4
   2489  2702a				   -	       lda	longreadroutineloP0,y
   2490  2702a				   -	       sta	inttemp3
   2491  2702a				   -	       jmp	(inttemp3)
   2492  2702a				   -LLRET0
   2493  2702a				   -
   2494  2702a				   -
   2495  2702a				   -	       ifconst	PADDLERANGE
   2496  2702a				   -TIMEVAL    =	PADDLERANGE
   2497  2702a				   -	       else
   2498  2702a				   -TIMEVAL    =	160
   2499  2702a				   -	       endif
   2500  2702a				   -TIMEOFFSET =	10
   2501  2702a				   -
   2502  2702a					       endif		; LONGCONTROLLERREAD
   2503  2702a
   2504  2702a
   2505  2702a			20 03 f2	       jsr	servicesfxchannels
   2506  2702d				   -	       ifconst	MUSICTRACKER
   2507  2702d				   -	       jsr	servicesong
   2508  2702d					       endif		; MUSICTRACKER
   2509  2702d				   -	       ifconst	RMT
   2510  2702d				   -	       ifnconst	RMTOFFSPEED
   2511  2702d				   -	       ifconst	RMTPALSPEED
   2512  2702d				   -	       lda	ntscslowframe
   2513  2702d				   -	       bne	skiprasterupdate
   2514  2702d				   -	       endif
   2515  2702d				   -	       endif
   2516  2702d				   -	       lda	rasterpause
   2517  2702d				   -	       beq	skiprasterupdate
   2518  2702d				   -	       ifconst	PAUSESILENT
   2519  2702d				   -	       lda	pausestate
   2520  2702d				   -	       bne	skiprasterupdate
   2521  2702d				   -	       endif
   2522  2702d				   -	       jsr	RASTERMUSICTRACKER+3
   2523  2702d				   -skiprasterupdate
   2524  2702d				   -RMT_Iend
   2525  2702d					       endif
   2526  2702d
   2527  2702d			ee a4 01	       inc	framecounter
   2528  27030			ad a4 01	       lda	framecounter
   2529  27033			29 3f		       and	#63
   2530  27035			d0 08		       bne	skipcountdownseconds
   2531  27037			ad a5 01	       lda	countdownseconds
   2532  2703a			f0 03		       beq	skipcountdownseconds
   2533  2703c			ce a5 01	       dec	countdownseconds
   2534  2703f				    skipcountdownseconds
   2535  2703f
   2536  2703f			a2 01		       ldx	#1
   2537  27041				    buttonreadloop
   2538  27041			8a		       txa
   2539  27042			48		       pha
   2540  27043			bc b8 01	       ldy	port0control,x
   2541  27046			b9 df f1	       lda	buttonhandlerlo,y
   2542  27049			85 da		       sta	inttemp3
   2543  2704b			b9 d2 f1	       lda	buttonhandlerhi,y
   2544  2704e			85 db		       sta	inttemp4
   2545  27050			05 da		       ora	inttemp3
   2546  27052			f0 03		       beq	buttonreadloopreturn
   2547  27054			6c da 00	       jmp	(inttemp3)
   2548  27057				    buttonreadloopreturn
   2549  27057			68		       pla
   2550  27058			aa		       tax
   2551  27059			ca		       dex
   2552  2705a			10 e5		       bpl	buttonreadloop
   2553  2705c
   2554  2705c				   -	       ifconst	DOUBLEBUFFER
   2555  2705c				   -	       lda	doublebufferminimumframeindex
   2556  2705c				   -	       beq	skipdoublebufferminimumframeindexadjust
   2557  2705c				   -	       dec	doublebufferminimumframeindex
   2558  2705c				   -skipdoublebufferminimumframeindexadjust
   2559  2705c					       endif
   2560  2705c
   2561  2705c			4c 79 f0	       jmp	NMIexit
   2562  2705f
   2563  2705f				    IRQ 		; the only source of non-nmi interrupt should be the BRK opcode.
   2564  2705f					       ifnconst	BREAKPROTECTOFF
   2565  2705f			a9 1a		       lda	#$1A
   2566  27061			85 20		       sta	BACKGRND
   2567  27063				    skipbrkolorset
   2568  27063				    skipbrkdetected
   2569  27063			a9 60		       lda	#$60
   2570  27065			8d 07 21	       sta	sCTRL
   2571  27068			85 3c		       sta	CTRL
   2572  2706a					       ifnconst	hiscorefont
   2573  2706a			02		       .byte.b	$02	; KIL/JAM
   2574  2706b				   -	       else		; hiscorefont is present
   2575  2706b				   -	       ifconst	CRASHDUMP
   2576  2706b				   -	       bit	MSTAT
   2577  2706b				   -	       bpl	skipbrkdetected	; wait for vblank to ensure we're clear of NMI
   2578  2706b				   -
   2579  2706b				   -	       ifconst	dumpbankswitch
   2580  2706b				   -	       lda	dumpbankswitch
   2581  2706b				   -	       pha
   2582  2706b				   -	       endif
   2583  2706b				   -
   2584  2706b				   -			; bankswitch if needed, to get to the hiscore font
   2585  2706b				   -	       ifconst	bankswitchmode
   2586  2706b				   -	       ifconst	included.hiscore.asm.bank
   2587  2706b				   -	       ifconst	MCPDEVCART
   2588  2706b				   -	       lda	#($18 | included.hiscore.asm.bank)
   2589  2706b				   -	       sta	$3000
   2590  2706b				   -	       else
   2591  2706b				   -	       lda	#(included.hiscore.asm.bank)
   2592  2706b				   -	       sta	$8000
   2593  2706b				   -	       endif
   2594  2706b				   -	       endif		; included.hiscore.asm.bank
   2595  2706b				   -	       endif		; bankswitchmode
   2596  2706b				   -
   2597  2706b				   -	       ifconst	DOUBLEBUFFER
   2598  2706b				   -			;turn off double-buffering, if on...
   2599  2706b				   -	       lda	#>DLLMEM
   2600  2706b				   -	       sta	DPPH
   2601  2706b				   -	       lda	#<DLLMEM
   2602  2706b				   -	       sta	DPPL
   2603  2706b				   -	       endif
   2604  2706b				   -
   2605  2706b				   -	       lda	#$00
   2606  2706b				   -	       sta	P0C2
   2607  2706b				   -
   2608  2706b				   -			;update the second-from-top DL...
   2609  2706b				   -	       ldy	#8
   2610  2706b				   -NMIupdatetopDL
   2611  2706b				   -	       lda	show2700,y
   2612  2706b				   -	       sta	ZONE1ADDRESS,y
   2613  2706b				   -	       dey
   2614  2706b				   -	       bpl	NMIupdatetopDL
   2615  2706b				   -
   2616  2706b				   -			; the hiscore font is present, so we try to output the stack
   2617  2706b				   -	       ldy	#0
   2618  2706b				   -copystackloop
   2619  2706b				   -	       pla
   2620  2706b				   -	       pha
   2621  2706b				   -	       lsr
   2622  2706b				   -	       lsr
   2623  2706b				   -	       lsr
   2624  2706b				   -	       lsr
   2625  2706b				   -	       tax
   2626  2706b				   -	       lda	hiscorehexlut,x
   2627  2706b				   -	       sta	$2700,y
   2628  2706b				   -	       iny
   2629  2706b				   -
   2630  2706b				   -	       pla
   2631  2706b				   -	       and	#$0F
   2632  2706b				   -	       tax
   2633  2706b				   -	       lda	hiscorehexlut,x
   2634  2706b				   -	       sta	$2700,y
   2635  2706b				   -	       iny
   2636  2706b				   -
   2637  2706b				   -	       lda	#27	; period
   2638  2706b				   -	       sta	$2700,y
   2639  2706b				   -	       iny
   2640  2706b				   -
   2641  2706b				   -	       cpy	#30
   2642  2706b				   -	       bne	copystackloop
   2643  2706b				   -
   2644  2706b				   -	       lda	#>hiscorefont
   2645  2706b				   -	       sta	CHARBASE
   2646  2706b				   -	       sta	sCHARBASE
   2647  2706b				   -	       lda	#%01000011	;Enable DMA, mode=320A
   2648  2706b				   -	       sta	CTRL
   2649  2706b				   -	       sta	sCTRL
   2650  2706b				   -	       .byte	$02	; KIL/JAM
   2651  2706b				   -hiscorehexlut
   2652  2706b				   -			; 0 1 2 3 4 5 6 7 8 9 A B C D E F
   2653  2706b				   -	       .byte	33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 0, 1, 2, 3, 4, 5
   2654  2706b				   -show2700
   2655  2706b				   -			; lo mode hi width=29 x EODL
   2656  2706b				   -	       .byte	$00, %01100000, $27, 3, 20, 0,0,0
   2657  2706b				   -	       else		; CRASHDUMP
   2658  2706b				   -	       .byte	$02	; KIL/JAM
   2659  2706b				   -	       endif		; crashdump
   2660  2706b					       endif		; hiscorefont
   2661  2706b				   -	       else
   2662  2706b				   -	       RTI
   2663  2706b					       endif
   2664  2706b
   2665  2706b				   -	       ifconst	LONGCONTROLLERREAD
   2666  2706b				   -
   2667  2706b				   -longreadtype
   2668  2706b				   -	       .byte	0, 0, 0, 1	; NONE PROLINE LIGHTGUN PADDLE
   2669  2706b				   -	       .byte	2, 0, 3, 0	; TRKBALL VCSSTICK DRIVING KEYPAD
   2670  2706b				   -	       .byte	3, 3, 0, 0	; STMOUSE AMOUSE ATARIVOX SNES
   2671  2706b				   -
   2672  2706b				   -longreadroutineloP0
   2673  2706b				   -	       .byte	<LLRET0	; 0 = no routine
   2674  2706b				   -	       .byte	<paddleport0update	; 1 = paddle
   2675  2706b				   -	       .byte	<trakball0update	; 2 = trakball
   2676  2706b				   -	       .byte	<mouse0update	; 3 = mouse
   2677  2706b				   -
   2678  2706b				   -longreadroutinehiP0
   2679  2706b				   -	       .byte	>LLRET0	; 0 = no routine
   2680  2706b				   -	       .byte	>paddleport0update	; 1 = paddle
   2681  2706b				   -	       .byte	>trakball0update	; 2 = trackball
   2682  2706b				   -	       .byte	>mouse0update	; 3 = mouse
   2683  2706b				   -
   2684  2706b				   -longreadroutineloP1
   2685  2706b				   -	       .byte	<LLRET1	; 0 = no routine
   2686  2706b				   -	       .byte	<paddleport1update	; 1 = paddle
   2687  2706b				   -	       .byte	<trakball1update	; 2 = trakball
   2688  2706b				   -	       .byte	<mouse1update	; 3 = mouse
   2689  2706b				   -
   2690  2706b				   -longreadroutinehiP1
   2691  2706b				   -	       .byte	>LLRET1	; 0 = no routine
   2692  2706b				   -	       .byte	>paddleport1update	; 1 = paddle
   2693  2706b				   -	       .byte	>trakball1update	; 2 = trackball
   2694  2706b				   -	       .byte	>mouse1update	; 3 = mouse
   2695  2706b				   -
   2696  2706b				   -
   2697  2706b				   -SETTIM64T
   2698  2706b				   -	       bne	skipdefaulttime
   2699  2706b				   -	       ifnconst	PADDLESMOOTHINGOFF
   2700  2706b				   -	       lda	#(TIMEVAL+TIMEOFFSET+1)
   2701  2706b				   -	       else
   2702  2706b				   -	       lda	#(TIMEVAL+TIMEOFFSET)
   2703  2706b				   -	       endif
   2704  2706b				   -skipdefaulttime
   2705  2706b				   -	       tay
   2706  2706b				   -	       dey
   2707  2706b				   -.setTIM64Tloop
   2708  2706b				   -	       sta	TIM64T
   2709  2706b				   -	       cpy	INTIM
   2710  2706b				   -	       bne	.setTIM64Tloop
   2711  2706b				   -	       rts
   2712  2706b					       endif		; LONGCONTROLLERREAD
   2713  2706b
   2714  2706b				    reallyoffvisible
   2715  2706b			85 24		       sta	WSYNC
   2716  2706d
   2717  2706d			a9 00		       lda	#0
   2718  2706f			85 4d		       sta	visibleover
   2719  27071				   -	       ifconst	DEBUGINTERRUPT
   2720  27071				   -	       sta	BACKGRND
   2721  27071					       endif
   2722  27071
   2723  27071			a9 03		       lda	#3
   2724  27073			8d b2 01	       sta	interruptindex
   2725  27076
   2726  27076			20 4b f1	       jsr	uninterruptableroutines
   2727  27079
   2728  27079				   -	       ifconst	.userinterrupt
   2729  27079				   -	       lda	interrupthold
   2730  27079				   -	       beq	skipuserintroutine
   2731  27079				   -	       jsr	.userinterrupt
   2732  27079				   -skipuserintroutine
   2733  27079					       endif
   2734  27079
   2735  27079				   -	       ifconst	KEYPADSUPPORT
   2736  27079				   -	       jsr	keypadcolumnread
   2737  27079				   -	       jsr	keypadrowselect
   2738  27079					       endif
   2739  27079
   2740  27079				    NMIexit
   2741  27079			68		       pla
   2742  2707a			a8		       tay
   2743  2707b			68		       pla
   2744  2707c			aa		       tax
   2745  2707d			68		       pla
   2746  2707e			40		       RTI
   2747  2707f
   2748  2707f				    clearscreen
   2749  2707f			a2 0b		       ldx	#(WZONECOUNT-1)
   2750  27081			a9 00		       lda	#0
   2751  27083				    clearscreenloop
   2752  27083			95 65		       sta	dlend,x
   2753  27085			ca		       dex
   2754  27086			10 fb		       bpl	clearscreenloop
   2755  27088			a9 00		       lda	#0
   2756  2708a			8d ad 01	       sta	valbufend	; clear the bcd value buffer
   2757  2708d			8d ae 01	       sta	valbufendsave
   2758  27090			60		       rts
   2759  27091
   2760  27091				    restorescreen
   2761  27091			a2 0b		       ldx	#(WZONECOUNT-1)
   2762  27093			a9 00		       lda	#0
   2763  27095				    restorescreenloop
   2764  27095			b5 82		       lda	dlendsave,x
   2765  27097			95 65		       sta	dlend,x
   2766  27099			ca		       dex
   2767  2709a			10 f9		       bpl	restorescreenloop
   2768  2709c			ad ae 01	       lda	valbufendsave
   2769  2709f			8d ad 01	       sta	valbufend
   2770  270a2			60		       rts
   2771  270a3
   2772  270a3				    savescreen
   2773  270a3			a2 0b		       ldx	#(WZONECOUNT-1)
   2774  270a5				    savescreenloop
   2775  270a5			b5 65		       lda	dlend,x
   2776  270a7			95 82		       sta	dlendsave,x
   2777  270a9			ca		       dex
   2778  270aa			10 f9		       bpl	savescreenloop
   2779  270ac			ad ad 01	       lda	valbufend
   2780  270af			8d ae 01	       sta	valbufendsave
   2781  270b2				   -	       ifconst	DOUBLEBUFFER
   2782  270b2				   -	       lda	doublebufferstate
   2783  270b2				   -	       beq	savescreenrts
   2784  270b2				   -	       lda	#1
   2785  270b2				   -	       sta	doublebufferbufferdirty
   2786  270b2				   -savescreenrts
   2787  270b2					       endif		; DOUBLEBUFFER
   2788  270b2			60		       rts
   2789  270b3
   2790  270b3				    drawscreen
   2791  270b3
   2792  270b3				   -	       ifconst	interrupthold
   2793  270b3				   -	       lda	#$FF
   2794  270b3				   -	       sta	interrupthold	; if the user called drawscreen, we're ready for interrupts
   2795  270b3					       endif
   2796  270b3
   2797  270b3			a9 00		       lda	#0
   2798  270b5			85 42		       sta	temp1	; not B&W if we're here...
   2799  270b7
   2800  270b7				    drawscreenwait
   2801  270b7			a5 4d		       lda	visibleover
   2802  270b9			d0 fc		       bne	drawscreenwait	; make sure the visible screen isn't being drawn
   2803  270bb
   2804  270bb							;restore some registers in case the game changed them mid-screen...
   2805  270bb			ad 07 21	       lda	sCTRL
   2806  270be			05 42		       ora	temp1
   2807  270c0			85 3c		       sta	CTRL
   2808  270c2			ad 0b 21	       lda	sCHARBASE
   2809  270c5			85 34		       sta	CHARBASE
   2810  270c7
   2811  270c7							;ensure all of the display list is terminated...
   2812  270c7			20 31 f1	       jsr	terminatedisplaylist
   2813  270ca
   2814  270ca					       ifnconst	pauseroutineoff
   2815  270ca			20 d5 f0	       jsr	pauseroutine
   2816  270cd					       endif		; pauseroutineoff
   2817  270cd
   2818  270cd							; Make sure the visible screen has *started* before we exit. That way we can rely on drawscreen
   2819  270cd							; delaying a full frame, but still allowing time for basic calculations.
   2820  270cd				    visiblescreenstartedwait
   2821  270cd			a5 4d		       lda	visibleover
   2822  270cf			f0 fc		       beq	visiblescreenstartedwait
   2823  270d1				    visiblescreenstartedwaitdone
   2824  270d1			ce 3e 21	       dec	frameslost	; ; this gets balanced with an "inc frameslost" by an NMI at the top of the screen
   2825  270d4			60		       rts
   2826  270d5
   2827  270d5					       ifnconst	pauseroutineoff
   2828  270d5							; check to see if pause was pressed and released
   2829  270d5				    pauseroutine
   2830  270d5			ad b3 01	       lda	pausedisable
   2831  270d8			d0 47		       bne	leavepauseroutine
   2832  270da			a9 08		       lda	#8
   2833  270dc			2c 82 02	       bit	SWCHB
   2834  270df			f0 22		       beq	pausepressed
   2835  270e1
   2836  270e1				   -	       ifconst	SNES0PAUSE
   2837  270e1				   -	       lda	port0control
   2838  270e1				   -	       cmp	#11
   2839  270e1				   -	       bne	skipsnes0pause
   2840  270e1				   -	       lda	snesdetected0
   2841  270e1				   -	       beq	skipsnes0pause
   2842  270e1				   -	       lda	snes2atari0hi
   2843  270e1				   -	       and	#%00010000
   2844  270e1				   -	       beq	pausepressed
   2845  270e1				   -skipsnes0pause
   2846  270e1					       endif
   2847  270e1				   -	       ifconst	SNES1PAUSE
   2848  270e1				   -
   2849  270e1				   -	       lda	port1control
   2850  270e1				   -	       cmp	#11
   2851  270e1				   -	       bne	skipsnes1pause
   2852  270e1				   -	       lda	snesdetected1
   2853  270e1				   -	       beq	skipsnes1pause
   2854  270e1				   -	       lda	snes2atari1hi
   2855  270e1				   -	       and	#%00010000
   2856  270e1				   -	       beq	pausepressed
   2857  270e1				   -skipsnes1pause
   2858  270e1					       endif
   2859  270e1				   -	       ifconst	SNESNPAUSE
   2860  270e1				   -	       ldx	snesport
   2861  270e1				   -	       lda	port0control,x
   2862  270e1				   -	       cmp	#11
   2863  270e1				   -	       bne	skipsnesNpause
   2864  270e1				   -	       lda	snesdetected0,x
   2865  270e1				   -	       beq	skipsnesNpause
   2866  270e1				   -	       lda	snes2atari0hi,x
   2867  270e1				   -	       and	#%00010000
   2868  270e1				   -	       beq	pausepressed
   2869  270e1				   -skipsnesNpause
   2870  270e1					       endif
   2871  270e1				   -	       ifconst	MULTIBUTTONPAUSE
   2872  270e1				   -	       ldx	#1
   2873  270e1				   -multibuttonpauseloop
   2874  270e1				   -	       lda	port0control,x
   2875  270e1				   -	       cmp	#11
   2876  270e1				   -	       bcc	multibuttonpauseloopbottom
   2877  270e1				   -	       lda	sINPT1,x
   2878  270e1				   -	       and	#1
   2879  270e1				   -	       beq	pausepressed
   2880  270e1				   -multibuttonpauseloopbottom
   2881  270e1				   -	       dex
   2882  270e1				   -	       bpl	multibuttonpauseloop
   2883  270e1					       endif		; MULTIBUTTONPAUSE
   2884  270e1
   2885  270e1							;pause isn't pressed
   2886  270e1			a9 00		       lda	#0
   2887  270e3			8d ac 01	       sta	pausebuttonflag	; clear pause hold state in case its set
   2888  270e6
   2889  270e6							;check if we're in an already paused state
   2890  270e6			ad 00 21	       lda	pausestate
   2891  270e9			f0 36		       beq	leavepauseroutine	; nope, leave
   2892  270eb
   2893  270eb			c9 01		       cmp	#1	; last frame was the start of pausing
   2894  270ed			f0 2b		       beq	enterpausestate2	; move from state 1 to 2
   2895  270ef
   2896  270ef			c9 02		       cmp	#2
   2897  270f1			f0 34		       beq	carryonpausing
   2898  270f3
   2899  270f3							;pausestate must be >2, which means we're ending an unpause 
   2900  270f3			a9 00		       lda	#0
   2901  270f5			8d ac 01	       sta	pausebuttonflag
   2902  270f8			8d 00 21	       sta	pausestate
   2903  270fb			ad 07 21	       lda	sCTRL
   2904  270fe			85 3c		       sta	CTRL
   2905  27100			4c 21 f1	       jmp	leavepauseroutine
   2906  27103
   2907  27103				    pausepressed
   2908  27103							;pause is pressed
   2909  27103			ad ac 01	       lda	pausebuttonflag
   2910  27106			c9 ff		       cmp	#$ff
   2911  27108			f0 1d		       beq	carryonpausing
   2912  2710a
   2913  2710a							;its a new press, increment the state
   2914  2710a			ee 00 21	       inc	pausestate
   2915  2710d
   2916  2710d							;silence volume at the start and end of pausing
   2917  2710d			a9 00		       lda	#0
   2918  2710f			85 19		       sta	AUDV0
   2919  27111			85 1a		       sta	AUDV1
   2920  27113
   2921  27113				   -	       ifconst	pokeysupport
   2922  27113				   -	       ldy	#7
   2923  27113				   -pausesilencepokeyaudioloop
   2924  27113				   -	       sta	(pokeybase),y
   2925  27113				   -	       dey
   2926  27113				   -	       bpl	pausesilencepokeyaudioloop
   2927  27113					       endif		; pokeysupport
   2928  27113
   2929  27113			a9 ff		       lda	#$ff
   2930  27115			8d ac 01	       sta	pausebuttonflag
   2931  27118			d0 0d		       bne	carryonpausing
   2932  2711a
   2933  2711a				    enterpausestate2
   2934  2711a			a9 02		       lda	#2
   2935  2711c			8d 00 21	       sta	pausestate
   2936  2711f			d0 06		       bne	carryonpausing
   2937  27121				    leavepauseroutine
   2938  27121			ad 07 21	       lda	sCTRL
   2939  27124			85 3c		       sta	CTRL
   2940  27126			60		       rts
   2941  27127				    carryonpausing
   2942  27127				   -	       ifconst	.pause
   2943  27127				   -	       jsr	.pause
   2944  27127					       endif		; .pause
   2945  27127			ad 07 21	       lda	sCTRL
   2946  2712a			09 80		       ora	#%10000000	; turn off colorburst during pause...
   2947  2712c			85 3c		       sta	CTRL
   2948  2712e			4c d5 f0	       jmp	pauseroutine
   2949  27131					       endif		; pauseroutineoff
   2950  27131
   2951  27131
   2952  27131				   -	       ifconst	DOUBLEBUFFER
   2953  27131				   -skipterminatedisplaylistreturn
   2954  27131				   -	       rts
   2955  27131					       endif		; DOUBLEBUFFER
   2956  27131				    terminatedisplaylist
   2957  27131				   -	       ifconst	DOUBLEBUFFER
   2958  27131				   -	       lda	doublebufferstate
   2959  27131				   -	       bne	skipterminatedisplaylistreturn	; double-buffering runs it's own DL termination code
   2960  27131					       endif		; DOUBLEBUFFER
   2961  27131				    terminatedisplaybuffer
   2962  27131							;add DL end entry on each DL
   2963  27131			a2 0b		       ldx	#(WZONECOUNT-1)
   2964  27133				    dlendloop
   2965  27133				   -	       ifconst	VSCROLL
   2966  27133				   -	       ldy	Xx3,x
   2967  27133				   -	       lda	DLLMEM+11,y
   2968  27133					       else		; !VSCROLL
   2969  27133			bd 52 f5	       lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
   2970  27136					       endif		; !VSCROLL
   2971  27136				   -	       ifconst	DOUBLEBUFFER
   2972  27136				   -	       clc
   2973  27136				   -	       adc	doublebufferdloffset
   2974  27136					       endif		; DOUBLEBUFFER
   2975  27136			85 63		       sta	dlpnt
   2976  27138				   -	       ifconst	VSCROLL
   2977  27138				   -	       lda	DLLMEM+10,y
   2978  27138					       else		; !VSCROLL
   2979  27138			bd 46 f5	       lda	DLPOINTH,x
   2980  2713b					       endif		; !VSCROLL
   2981  2713b				   -	       ifconst	DOUBLEBUFFER
   2982  2713b				   -	       adc	#0
   2983  2713b					       endif		; DOUBLEBUFFER
   2984  2713b			85 64		       sta	dlpnt+1
   2985  2713d			b4 65		       ldy	dlend,x
   2986  2713f			a9 00		       lda	#$00
   2987  27141				    dlendmoreloops
   2988  27141			c8		       iny
   2989  27142			91 63		       sta	(dlpnt),y
   2990  27144				   -	       ifconst	FRAMESKIPGLITCHFIXWEAK
   2991  27144				   -	       cpy	#DLLASTOBJ+1
   2992  27144				   -	       beq	dlendthiszonedone
   2993  27144				   -	       iny
   2994  27144				   -	       iny
   2995  27144				   -	       iny
   2996  27144				   -	       iny
   2997  27144				   -	       iny
   2998  27144				   -	       sta	(dlpnt),y
   2999  27144				   -dlendthiszonedone
   3000  27144					       endif	FRAMESKIPGLITCHFIXWEAK
   3001  27144				   -	       ifconst	FRAMESKIPGLITCHFIX
   3002  27144				   -	       iny
   3003  27144				   -	       iny
   3004  27144				   -	       iny
   3005  27144				   -	       iny
   3006  27144				   -	       cpy	#DLLASTOBJ-1
   3007  27144				   -	       bcc	dlendmoreloops
   3008  27144					       endif		; FRAMESKIPGLITCHFIX
   3009  27144			ca		       dex
   3010  27145			10 ec		       bpl	dlendloop
   3011  27147
   3012  27147					       ifnconst	pauseroutineoff
   3013  27147			20 d5 f0	       jsr	pauseroutine
   3014  2714a					       endif		; pauseroutineoff
   3015  2714a			60		       rts
   3016  2714b
   3017  2714b				    uninterruptableroutines
   3018  2714b							; this is for routines that must happen off the visible screen, each frame.
   3019  2714b
   3020  2714b				   -	       ifconst	AVOXVOICE
   3021  2714b				   -	       jsr	serviceatarivoxqueue
   3022  2714b					       endif
   3023  2714b				   -	       ifconst	MEGA7800SUPPORT
   3024  2714b				   -	       ldx	#1
   3025  2714b				   -mega7800polling
   3026  2714b				   -	       lda	port0control,x
   3027  2714b				   -	       cmp	#12	; mega7800
   3028  2714b				   -	       bne	mega7800handlercheck2
   3029  2714b				   -	       jsr	mega7800handler
   3030  2714b				   -	       jmp	mega7800handlerdone
   3031  2714b				   -mega7800handlercheck2
   3032  2714b				   -	       ifconst	MULTIBUTTON
   3033  2714b				   -	       cmp	#1	; proline
   3034  2714b				   -	       bne	mega7800handlerdone
   3035  2714b				   -	       lda	framecounter
   3036  2714b				   -	       eor	#7	; avoid the same frame as the snes2atari probe
   3037  2714b				   -	       and	#63
   3038  2714b				   -	       bne	mega7800handlerdone
   3039  2714b				   -	       lda	#12
   3040  2714b				   -	       sta	port0control,x
   3041  2714b				   -	       jsr	mega7800handler
   3042  2714b				   -	       endif		; MULTIBUTTON
   3043  2714b				   -mega7800handlerdone
   3044  2714b				   -	       dex
   3045  2714b				   -	       bpl	mega7800polling
   3046  2714b					       endif		; MEGA7800SUPPORT
   3047  2714b
   3048  2714b			a9 00		       lda	#0
   3049  2714d			8d b7 01	       sta	palfastframe
   3050  27150			8d b6 01	       sta	ntscslowframe
   3051  27153			ac b5 01	       ldy	palframes
   3052  27156			c8		       iny
   3053  27157			ae 09 21	       ldx	paldetected	; 0=ntsc 1=pal
   3054  2715a			f0 06		       beq	ntsc2palskipcheck
   3055  2715c				    pal2ntscskipcheck
   3056  2715c			c0 05		       cpy	#5	; every 5th frame, add a frame
   3057  2715e			d0 0b		       bne	palframeskipdone
   3058  27160			f0 04		       beq	frameskipdo
   3059  27162				    ntsc2palskipcheck
   3060  27162			c0 06		       cpy	#6	; every 6th frame, drop a frame
   3061  27164			d0 05		       bne	palframeskipdone
   3062  27166				    frameskipdo
   3063  27166			fe b6 01	       inc	ntscslowframe,x
   3064  27169			a0 00		       ldy	#0
   3065  2716b				    palframeskipdone
   3066  2716b			8c b5 01	       sty	palframes
   3067  2716e				    skippalframeadjusting
   3068  2716e
   3069  2716e				   -	       ifconst	MUSICTRACKER
   3070  2716e				   -			; We normally run the servicesong routine from the top-screen interrupt, but if it
   3071  2716e				   -			; happens to interrupt the scheduling of a sound effect in the game code, we skip it.
   3072  2716e				   -			; If that happens, we try again here. Chances are very small we'll run into the same
   3073  2716e				   -			; problem twice, and if we do, we just drop a musical note or two.
   3074  2716e				   -	       lda	sfxschedulemissed
   3075  2716e				   -	       beq	servicesongwasnotmissed
   3076  2716e				   -	       jsr	servicesong
   3077  2716e				   -servicesongwasnotmissed
   3078  2716e					       endif		; MUSICTRACKER
   3079  2716e
   3080  2716e				   -	       ifconst	RMT
   3081  2716e				   -	       ifnconst	RMTPALSPEED
   3082  2716e				   -	       ifnconst	RMTOFFSPEED
   3083  2716e				   -	       ifconst	PAUSESILENT
   3084  2716e				   -	       lda	pausestate
   3085  2716e				   -	       bne	skiprasterupdate2
   3086  2716e				   -	       endif
   3087  2716e				   -	       lda	palfastframe
   3088  2716e				   -	       beq	skiprasterupdate2
   3089  2716e				   -	       lda	rasterpause
   3090  2716e				   -	       beq	skiprasterupdate2
   3091  2716e				   -	       jsr	RASTERMUSICTRACKER+3
   3092  2716e				   -skiprasterupdate2
   3093  2716e				   -	       endif
   3094  2716e				   -	       endif
   3095  2716e					       endif
   3096  2716e
   3097  2716e			60		       rts
   3098  2716f
   3099  2716f				    serviceatarivoxqueue
   3100  2716f				   -	       ifconst	AVOXVOICE
   3101  2716f				   -	       lda	voxlock
   3102  2716f				   -	       bne	skipvoxprocessing	; the vox is in the middle of speech address update
   3103  2716f				   -skipvoxqueuesizedec
   3104  2716f				   -	       jmp	processavoxvoice
   3105  2716f				   -skipvoxprocessing
   3106  2716f				   -	       rts
   3107  2716f				   -
   3108  2716f				   -processavoxvoice
   3109  2716f				   -	       ifconst	HSSUPPORT
   3110  2716f				   -			; ** we skip speech if hi-score is on and no vox was detected
   3111  2716f				   -			; ** this is to avoid later collision with snes pads.
   3112  2716f				   -	       lda	hsdevice
   3113  2716f				   -	       and	#2
   3114  2716f				   -	       beq	processavoxvoicereturn
   3115  2716f				   -	       endif		; HSSUPPORT
   3116  2716f				   -	       lda	avoxenable
   3117  2716f				   -	       bne	avoxfixport
   3118  2716f				   -	       SPKOUT	tempavox
   3119  2716f				   -	       rts
   3120  2716f				   -avoxfixport
   3121  2716f				   -	       lda	#0	; restore the port to all bits as inputs...
   3122  2716f				   -	       sta	CTLSWA
   3123  2716f				   -	       rts
   3124  2716f				   -silenceavoxvoice
   3125  2716f				   -	       SPEAK	avoxsilentdata
   3126  2716f				   -processavoxvoicereturn
   3127  2716f				   -	       rts
   3128  2716f				   -avoxsilentdata
   3129  2716f				   -	       .byte	31,255
   3130  2716f					       else
   3131  2716f			60		       rts
   3132  27170					       endif		; AVOXVOICE
   3133  27170
   3134  27170				    prolinebuttonpadhandler
   3135  27170				   -	       ifconst	MULTIBUTTON
   3136  27170				   -	       lda	framecounter
   3137  27170				   -	       and	#63
   3138  27170				   -	       bne	jbhandlercont1
   3139  27170				   -	       jsr	setonebuttonmode
   3140  27170				   -	       lda	#11
   3141  27170				   -	       sta	port0control,x
   3142  27170				   -	       jsr	snes2atari_signal_go
   3143  27170				   -	       lda	port0control,x
   3144  27170				   -	       cmp	#1	; check if it's still a proline 
   3145  27170				   -	       beq	jbhandlercont1
   3146  27170				   -	       jmp	buttonreadloopreturn
   3147  27170				   -jbhandlercont1
   3148  27170				   -	       lda	#2
   3149  27170				   -	       sta	multibuttoncount0,x
   3150  27170					       endif		; MULTIBUTTON
   3151  27170				    joybuttonpadhandler
   3152  27170			ad 31 21	       lda	sSWCHA	; clear previous dirs for this pad, from
   3153  27173			1d c2 f1	       ora	SWCHA_DIRMASK,x	; our sSWCHA nibble.
   3154  27176			8d 31 21	       sta	sSWCHA
   3155  27179			ad 80 02	       lda	SWCHA	; load th actual joystick dirs, ensuring
   3156  2717c			1d c3 f1	       ora	SWCHA_DIRMASK+1,x	; we don't change the other nibble.
   3157  2717f			2d 31 21	       and	sSWCHA
   3158  27182			8d 31 21	       sta	sSWCHA
   3159  27185				    joybuttonhandler
   3160  27185			8a		       txa
   3161  27186			0a		       asl
   3162  27187			a8		       tay
   3163  27188			b9 08 00	       lda	INPT0,y
   3164  2718b			4a		       lsr
   3165  2718c							;ora #%00111111
   3166  2718c			9d 02 21	       sta	sINPT1,x
   3167  2718f			b9 09 00	       lda	INPT1,y
   3168  27192			29 80		       and	#%10000000
   3169  27194			1d 02 21	       ora	sINPT1,x
   3170  27197			9d 02 21	       sta	sINPT1,x
   3171  2719a
   3172  2719a			b5 0c		       lda	INPT4,x
   3173  2719c			30 19		       bmi	.skip1bjoyfirecheck
   3174  2719e							;one button joystick is down
   3175  2719e			49 80		       eor	#%10000000
   3176  271a0			9d 02 21	       sta	sINPT1,x
   3177  271a3
   3178  271a3			ad b1 01	       lda	joybuttonmode
   3179  271a6			3d c0 f4	       and	thisjoy2buttonbit,x
   3180  271a9			f0 0c		       beq	.skip1bjoyfirecheck
   3181  271ab			ad b1 01	       lda	joybuttonmode
   3182  271ae			1d c0 f4	       ora	thisjoy2buttonbit,x
   3183  271b1			8d b1 01	       sta	joybuttonmode
   3184  271b4			8d 82 02	       sta	SWCHB
   3185  271b7				    .skip1bjoyfirecheck
   3186  271b7			a9 3f		       lda	#%00111111
   3187  271b9			1d 02 21	       ora	sINPT1,x
   3188  271bc			9d 02 21	       sta	sINPT1,x	; ensure multibutton bits are hi
   3189  271bf			4c 57 f0	       jmp	buttonreadloopreturn
   3190  271c2
   3191  271c2				    SWCHA_DIRMASK
   3192  271c2							;  p0	p1  p0
   3193  271c2			f0 0f f0	       .byte.b	$F0,$0F,$F0
   3194  271c5
   3195  271c5				    gunbuttonhandler		; outside of the conditional, so our button handler LUT is valid
   3196  271c5				   -	       ifconst	LIGHTGUNSUPPORT
   3197  271c5				   -	       cpx	#0
   3198  271c5				   -	       bne	secondportgunhandler
   3199  271c5				   -firstportgunhandler
   3200  271c5				   -	       lda	SWCHA
   3201  271c5				   -	       asl
   3202  271c5				   -	       asl
   3203  271c5				   -	       asl		; shift D4 to D7
   3204  271c5				   -	       and	#%10000000
   3205  271c5				   -	       eor	#%10000000
   3206  271c5				   -	       sta	sINPT1
   3207  271c5				   -	       jmp	buttonreadloopreturn
   3208  271c5				   -secondportgunhandler
   3209  271c5				   -	       lda	SWCHA
   3210  271c5				   -	       lsr		; shift D0 into carry
   3211  271c5				   -	       lsr		; shift carry into D7
   3212  271c5				   -	       and	#%10000000
   3213  271c5				   -	       eor	#%10000000
   3214  271c5				   -	       sta	sINPT3
   3215  271c5				   -	       jmp	buttonreadloopreturn
   3216  271c5					       endif		; LIGHTGUNSUPPORT
   3217  271c5
   3218  271c5				    controlsusing2buttoncode
   3219  271c5			00		       .byte.b	0	; 00=no controller plugged in
   3220  271c6			01		       .byte.b	1	; 01=proline joystick
   3221  271c7			00		       .byte.b	0	; 02=lightgun
   3222  271c8			00		       .byte.b	0	; 03=paddle
   3223  271c9			01		       .byte.b	1	; 04=trakball
   3224  271ca			01		       .byte.b	1	; 05=vcs joystick
   3225  271cb			01		       .byte.b	1	; 06=driving control
   3226  271cc			00		       .byte.b	0	; 07=keypad control
   3227  271cd			00		       .byte.b	0	; 08=st mouse/cx80
   3228  271ce			00		       .byte.b	0	; 09=amiga mouse
   3229  271cf			01		       .byte.b	1	; 10=atarivox
   3230  271d0			00		       .byte.b	0	; 11=snes2atari
   3231  271d1			00		       .byte.b	0	; 12=mega7800
   3232  271d2
   3233  271d2				    buttonhandlerhi
   3234  271d2			00		       .byte.b	0	; 00=no controller plugged in
   3235  271d3			f1		       .byte.b	>prolinebuttonpadhandler	; 01=proline joystick
   3236  271d4			f1		       .byte.b	>gunbuttonhandler	; 02=lightgun
   3237  271d5			f4		       .byte.b	>paddlebuttonhandler	; 03=paddle
   3238  271d6			f1		       .byte.b	>joybuttonhandler	; 04=trakball
   3239  271d7			f1		       .byte.b	>joybuttonpadhandler	; 05=vcs joystick
   3240  271d8			f1		       .byte.b	>joybuttonhandler	; 06=driving control
   3241  271d9			00		       .byte.b	0	; 07=keypad
   3242  271da			f4		       .byte.b	>mousebuttonhandler	; 08=st mouse
   3243  271db			f4		       .byte.b	>mousebuttonhandler	; 09=amiga mouse
   3244  271dc			f1		       .byte.b	>joybuttonhandler	; 10=atarivox
   3245  271dd			f0		       .byte.b	>snes2atarihandler	; 11=snes
   3246  271de			00		       .byte.b	0	; 12=mega7800
   3247  271df				    buttonhandlerlo
   3248  271df			00		       .byte.b	0	; 00=no controller plugged in
   3249  271e0			70		       .byte.b	<prolinebuttonpadhandler	; 01=proline joystick
   3250  271e1			c5		       .byte.b	<gunbuttonhandler	; 02=lightgun 
   3251  271e2			90		       .byte.b	<paddlebuttonhandler	; 03=paddle
   3252  271e3			85		       .byte.b	<joybuttonhandler	; 04=trakball
   3253  271e4			70		       .byte.b	<joybuttonpadhandler	; 05=vcs joystick
   3254  271e5			85		       .byte.b	<joybuttonhandler	; 06=driving control
   3255  271e6			00		       .byte.b	0	; 07=keypad
   3256  271e7			90		       .byte.b	<mousebuttonhandler	; 08=st mouse
   3257  271e8			90		       .byte.b	<mousebuttonhandler	; 09=amiga mouse
   3258  271e9			85		       .byte.b	<joybuttonhandler	; 10=atarivox
   3259  271ea			00		       .byte.b	<snes2atarihandler	; 11=snes
   3260  271eb			00		       .byte.b	0	; 12=mega7800
   3261  271ec
   3262  271ec				    drawwait
   3263  271ec			24 4d		       bit	visibleover	; 255 if screen is being drawn, 0 when not.
   3264  271ee			30 fc		       bmi	drawwait	; make sure the visible screen isn't being drawn
   3265  271f0			60		       rts
   3266  271f1
   3267  271f1				    drawoverwait
   3268  271f1			24 4d		       bit	visibleover	; 255 if screen is being drawn, 0 when not.
   3269  271f3			10 fc		       bpl	drawoverwait	; make sure the visible screen is being drawn
   3270  271f5			60		       rts
   3271  271f6
   3272  271f6
   3273  271f6				    mutetia
   3274  271f6			a9 00		       lda	#0
   3275  271f8			a2 03		       ldx	#3
   3276  271fa				    mutetialoop
   3277  271fa			95 4e		       sta	sfx1pointlo,x
   3278  271fc			95 17		       sta	AUDF0,x
   3279  271fe			ca		       dex
   3280  271ff			10 f9		       bpl	mutetialoop
   3281  27201			60		       rts
   3282  27202
   3283  27202				    servicesfxchannelsdone
   3284  27202					       ifnconst	pokeysupport
   3285  27202			60		       rts
   3286  27203				   -	       else
   3287  27203				   -	       jmp	checkpokeyplaying
   3288  27203					       endif
   3289  27203				    servicesfxchannels
   3290  27203				   -	       ifconst	PAUSESILENT
   3291  27203				   -	       lda	pausestate
   3292  27203				   -	       beq	servicesfxchannels_1
   3293  27203				   -	       rts
   3294  27203				   -servicesfxchannels_1
   3295  27203					       endif
   3296  27203			a2 ff		       ldx	#255
   3297  27205				    servicesfxchannelsloop
   3298  27205			e8		       inx
   3299  27206					       ifnconst	TIASFXMONO
   3300  27206			e0 02		       cpx	#2
   3301  27208				   -	       else
   3302  27208				   -	       cpx	#1
   3303  27208					       endif
   3304  27208			f0 f8		       beq	servicesfxchannelsdone
   3305  2720a
   3306  2720a			a5 de		       lda	sfxschedulelock	; =1 if locked
   3307  2720c			d0 f4		       bne	servicesfxchannelsdone	; exit if a pointer may be mid-way change
   3308  2720e
   3309  2720e			b5 4e		       lda	sfx1pointlo,x
   3310  27210			85 dc		       sta	inttemp5
   3311  27212			15 50		       ora	sfx1pointhi,x
   3312  27214			f0 ef		       beq	servicesfxchannelsloop
   3313  27216			b5 50		       lda	sfx1pointhi,x
   3314  27218			85 dd		       sta	inttemp6
   3315  2721a
   3316  2721a			b5 58		       lda	sfx1tick,x
   3317  2721c			f0 05		       beq	servicesfx_cont1	; this chunk is over, load the next!
   3318  2721e			d6 58		       dec	sfx1tick,x	; frame countdown is non-zero, subtract one
   3319  27220			4c 05 f2	       jmp	servicesfxchannelsloop
   3320  27223				    servicesfx_cont1
   3321  27223
   3322  27223			a0 01		       ldy	#1	; check to see if they're changing the frame countdown
   3323  27225			b1 dc		       lda	(inttemp5),y
   3324  27227			c9 10		       cmp	#$10
   3325  27229			d0 1b		       bne	servicesfx_cont1a
   3326  2722b			a0 02		       ldy	#2
   3327  2722d			b1 dc		       lda	(inttemp5),y
   3328  2722f			95 56		       sta	sfx1frames,x	; change the frame countdown
   3329  27231			a9 00		       lda	#0
   3330  27233			95 58		       sta	sfx1tick,x
   3331  27235							; advance the sound pointer by 3...
   3332  27235			b5 4e		       lda	sfx1pointlo,x
   3333  27237			18		       clc
   3334  27238			69 03		       adc	#3
   3335  2723a			95 4e		       sta	sfx1pointlo,x
   3336  2723c			b5 50		       lda	sfx1pointhi,x
   3337  2723e			69 00		       adc	#0
   3338  27240			95 50		       sta	sfx1pointhi,x
   3339  27242							; and then fetch another sample for this channel...
   3340  27242			ca		       dex
   3341  27243			4c 05 f2	       jmp	servicesfxchannelsloop
   3342  27246				    servicesfx_cont1a
   3343  27246
   3344  27246			b5 56		       lda	sfx1frames,x	; set the frame countdown for this sound chunk
   3345  27248			95 58		       sta	sfx1tick,x
   3346  2724a
   3347  2724a			b5 52		       lda	sfx1priority,x	; decrease the sound's priority if its non-zero
   3348  2724c			f0 02		       beq	servicesfx_cont2
   3349  2724e			d6 52		       dec	sfx1priority,x
   3350  27250				    servicesfx_cont2
   3351  27250
   3352  27250			a0 00		       ldy	#0	; play the sound
   3353  27252			b1 dc		       lda	(inttemp5),y
   3354  27254			85 d8		       sta	inttemp1
   3355  27256
   3356  27256				   -	       ifconst	MUSICTRACKER
   3357  27256				   -	       lda	sfx1notedata,x
   3358  27256				   -	       beq	exitmusictracker	; exit if this isn't a pitched instrument
   3359  27256				   -	       ldy	#0
   3360  27256				   -	       sty	inttemp2
   3361  27256				   -	       clc
   3362  27256				   -	       adc	(inttemp5),y
   3363  27256				   -	       asl		; x2
   3364  27256				   -	       tay
   3365  27256				   -	       lda	tiatrackeroctavenotes,y
   3366  27256				   -	       sta	AUDC0,x
   3367  27256				   -	       iny
   3368  27256				   -	       lda	tiatrackeroctavenotes,y
   3369  27256				   -	       sta	AUDF0,x
   3370  27256				   -	       ldy	#1
   3371  27256				   -	       jmp	sfxvolumeentrypt
   3372  27256				   -exitmusictracker
   3373  27256				   -	       lda	inttemp1
   3374  27256					       endif		; MUSICTRACKER
   3375  27256
   3376  27256			18		       clc
   3377  27257			75 54		       adc	sfx1poffset,x	; take into account any pitch modification
   3378  27259			95 17		       sta	AUDF0,x
   3379  2725b			c8		       iny
   3380  2725c			b1 dc		       lda	(inttemp5),y
   3381  2725e			95 15		       sta	AUDC0,x
   3382  27260			85 d9		       sta	inttemp2
   3383  27262			c8		       iny
   3384  27263				    sfxvolumeentrypt
   3385  27263				   -	       ifconst	TIAVOLUME
   3386  27263				   -	       lda	tiavolume
   3387  27263				   -	       asl
   3388  27263				   -	       asl
   3389  27263				   -	       asl
   3390  27263				   -	       asl
   3391  27263				   -	       sta	fourbitfadevalueint
   3392  27263					       endif		; TIAVOLUME
   3393  27263			b1 dc		       lda	(inttemp5),y
   3394  27265				   -	       ifconst	TIAVOLUME
   3395  27265				   -	       jsr	fourbitfadeint
   3396  27265					       endif		; TIAVOLUME
   3397  27265			95 19		       sta	AUDV0,x
   3398  27267			c9 10		       cmp	#$10
   3399  27269			b0 19		       bcs	sfxsoundloop	; AUDV0>$0F means the sound is looped while priority is active
   3400  2726b
   3401  2726b			05 d9		       ora	inttemp2
   3402  2726d			05 d8		       ora	inttemp1	; check if F|C|V=0
   3403  2726f			f0 23		       beq	zerosfx	; if so, we're at the end of the sound.
   3404  27271
   3405  27271				    advancesfxpointer
   3406  27271							; advance the pointer to the next sound chunk
   3407  27271			c8		       iny
   3408  27272			84 da		       sty	inttemp3
   3409  27274			18		       clc
   3410  27275			b5 4e		       lda	sfx1pointlo,x
   3411  27277			65 da		       adc	inttemp3
   3412  27279			95 4e		       sta	sfx1pointlo,x
   3413  2727b			b5 50		       lda	sfx1pointhi,x
   3414  2727d			69 00		       adc	#0
   3415  2727f			95 50		       sta	sfx1pointhi,x
   3416  27281			4c 05 f2	       jmp	servicesfxchannelsloop
   3417  27284
   3418  27284				    sfxsoundloop
   3419  27284			48		       pha
   3420  27285			b5 52		       lda	sfx1priority,x
   3421  27287			d0 04		       bne	sfxsoundloop_carryon
   3422  27289			68		       pla		; fix the stack before we go
   3423  2728a			4c 71 f2	       jmp	advancesfxpointer
   3424  2728d				    sfxsoundloop_carryon
   3425  2728d			68		       pla
   3426  2728e			29 f0		       and	#$F0
   3427  27290			4a		       lsr
   3428  27291			4a		       lsr
   3429  27292			4a		       lsr
   3430  27293			4a		       lsr
   3431  27294
   3432  27294				    zerosfx
   3433  27294			95 4e		       sta	sfx1pointlo,x
   3434  27296			95 50		       sta	sfx1pointhi,x
   3435  27298			95 52		       sta	sfx1priority,x
   3436  2729a			4c 05 f2	       jmp	servicesfxchannelsloop
   3437  2729d
   3438  2729d
   3439  2729d				    schedulesfx
   3440  2729d							; called with sfxinstrumentlo=<data sfxinstrumenthi=>data sfxpitchoffset=pitch-offset sfxnoteindex=note index
   3441  2729d			a0 00		       ldy	#0
   3442  2729f				   -	       ifconst	pokeysupport
   3443  2729f				   -	       lda	sfxinstrumenthi
   3444  2729f				   -	       beq	scheduletiasfx	; drums have undefined instrument
   3445  2729f				   -	       lda	(sfxinstrumentlo),y
   3446  2729f				   -	       cmp	#$20	; POKEY?
   3447  2729f				   -	       bne	scheduletiasfx
   3448  2729f				   -	       jmp	schedulepokeysfx
   3449  2729f					       endif
   3450  2729f				    scheduletiasfx
   3451  2729f							;cmp #$10 ; TIA?
   3452  2729f							;beq continuescheduletiasfx
   3453  2729f							; rts ; unhandled!!! 
   3454  2729f				    continuescheduletiasfx
   3455  2729f					       ifnconst	TIASFXMONO
   3456  2729f			a5 50		       lda	sfx1pointhi
   3457  272a1			f0 15		       beq	schedulesfx1	;if channel 1 is idle, use it
   3458  272a3			a5 51		       lda	sfx2pointhi
   3459  272a5			f0 15		       beq	schedulesfx2	;if channel 2 is idle, use it
   3460  272a7							; Both channels are scheduled. 
   3461  272a7			a5 e1		       lda	sfxinstrumenthi
   3462  272a9			f0 06		       beq	skipscheduledrums
   3463  272ab			a0 01		       ldy	#1
   3464  272ad			b1 e0		       lda	(sfxinstrumentlo),y
   3465  272af			d0 01		       bne	interruptsfx
   3466  272b1				    skipscheduledrums
   3467  272b1			60		       rts		; the new sound has 0 priority and both channels are busy. Skip playing it.
   3468  272b2				    interruptsfx
   3469  272b2							;Compare which active sound has a lower priority. We'll interrupt the lower one.
   3470  272b2			a5 52		       lda	sfx1priority
   3471  272b4			c5 53		       cmp	sfx2priority
   3472  272b6			b0 04		       bcs	schedulesfx2
   3473  272b8					       endif		; !TIASFXMONO
   3474  272b8
   3475  272b8				    schedulesfx1
   3476  272b8			a2 00		       ldx	#0	; channel 1
   3477  272ba					       ifnconst	TIASFXMONO
   3478  272ba			f0 02		       beq	skipschedulesfx2
   3479  272bc				    schedulesfx2
   3480  272bc			a2 01		       ldx	#1	; channel 2
   3481  272be				    skipschedulesfx2
   3482  272be					       endif		; !TIASFXMONO
   3483  272be
   3484  272be				   -	       ifconst	MUSICTRACKER
   3485  272be				   -	       lda	sfxnoteindex
   3486  272be				   -	       bpl	skipdrumkitoverride
   3487  272be				   -	       and	#$7F	; subtract 128
   3488  272be				   -	       sec
   3489  272be				   -	       sbc	#4	; drums start at 132, i.e. octave 10
   3490  272be				   -	       asl
   3491  272be				   -	       tay
   3492  272be				   -	       lda	tiadrumkitdefinition,y
   3493  272be				   -	       sta	sfxinstrumentlo
   3494  272be				   -	       iny
   3495  272be				   -	       lda	tiadrumkitdefinition,y
   3496  272be				   -	       sta	sfxinstrumenthi
   3497  272be				   -	       lda	#0
   3498  272be				   -	       sta	sfxnoteindex	; and tell the driver it's a non-pitched instrument
   3499  272be				   -skipdrumkitoverride
   3500  272be					       endif		; MUSICTRACKER
   3501  272be			a0 01		       ldy	#1	; get priority and sound-resolution (in frames)
   3502  272c0			b1 e0		       lda	(sfxinstrumentlo),y
   3503  272c2			95 52		       sta	sfx1priority,x
   3504  272c4			c8		       iny
   3505  272c5			b1 e0		       lda	(sfxinstrumentlo),y
   3506  272c7			95 56		       sta	sfx1frames,x
   3507  272c9			a5 e0		       lda	sfxinstrumentlo
   3508  272cb			18		       clc
   3509  272cc			69 03		       adc	#3
   3510  272ce			95 4e		       sta	sfx1pointlo,x
   3511  272d0			a5 e1		       lda	sfxinstrumenthi
   3512  272d2			69 00		       adc	#0
   3513  272d4			95 50		       sta	sfx1pointhi,x
   3514  272d6			a5 e2		       lda	sfxpitchoffset
   3515  272d8			95 54		       sta	sfx1poffset,x
   3516  272da			a9 00		       lda	#0
   3517  272dc			95 58		       sta	sfx1tick,x
   3518  272de			a5 e3		       lda	sfxnoteindex
   3519  272e0			95 cd		       sta	sfx1notedata,x
   3520  272e2			60		       rts
   3521  272e3
   3522  272e3				    plotsprite
   3523  272e3					       ifnconst	NODRAWWAIT
   3524  272e3				   -	       ifconst	DOUBLEBUFFER
   3525  272e3				   -	       lda	doublebufferstate
   3526  272e3				   -	       bne	skipplotspritewait
   3527  272e3					       endif		; DOUBLEBUFFER
   3528  272e3				   -	       ifconst	DEBUGWAITCOLOR
   3529  272e3				   -	       lda	#$41
   3530  272e3				   -	       sta	BACKGRND
   3531  272e3					       endif
   3532  272e3				    plotspritewait
   3533  272e3			a5 4d		       lda	visibleover
   3534  272e5			d0 fc		       bne	plotspritewait
   3535  272e7				    skipplotspritewait
   3536  272e7				   -	       ifconst	DEBUGWAITCOLOR
   3537  272e7				   -	       lda	#$0
   3538  272e7				   -	       sta	BACKGRND
   3539  272e7					       endif
   3540  272e7					       endif
   3541  272e7
   3542  272e7							;arguments: 
   3543  272e7							; temp1=lo graphicdata 
   3544  272e7							; temp2=hi graphicdata 
   3545  272e7							; temp3=palette | width byte
   3546  272e7							; temp4=x
   3547  272e7							; temp5=y
   3548  272e7							; temp6=mode
   3549  272e7			a5 46		       lda	temp5	;Y position
   3550  272e9			4a		       lsr		; 2 - Divide by 8 or 16
   3551  272ea			4a		       lsr		; 2
   3552  272eb			4a		       lsr		; 2
   3553  272ec					       if	WZONEHEIGHT = 16
   3554  272ec			4a		       lsr		; 2
   3555  272ed					       endif
   3556  272ed
   3557  272ed			aa		       tax
   3558  272ee
   3559  272ee					       ifnconst	NOLIMITCHECKING
   3560  272ee
   3561  272ee							; the next block allows for vertical masking, and ensures we don't overwrite non-DL memory
   3562  272ee
   3563  272ee			c9 0c		       cmp	#WZONECOUNT
   3564  272f0
   3565  272f0			90 0a		       bcc	continueplotsprite1	; the sprite is fully on-screen, so carry on...
   3566  272f2							; otherwise, check to see if the bottom half is in zone 0...
   3567  272f2
   3568  272f2					       if	WZONEHEIGHT = 16
   3569  272f2			c9 0f		       cmp	#15
   3570  272f4				   -	       else
   3571  272f4				   -	       cmp	#31
   3572  272f4					       endif
   3573  272f4
   3574  272f4			d0 05		       bne	exitplotsprite1
   3575  272f6			a2 00		       ldx	#0
   3576  272f8			4c 31 f3	       jmp	continueplotsprite2
   3577  272fb				    exitplotsprite1
   3578  272fb			60		       rts
   3579  272fc
   3580  272fc				    continueplotsprite1
   3581  272fc					       endif
   3582  272fc
   3583  272fc				   -	       ifconst	VSCROLL
   3584  272fc				   -	       ldy	Xx3,x
   3585  272fc				   -	       lda	DLLMEM+11,y
   3586  272fc					       else		; !VSCROLL
   3587  272fc			bd 52 f5	       lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
   3588  272ff					       endif		; !VSCROLL
   3589  272ff				   -	       ifconst	DOUBLEBUFFER
   3590  272ff				   -	       clc
   3591  272ff				   -	       adc	doublebufferdloffset
   3592  272ff					       endif		; DOUBLEBUFFER
   3593  272ff			85 63		       sta	dlpnt
   3594  27301				   -	       ifconst	VSCROLL
   3595  27301				   -	       lda	DLLMEM+10,y
   3596  27301					       else		; !VSCROLL
   3597  27301			bd 46 f5	       lda	DLPOINTH,x
   3598  27304					       endif		; !VSCROLL
   3599  27304				   -	       ifconst	DOUBLEBUFFER
   3600  27304				   -	       adc	#0
   3601  27304					       endif		; DOUBLEBUFFER
   3602  27304			85 64		       sta	dlpnt+1
   3603  27306
   3604  27306							;Create DL entry for upper part of sprite
   3605  27306
   3606  27306			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   3607  27308
   3608  27308				   -	       ifconst	CHECKOVERWRITE
   3609  27308				   -	       cpy	#DLLASTOBJ
   3610  27308				   -	       beq	checkcontinueplotsprite2
   3611  27308				   -continueplotsprite1a
   3612  27308					       endif
   3613  27308
   3614  27308			a5 42		       lda	temp1	; graphic data, lo byte
   3615  2730a			91 63		       sta	(dlpnt),y	;Low byte of data address
   3616  2730c
   3617  2730c					       ifnconst	ATOMICSPRITEUPDATE
   3618  2730c			c8		       iny
   3619  2730d			a5 47		       lda	temp6
   3620  2730f			91 63		       sta	(dlpnt),y
   3621  27311				   -	       else
   3622  27311				   -	       iny
   3623  27311				   -	       sty	temp8
   3624  27311					       endif
   3625  27311
   3626  27311			c8		       iny
   3627  27312
   3628  27312			a5 46		       lda	temp5	;Y position
   3629  27314			29 0f		       and	#(WZONEHEIGHT - 1)
   3630  27316			c9 01		       cmp	#1	; clear carry if our sprite is just in this zone
   3631  27318			05 43		       ora	temp2	; graphic data, hi byte
   3632  2731a			91 63		       sta	(dlpnt),y
   3633  2731c
   3634  2731c			c8		       iny
   3635  2731d			a5 44		       lda	temp3	;palette|width
   3636  2731f			91 63		       sta	(dlpnt),y
   3637  27321
   3638  27321			c8		       iny
   3639  27322			a5 45		       lda	temp4	;Horizontal position
   3640  27324			91 63		       sta	(dlpnt),y
   3641  27326
   3642  27326			c8		       iny
   3643  27327			94 65		       sty	dlend,x
   3644  27329
   3645  27329				   -	       ifconst	ALWAYSTERMINATE
   3646  27329				   -	       iny
   3647  27329				   -	       lda	#0
   3648  27329				   -	       sta	(dlpnt),y
   3649  27329					       endif
   3650  27329
   3651  27329				   -	       ifconst	ATOMICSPRITEUPDATE
   3652  27329				   -	       ldy	temp8
   3653  27329				   -	       lda	temp6
   3654  27329				   -	       sta	(dlpnt),y
   3655  27329					       endif
   3656  27329
   3657  27329				    checkcontinueplotsprite2
   3658  27329
   3659  27329			90 33		       bcc	doneSPDL	;branch if the sprite was fully in the last zone
   3660  2732b
   3661  2732b							;Create DL entry for lower part of sprite
   3662  2732b
   3663  2732b			e8		       inx		;Next region
   3664  2732c
   3665  2732c					       ifnconst	NOLIMITCHECKING
   3666  2732c			e0 0c		       cpx	#WZONECOUNT
   3667  2732e
   3668  2732e			90 01		       bcc	continueplotsprite2	; the second half of the sprite is fully on-screen, so carry on...
   3669  27330			60		       rts
   3670  27331				    continueplotsprite2
   3671  27331					       endif
   3672  27331
   3673  27331				   -	       ifconst	VSCROLL
   3674  27331				   -	       ldy	Xx3,x
   3675  27331				   -	       lda	DLLMEM+11,y
   3676  27331					       else		; !VSCROLL
   3677  27331			bd 52 f5	       lda	DLPOINTL,x	;Get pointer to next DL
   3678  27334					       endif		; !VSCROLL
   3679  27334				   -	       ifconst	DOUBLEBUFFER
   3680  27334				   -	       clc
   3681  27334				   -	       adc	doublebufferdloffset
   3682  27334					       endif		; DOUBLEBUFFER
   3683  27334			85 63		       sta	dlpnt
   3684  27336				   -	       ifconst	VSCROLL
   3685  27336				   -	       lda	DLLMEM+10,y
   3686  27336					       else		; !VSCROLL
   3687  27336			bd 46 f5	       lda	DLPOINTH,x
   3688  27339					       endif		; !VSCROLL
   3689  27339				   -	       ifconst	DOUBLEBUFFER
   3690  27339				   -	       adc	#0
   3691  27339					       endif		; DOUBLEBUFFER
   3692  27339			85 64		       sta	dlpnt+1
   3693  2733b			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   3694  2733d
   3695  2733d				   -	       ifconst	CHECKOVERWRITE
   3696  2733d				   -	       cpy	#DLLASTOBJ
   3697  2733d				   -	       bne	continueplotsprite2a
   3698  2733d				   -	       rts
   3699  2733d				   -continueplotsprite2a
   3700  2733d					       endif
   3701  2733d
   3702  2733d			a5 42		       lda	temp1	; graphic data, lo byte
   3703  2733f			91 63		       sta	(dlpnt),y
   3704  27341
   3705  27341					       ifnconst	ATOMICSPRITEUPDATE
   3706  27341			c8		       iny
   3707  27342			a5 47		       lda	temp6
   3708  27344			91 63		       sta	(dlpnt),y
   3709  27346				   -	       else
   3710  27346				   -	       iny
   3711  27346				   -	       sty	temp8
   3712  27346					       endif
   3713  27346
   3714  27346			c8		       iny
   3715  27347
   3716  27347			a5 46		       lda	temp5	;Y position
   3717  27349			0b 0f		       anc	#(WZONEHEIGHT - 1)	; undocumented. A=A&IMM, then move bit 7 into carry
   3718  2734b			05 43		       ora	temp2	; graphic data, hi byte
   3719  2734d			e9 0f		       sbc	#(WZONEHEIGHT-1)	; start at the DMA hole. -1 because carry is clear
   3720  2734f			91 63		       sta	(dlpnt),y
   3721  27351
   3722  27351			c8		       iny
   3723  27352
   3724  27352			a5 44		       lda	temp3	;palette|width
   3725  27354			91 63		       sta	(dlpnt),y
   3726  27356
   3727  27356			c8		       iny
   3728  27357
   3729  27357			a5 45		       lda	temp4	;Horizontal position
   3730  27359			91 63		       sta	(dlpnt),y
   3731  2735b
   3732  2735b			c8		       iny
   3733  2735c			94 65		       sty	dlend,x
   3734  2735e
   3735  2735e				   -	       ifconst	ALWAYSTERMINATE
   3736  2735e				   -	       iny
   3737  2735e				   -	       lda	#0
   3738  2735e				   -	       sta	(dlpnt),y
   3739  2735e					       endif
   3740  2735e
   3741  2735e				   -	       ifconst	ATOMICSPRITEUPDATE
   3742  2735e				   -	       ldy	temp8
   3743  2735e				   -	       lda	temp6
   3744  2735e				   -	       sta	(dlpnt),y
   3745  2735e					       endif
   3746  2735e
   3747  2735e				    doneSPDL
   3748  2735e			60		       rts
   3749  2735f
   3750  2735f				   -	       ifconst	VSCROLL
   3751  2735f				   -			; x3 table for fast DLL parsing
   3752  2735f				   -Xx3
   3753  2735f				   -	       .byte	0,3,6,9,12,15,18,21,24,27
   3754  2735f				   -	       .byte	30,33,36,39,42,45,48,51,54,57
   3755  2735f				   -	       .byte	60,63,66,69,72,75,78,81,84,87
   3756  2735f				   -maskscrollsprite
   3757  2735f				   -	       .byte	$00,%11000000,($D0+WZONEHEIGHT),0,160	; 5*2 + 32*3 = 106 cycles
   3758  2735f				   -	       .byte	$00,1,($D0+WZONEHEIGHT),160	; 4*2 + 31*3 = 101 cycles 
   3759  2735f				   -	       .byte	$00,1,($D0+WZONEHEIGHT),160	; 4*2 + 31*3 = 101 cycles 
   3760  2735f				   -	       .byte	$00,1,($D0+WZONEHEIGHT),160	; 4*2 + 31*3 = 101 cycles 
   3761  2735f				   -	       .byte	$00,%01000000,($D0+WZONEHEIGHT),16,160	; 5*2 + 16*3 =  58 cycles
   3762  2735f				   -			; MAX	============ 467 cycles
   3763  2735f				   -			; MIN	============  59 cycles
   3764  2735f				   -maskscrollspriteend
   3765  2735f					       endif		; VSCROLL
   3766  2735f
   3767  2735f				    lockzonex
   3768  2735f				   -	       ifconst	ZONELOCKS
   3769  2735f				   -	       ldy	dlend,x
   3770  2735f				   -	       cpy	#DLLASTOBJ
   3771  2735f				   -	       beq	lockzonexreturn	; the zone is either stuffed or locked. abort!
   3772  2735f				   -	       lda	DLPOINTL,x
   3773  2735f				   -	       ifconst	DOUBLEBUFFER
   3774  2735f				   -	       clc
   3775  2735f				   -	       adc	doublebufferdloffset
   3776  2735f				   -	       endif		; DOUBLEBUFFER
   3777  2735f				   -	       sta	dlpnt
   3778  2735f				   -	       lda	DLPOINTH,x
   3779  2735f				   -	       ifconst	DOUBLEBUFFER
   3780  2735f				   -	       adc	#0
   3781  2735f				   -	       endif		; DOUBLEBUFFER
   3782  2735f				   -	       sta	dlpnt+1
   3783  2735f				   -	       iny
   3784  2735f				   -	       lda	#0
   3785  2735f				   -	       sta	(dlpnt),y
   3786  2735f				   -	       dey
   3787  2735f				   -	       tya
   3788  2735f				   -	       ldy	#(DLLASTOBJ-1)
   3789  2735f				   -	       sta	(dlpnt),y
   3790  2735f				   -	       iny
   3791  2735f				   -	       sty	dlend,x
   3792  2735f				   -lockzonexreturn
   3793  2735f				   -	       rts
   3794  2735f					       endif		; ZONELOCKS
   3795  2735f				    unlockzonex
   3796  2735f				   -	       ifconst	ZONELOCKS
   3797  2735f				   -	       ldy	dlend,x
   3798  2735f				   -	       cpy	#DLLASTOBJ
   3799  2735f				   -	       bne	unlockzonexreturn	; if the zone isn't stuffed, it's not locked. abort!
   3800  2735f				   -	       lda	DLPOINTL,x
   3801  2735f				   -	       ifconst	DOUBLEBUFFER
   3802  2735f				   -	       clc
   3803  2735f				   -	       adc	doublebufferdloffset
   3804  2735f				   -	       endif		; DOUBLEBUFFER
   3805  2735f				   -	       sta	dlpnt
   3806  2735f				   -	       lda	DLPOINTH,x
   3807  2735f				   -	       ifconst	DOUBLEBUFFER
   3808  2735f				   -	       adc	#0
   3809  2735f				   -	       endif		; DOUBLEBUFFER
   3810  2735f				   -	       sta	dlpnt+1
   3811  2735f				   -	       dey
   3812  2735f				   -	       lda	(dlpnt),y
   3813  2735f				   -	       tay
   3814  2735f				   -	       sty	dlend,x
   3815  2735f				   -unlockzonexreturn
   3816  2735f					       endif		; ZONELOCKS
   3817  2735f			60		       rts
   3818  27360
   3819  27360				    plotcharloop
   3820  27360							; ** read from a data indirectly pointed to from temp8,temp9
   3821  27360							; ** format is: lo_data, hi_data, palette|width, x, y
   3822  27360							; ** format ends with lo_data | hi_data = 0
   3823  27360
   3824  27360				   -	       ifconst	DOUBLEBUFFER
   3825  27360				   -	       lda	doublebufferstate
   3826  27360				   -	       bne	skipplotcharloopwait
   3827  27360					       endif		; DOUBLEBUFFER
   3828  27360				   -	       ifconst	DEBUGWAITCOLOR
   3829  27360				   -	       lda	#$61
   3830  27360				   -	       sta	BACKGRND
   3831  27360					       endif
   3832  27360				    plotcharloopwait
   3833  27360			a5 4d		       lda	visibleover
   3834  27362			d0 fc		       bne	plotcharloopwait
   3835  27364				   -	       ifconst	DEBUGWAITCOLOR
   3836  27364				   -	       lda	#0
   3837  27364				   -	       sta	BACKGRND
   3838  27364					       endif
   3839  27364				    skipplotcharloopwait
   3840  27364				    plotcharlooploop
   3841  27364			a0 00		       ldy	#0
   3842  27366			b1 49		       lda	(temp8),y
   3843  27368			85 42		       sta	temp1
   3844  2736a			c8		       iny
   3845  2736b			b1 49		       lda	(temp8),y
   3846  2736d			85 43		       sta	temp2
   3847  2736f			05 42		       ora	temp1
   3848  27371			d0 01		       bne	plotcharloopcontinue
   3849  27373							;the pointer=0, so return
   3850  27373			60		       rts
   3851  27374				    plotcharloopcontinue
   3852  27374			c8		       iny
   3853  27375			b1 49		       lda	(temp8),y
   3854  27377			85 44		       sta	temp3
   3855  27379			c8		       iny
   3856  2737a			b1 49		       lda	(temp8),y
   3857  2737c			85 45		       sta	temp4
   3858  2737e			c8		       iny
   3859  2737f			b1 49		       lda	(temp8),y
   3860  27381							;sta temp5 ; not needed with our late entry.
   3861  27381			20 9a f3	       jsr	plotcharactersskipentry
   3862  27384			a5 49		       lda	temp8
   3863  27386			18		       clc
   3864  27387			69 05		       adc	#5
   3865  27389			85 49		       sta	temp8
   3866  2738b			a5 4a		       lda	temp9
   3867  2738d			69 00		       adc	#0
   3868  2738f			85 4a		       sta	temp9
   3869  27391			4c 64 f3	       jmp	plotcharlooploop
   3870  27394
   3871  27394				    plotcharacters
   3872  27394				   -	       ifconst	DOUBLEBUFFER
   3873  27394				   -	       lda	doublebufferstate
   3874  27394				   -	       bne	skipplotcharacterswait
   3875  27394					       endif		; DOUBLEBUFFER
   3876  27394				   -	       ifconst	DEBUGWAITCOLOR
   3877  27394				   -	       lda	#$41
   3878  27394				   -	       sta	BACKGRND
   3879  27394					       endif
   3880  27394				    plotcharacterswait
   3881  27394			a5 4d		       lda	visibleover
   3882  27396			d0 fc		       bne	plotcharacterswait
   3883  27398				   -	       ifconst	DEBUGWAITCOLOR
   3884  27398				   -	       sta	BACKGRND
   3885  27398					       endif
   3886  27398				    skipplotcharacterswait
   3887  27398							;arguments: 
   3888  27398							; temp1=lo charactermap
   3889  27398							; temp2=hi charactermap
   3890  27398							; temp3=palette | width byte
   3891  27398							; temp4=x
   3892  27398							; temp5=y
   3893  27398
   3894  27398			a5 46		       lda	temp5	;Y position
   3895  2739a
   3896  2739a				    plotcharactersskipentry
   3897  2739a
   3898  2739a							;ifconst ZONEHEIGHT
   3899  2739a							; if ZONEHEIGHT = 16
   3900  2739a							; and #$0F
   3901  2739a							; endif
   3902  2739a							; if ZONEHEIGHT = 8
   3903  2739a							; and #$1F
   3904  2739a							; endif
   3905  2739a							;else
   3906  2739a							; and #$0F
   3907  2739a							;endif
   3908  2739a
   3909  2739a			aa		       tax
   3910  2739b
   3911  2739b				   -	       ifconst	VSCROLL
   3912  2739b				   -	       ldy	Xx3,x
   3913  2739b				   -	       lda	DLLMEM+11,y
   3914  2739b					       else		; !VSCROLL
   3915  2739b			bd 52 f5	       lda	DLPOINTL,x	;Get pointer to DL that the characters are in
   3916  2739e					       endif		; !VSCROLL
   3917  2739e				   -	       ifconst	DOUBLEBUFFER
   3918  2739e				   -	       clc
   3919  2739e				   -	       adc	doublebufferdloffset
   3920  2739e					       endif		; DOUBLEBUFFER
   3921  2739e			85 63		       sta	dlpnt
   3922  273a0				   -	       ifconst	VSCROLL
   3923  273a0				   -	       lda	DLLMEM+10,y
   3924  273a0					       else		; !VSCROLL
   3925  273a0			bd 46 f5	       lda	DLPOINTH,x
   3926  273a3					       endif		; !VSCROLL
   3927  273a3				   -	       ifconst	DOUBLEBUFFER
   3928  273a3				   -	       adc	#0
   3929  273a3					       endif		; DOUBLEBUFFER
   3930  273a3			85 64		       sta	dlpnt+1
   3931  273a5
   3932  273a5							;Create DL entry for the characters
   3933  273a5
   3934  273a5			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   3935  273a7
   3936  273a7				   -	       ifconst	CHECKOVERWRITE
   3937  273a7				   -	       cpy	#DLLASTOBJ
   3938  273a7				   -	       bne	continueplotcharacters
   3939  273a7				   -	       rts
   3940  273a7				   -continueplotcharacters
   3941  273a7					       endif
   3942  273a7
   3943  273a7			a5 42		       lda	temp1	; character map data, lo byte
   3944  273a9			91 63		       sta	(dlpnt),y	;(1) store low address
   3945  273ab
   3946  273ab			c8		       iny
   3947  273ac			ad 06 21	       lda	charactermode
   3948  273af			91 63		       sta	(dlpnt),y	;(2) store mode
   3949  273b1
   3950  273b1			c8		       iny
   3951  273b2			a5 43		       lda	temp2	; character map, hi byte
   3952  273b4			91 63		       sta	(dlpnt),y	;(3) store high address
   3953  273b6
   3954  273b6			c8		       iny
   3955  273b7			a5 44		       lda	temp3	;palette|width
   3956  273b9			91 63		       sta	(dlpnt),y	;(4) store palette|width
   3957  273bb
   3958  273bb			c8		       iny
   3959  273bc			a5 45		       lda	temp4	;Horizontal position
   3960  273be			91 63		       sta	(dlpnt),y	;(5) store horizontal position
   3961  273c0
   3962  273c0			c8		       iny
   3963  273c1			94 65		       sty	dlend,x	; save display list end byte
   3964  273c3			60		       rts
   3965  273c4
   3966  273c4
   3967  273c4					       ifconst	plotvalueonscreen
   3968  273c4				    plotcharacterslive
   3969  273c4							; a version of plotcharacters that draws live and minimally disrupts the screen...
   3970  273c4
   3971  273c4							;arguments: 
   3972  273c4							; temp1=lo charactermap
   3973  273c4							; temp2=hi charactermap
   3974  273c4							; temp3=palette | width byte
   3975  273c4							; temp4=x
   3976  273c4							; temp5=y
   3977  273c4
   3978  273c4			a5 46		       lda	temp5	;Y position
   3979  273c6
   3980  273c6			aa		       tax
   3981  273c7
   3982  273c7				   -	       ifconst	VSCROLL
   3983  273c7				   -	       ldy	Xx3,x
   3984  273c7				   -	       lda	DLLMEM+11,y
   3985  273c7					       else		; !VSCROLL
   3986  273c7			bd 52 f5	       lda	DLPOINTL,x	;Get pointer to DL that the characters are in
   3987  273ca					       endif		; !VSCROLL
   3988  273ca				   -	       ifconst	DOUBLEBUFFER
   3989  273ca				   -	       clc
   3990  273ca				   -	       adc	doublebufferdloffset
   3991  273ca					       endif		; DOUBLEBUFFER
   3992  273ca			85 63		       sta	dlpnt
   3993  273cc				   -	       ifconst	VSCROLL
   3994  273cc				   -	       lda	DLLMEM+10,y
   3995  273cc					       else		; !VSCROLL
   3996  273cc			bd 46 f5	       lda	DLPOINTH,x
   3997  273cf					       endif		; !VSCROLL
   3998  273cf				   -	       ifconst	DOUBLEBUFFER
   3999  273cf				   -	       adc	#0
   4000  273cf					       endif		; DOUBLEBUFFER
   4001  273cf			85 64		       sta	dlpnt+1
   4002  273d1
   4003  273d1							;Create DL entry for the characters
   4004  273d1
   4005  273d1			b4 65		       ldy	dlend,x	;Get the index to the end of this DL
   4006  273d3
   4007  273d3				   -	       ifconst	CHECKOVERWRITE
   4008  273d3				   -	       cpy	#DLLASTOBJ
   4009  273d3				   -	       bne	continueplotcharacterslive
   4010  273d3				   -	       rts
   4011  273d3				   -continueplotcharacterslive
   4012  273d3					       endif
   4013  273d3
   4014  273d3			a5 42		       lda	temp1	; character map data, lo byte
   4015  273d5			91 63		       sta	(dlpnt),y	;(1) store low address
   4016  273d7
   4017  273d7			c8		       iny
   4018  273d8							; we don't add the second byte yet, since the charmap could briefly
   4019  273d8							; render without a proper character map address, width, or position.
   4020  273d8			ad 06 21	       lda	charactermode
   4021  273db			91 63		       sta	(dlpnt),y	;(2) store mode
   4022  273dd
   4023  273dd			c8		       iny
   4024  273de			a5 43		       lda	temp2	; character map, hi byte
   4025  273e0			91 63		       sta	(dlpnt),y	;(3) store high address
   4026  273e2
   4027  273e2			c8		       iny
   4028  273e3			a5 44		       lda	temp3	;palette|width
   4029  273e5			91 63		       sta	(dlpnt),y	;(4) store palette|width
   4030  273e7
   4031  273e7			c8		       iny
   4032  273e8			a5 45		       lda	temp4	;Horizontal position
   4033  273ea			91 63		       sta	(dlpnt),y	;(5) store horizontal position
   4034  273ec
   4035  273ec			c8		       iny
   4036  273ed			94 65		       sty	dlend,x	; save display list end byte
   4037  273ef
   4038  273ef			60		       rts
   4039  273f0					       endif		;plotcharacterslive
   4040  273f0
   4041  273f0				   -	       ifconst	USED_PLOTVALUE
   4042  273f0				   -plotvalue
   4043  273f0				   -			; calling 7800basic command:
   4044  273f0				   -			; plotvalue digit_gfx palette variable/data number_of_digits screen_x screen_y
   4045  273f0				   -			; ...displays the variable as BCD digits
   4046  273f0				   -			;
   4047  273f0				   -			; asm sub arguments: 
   4048  273f0				   -			; temp1=lo charactermap
   4049  273f0				   -			; temp2=hi charactermap
   4050  273f0				   -			; temp3=palette | width byte
   4051  273f0				   -			; temp4=x
   4052  273f0				   -			; temp5=y
   4053  273f0				   -			; temp6=number of digits
   4054  273f0				   -			; temp7=lo variable
   4055  273f0				   -			; temp8=hi variable
   4056  273f0				   -			; temp9=character mode
   4057  273f0				   -
   4058  273f0				   -plotdigitcount =	temp6
   4059  273f0				   -
   4060  273f0				   -	       ifconst	ZONELOCKS
   4061  273f0				   -	       ldx	temp5
   4062  273f0				   -	       ldy	dlend,x
   4063  273f0				   -	       cpy	#DLLASTOBJ
   4064  273f0				   -	       bne	carryonplotvalue
   4065  273f0				   -	       rts
   4066  273f0				   -carryonplotvalue
   4067  273f0				   -	       endif
   4068  273f0				   -
   4069  273f0				   -	       lda	#0
   4070  273f0				   -	       tay
   4071  273f0				   -	       ldx	valbufend
   4072  273f0				   -
   4073  273f0				   -	       lda	plotdigitcount
   4074  273f0				   -	       and	#1
   4075  273f0				   -	       beq	pvnibble2char
   4076  273f0				   -	       lda	#0
   4077  273f0				   -	       sta	VALBUFFER,x	; just in case we skip this digit
   4078  273f0				   -	       beq	pvnibble2char_skipnibble
   4079  273f0				   -
   4080  273f0				   -pvnibble2char
   4081  273f0				   -			; high nibble...
   4082  273f0				   -	       lda	(temp7),y
   4083  273f0				   -	       and	#$f0
   4084  273f0				   -	       lsr
   4085  273f0				   -	       lsr
   4086  273f0				   -	       lsr
   4087  273f0				   -	       ifnconst	DOUBLEWIDE	; multiply value by 2 for double-width
   4088  273f0				   -	       lsr
   4089  273f0				   -	       endif
   4090  273f0				   -
   4091  273f0				   -	       clc
   4092  273f0				   -	       adc	temp1	; add the offset to character graphics to our value
   4093  273f0				   -	       sta	VALBUFFER,x
   4094  273f0				   -	       inx
   4095  273f0				   -	       dec	plotdigitcount
   4096  273f0				   -
   4097  273f0				   -pvnibble2char_skipnibble
   4098  273f0				   -			; low nibble...
   4099  273f0				   -	       lda	(temp7),y
   4100  273f0				   -	       and	#$0f
   4101  273f0				   -	       ifconst	DOUBLEWIDE	; multiply value by 2 for double-width
   4102  273f0				   -	       asl
   4103  273f0				   -	       endif
   4104  273f0				   -	       clc
   4105  273f0				   -	       adc	temp1	; add the offset to character graphics to our value
   4106  273f0				   -	       sta	VALBUFFER,x
   4107  273f0				   -	       inx
   4108  273f0				   -	       iny
   4109  273f0				   -
   4110  273f0				   -	       dec	plotdigitcount
   4111  273f0				   -	       bne	pvnibble2char
   4112  273f0				   -
   4113  273f0				   -			;point to the start of our valuebuffer
   4114  273f0				   -	       clc
   4115  273f0				   -	       lda	#<VALBUFFER
   4116  273f0				   -	       adc	valbufend
   4117  273f0				   -	       sta	temp1
   4118  273f0				   -	       lda	#>VALBUFFER
   4119  273f0				   -	       adc	#0
   4120  273f0				   -	       sta	temp2
   4121  273f0				   -
   4122  273f0				   -			;advance valbufend to the end of our value buffer
   4123  273f0				   -	       stx	valbufend
   4124  273f0				   -
   4125  273f0				   -	       ifnconst	plotvalueonscreen
   4126  273f0				   -	       jmp	plotcharacters
   4127  273f0				   -	       else
   4128  273f0				   -	       jmp	plotcharacterslive
   4129  273f0				   -	       endif
   4130  273f0				   -
   4131  273f0					       endif		; USED_PLOTVALUE
   4132  273f0
   4133  273f0
   4134  273f0				   -	       ifconst	USED_PLOTVALUEEXTRA
   4135  273f0				   -plotdigitcount =	temp6
   4136  273f0				   -plotvalueextra
   4137  273f0				   -			; calling 7800basic command:
   4138  273f0				   -			; plotvalue digit_gfx palette variable/data number_of_digits screen_x screen_y
   4139  273f0				   -			; ...displays the variable as BCD digits
   4140  273f0				   -			;
   4141  273f0				   -			; asm sub arguments: 
   4142  273f0				   -			; temp1=lo charactermap
   4143  273f0				   -			; temp2=hi charactermap
   4144  273f0				   -			; temp3=palette | width byte
   4145  273f0				   -			; temp4=x
   4146  273f0				   -			; temp5=y
   4147  273f0				   -			; temp6=number of digits
   4148  273f0				   -			; temp7=lo variable
   4149  273f0				   -			; temp8=hi variable
   4150  273f0				   -
   4151  273f0				   -	       lda	#0
   4152  273f0				   -	       tay
   4153  273f0				   -	       ldx	valbufend
   4154  273f0				   -	       ifnconst	plotvalueonscreen
   4155  273f0				   -	       sta	VALBUFFER,x
   4156  273f0				   -	       endif
   4157  273f0				   -
   4158  273f0				   -	       lda	plotdigitcount
   4159  273f0				   -	       and	#1
   4160  273f0				   -
   4161  273f0				   -	       bne	pvnibble2char_skipnibbleextra
   4162  273f0				   -
   4163  273f0				   -pvnibble2charextra
   4164  273f0				   -			; high nibble...
   4165  273f0				   -	       lda	(temp7),y
   4166  273f0				   -	       and	#$f0
   4167  273f0				   -	       lsr
   4168  273f0				   -	       lsr
   4169  273f0				   -	       ifnconst	DOUBLEWIDE	; multiply value by 2 for double-width
   4170  273f0				   -	       lsr
   4171  273f0				   -	       endif
   4172  273f0				   -	       clc
   4173  273f0				   -	       adc	temp1	; add the offset to character graphics to our value
   4174  273f0				   -	       sta	VALBUFFER,x
   4175  273f0				   -	       inx
   4176  273f0				   -
   4177  273f0				   -			; second half of the digit
   4178  273f0				   -	       clc
   4179  273f0				   -	       adc	#1
   4180  273f0				   -	       sta	VALBUFFER,x
   4181  273f0				   -	       inx
   4182  273f0				   -	       dec	plotdigitcount
   4183  273f0				   -
   4184  273f0				   -pvnibble2char_skipnibbleextra
   4185  273f0				   -			; low nibble...
   4186  273f0				   -	       lda	(temp7),y
   4187  273f0				   -	       and	#$0f
   4188  273f0				   -	       ifconst	DOUBLEWIDE	; multiply value by 2 for double-width
   4189  273f0				   -	       asl
   4190  273f0				   -	       endif
   4191  273f0				   -	       asl
   4192  273f0				   -
   4193  273f0				   -	       clc
   4194  273f0				   -	       adc	temp1	; add the offset to character graphics to our value
   4195  273f0				   -	       sta	VALBUFFER,x
   4196  273f0				   -	       inx
   4197  273f0				   -
   4198  273f0				   -	       clc
   4199  273f0				   -	       adc	#1
   4200  273f0				   -	       sta	VALBUFFER,x
   4201  273f0				   -	       inx
   4202  273f0				   -	       iny
   4203  273f0				   -
   4204  273f0				   -	       dec	plotdigitcount
   4205  273f0				   -	       bne	pvnibble2charextra
   4206  273f0				   -
   4207  273f0				   -			;point to the start of our valuebuffer
   4208  273f0				   -	       clc
   4209  273f0				   -	       lda	#<VALBUFFER
   4210  273f0				   -	       adc	valbufend
   4211  273f0				   -	       sta	temp1
   4212  273f0				   -	       lda	#>VALBUFFER
   4213  273f0				   -	       adc	#0
   4214  273f0				   -	       sta	temp2
   4215  273f0				   -
   4216  273f0				   -			;advance valbufend to the end of our value buffer
   4217  273f0				   -	       stx	valbufend
   4218  273f0				   -
   4219  273f0				   -	       ifnconst	plotvalueonscreen
   4220  273f0				   -	       jmp	plotcharacters
   4221  273f0				   -	       else
   4222  273f0				   -	       jmp	plotcharacterslive
   4223  273f0				   -	       endif
   4224  273f0					       endif		; USED_PLOTVALUEEXTRA
   4225  273f0
   4226  273f0				    boxcollision
   4227  273f0				   -	       ifconst	BOXCOLLISION
   4228  273f0				   -			; the worst case cycle-time for the code below is 43 cycles.
   4229  273f0				   -			; unfortunately, prior to getting here we've burned 44 cycles in argument setup. eep!
   4230  273f0				   -
   4231  273f0				   -			;__boxx1 = accumulator
   4232  273f0				   -			;__boxy1 = y
   4233  273f0				   -__boxw1    =	temp3
   4234  273f0				   -__boxh1    =	temp4
   4235  273f0				   -
   4236  273f0				   -__boxx2    =	temp5
   4237  273f0				   -__boxy2    =	temp6
   4238  273f0				   -__boxw2    =	temp7
   4239  273f0				   -__boxh2    =	temp8
   4240  273f0				   -
   4241  273f0				   -DoXCollisionCheck
   4242  273f0				   -			;lda __boxx1 ; skipped. already in the accumulator
   4243  273f0				   -	       cmp	__boxx2	;3
   4244  273f0				   -	       bcs	X1isbiggerthanX2	;2/3
   4245  273f0				   -X2isbiggerthanX1
   4246  273f0				   -			; carry is clear
   4247  273f0				   -	       adc	__boxw1	;3
   4248  273f0				   -	       cmp	__boxx2	;3
   4249  273f0				   -	       bcs	DoYCollisionCheck	;3/2
   4250  273f0				   -	       rts		;6 - carry clear, no collision
   4251  273f0				   -X1isbiggerthanX2
   4252  273f0				   -	       clc		;2
   4253  273f0				   -	       sbc	__boxw2	;3
   4254  273f0				   -	       cmp	__boxx2	;3
   4255  273f0				   -	       bcs	noboxcollision	;3/2
   4256  273f0				   -DoYCollisionCheck
   4257  273f0				   -	       tya		; 2 ; use to be "lda __boxy1"
   4258  273f0				   -	       cmp	__boxy2	;3
   4259  273f0				   -	       bcs	Y1isbiggerthanY2	;3/2
   4260  273f0				   -Y2isbiggerthanY1
   4261  273f0				   -			; carry is clear
   4262  273f0				   -	       adc	__boxh1	;3
   4263  273f0				   -	       cmp	__boxy2	;3
   4264  273f0				   -	       rts		;6 
   4265  273f0				   -Y1isbiggerthanY2
   4266  273f0				   -	       clc		;2
   4267  273f0				   -	       sbc	__boxh2	;3
   4268  273f0				   -	       cmp	__boxy2	;3
   4269  273f0				   -	       bcs	noboxcollision	;3/2
   4270  273f0				   -yesboxcollision
   4271  273f0				   -	       sec		;2
   4272  273f0				   -	       rts		;6
   4273  273f0				   -noboxcollision
   4274  273f0				   -	       clc		;2
   4275  273f0				   -	       rts		;6
   4276  273f0					       endif		; BOXCOLLISION
   4277  273f0
   4278  273f0				    randomize
   4279  273f0			a5 40		       lda	rand
   4280  273f2			4a		       lsr
   4281  273f3			26 41		       rol	rand16
   4282  273f5			90 02		       bcc	noeor
   4283  273f7			49 b4		       eor	#$B4
   4284  273f9				    noeor
   4285  273f9			85 40		       sta	rand
   4286  273fb			45 41		       eor	rand16
   4287  273fd			60		       rts
   4288  273fe
   4289  273fe							; *** bcd conversion routine courtesy Omegamatrix
   4290  273fe							; *** http://atariage.com/forums/blog/563/entry-10832-hex-to-bcd-conversion-0-99/
   4291  273fe				   -	       ifconst	.calledfunction_converttobcd
   4292  273fe				   -converttobcd
   4293  273fe				   -			;value to convert is in the accumulator
   4294  273fe				   -	       sta	temp1
   4295  273fe				   -	       lsr
   4296  273fe				   -	       adc	temp1
   4297  273fe				   -	       ror
   4298  273fe				   -	       lsr
   4299  273fe				   -	       lsr
   4300  273fe				   -	       adc	temp1
   4301  273fe				   -	       ror
   4302  273fe				   -	       adc	temp1
   4303  273fe				   -	       ror
   4304  273fe				   -	       lsr
   4305  273fe				   -	       and	#$3C
   4306  273fe				   -	       sta	temp2
   4307  273fe				   -	       lsr
   4308  273fe				   -	       adc	temp2
   4309  273fe				   -	       adc	temp1
   4310  273fe				   -	       rts		; return the result in the accumulator
   4311  273fe					       endif		; .calledfunction_converttobcd
   4312  273fe
   4313  273fe				   -	       ifconst	.calledfunction_mul8
   4314  273fe				   -			; Y and A contain multiplicands, result in A
   4315  273fe				   -mul8
   4316  273fe				   -	       sty	temp1
   4317  273fe				   -	       sta	temp2
   4318  273fe				   -	       lda	#0
   4319  273fe				   -reptmul8
   4320  273fe				   -	       lsr	temp2
   4321  273fe				   -	       bcc	skipmul8
   4322  273fe				   -	       clc
   4323  273fe				   -	       adc	temp1
   4324  273fe				   -			;bcs donemul8 might save cycles?
   4325  273fe				   -skipmul8
   4326  273fe				   -			;beq donemul8 might save cycles?
   4327  273fe				   -	       asl	temp1
   4328  273fe				   -	       bne	reptmul8
   4329  273fe				   -donemul8
   4330  273fe				   -	       rts
   4331  273fe					       endif		; .calledfunction_mul8
   4332  273fe
   4333  273fe				   -	       ifconst	.calledfunction_div8
   4334  273fe				   -div8
   4335  273fe				   -			; A=numerator Y=denominator, result in A
   4336  273fe				   -	       cpy	#2
   4337  273fe				   -	       bcc	div8end+1	;div by 0 = bad, div by 1=no calc needed, so bail out
   4338  273fe				   -	       sty	temp1
   4339  273fe				   -	       ldy	#$ff
   4340  273fe				   -div8loop
   4341  273fe				   -	       sbc	temp1
   4342  273fe				   -	       iny
   4343  273fe				   -	       bcs	div8loop
   4344  273fe				   -div8end
   4345  273fe				   -	       tya
   4346  273fe				   -			; result in A
   4347  273fe				   -	       rts
   4348  273fe					       endif		; .calledfunction_div8
   4349  273fe
   4350  273fe				   -	       ifconst	.calledfunction_mul16
   4351  273fe				   -			; Y and A contain multiplicands, result in temp2,A=low, temp1=high
   4352  273fe				   -mul16
   4353  273fe				   -	       sty	temp1
   4354  273fe				   -	       sta	temp2
   4355  273fe				   -
   4356  273fe				   -	       lda	#0
   4357  273fe				   -	       ldx	#8
   4358  273fe				   -	       lsr	temp1
   4359  273fe				   -mul16_1
   4360  273fe				   -	       bcc	mul16_2
   4361  273fe				   -	       clc
   4362  273fe				   -	       adc	temp2
   4363  273fe				   -mul16_2
   4364  273fe				   -	       ror
   4365  273fe				   -	       ror	temp1
   4366  273fe				   -	       dex
   4367  273fe				   -	       bne	mul16_1
   4368  273fe				   -	       sta	temp2
   4369  273fe				   -	       rts
   4370  273fe					       endif		; .calledfunction_mul16
   4371  273fe
   4372  273fe				   -	       ifconst	.calledfunction_div16
   4373  273fe				   -			; div int/int
   4374  273fe				   -			; numerator in A, denom in temp1
   4375  273fe				   -			; returns with quotient in A, remainder in temp1
   4376  273fe				   -div16
   4377  273fe				   -	       sta	temp2
   4378  273fe				   -	       sty	temp1
   4379  273fe				   -	       lda	#0
   4380  273fe				   -	       ldx	#8
   4381  273fe				   -	       asl	temp2
   4382  273fe				   -div16_1
   4383  273fe				   -	       rol
   4384  273fe				   -	       cmp	temp1
   4385  273fe				   -	       bcc	div16_2
   4386  273fe				   -	       sbc	temp1
   4387  273fe				   -div16_2
   4388  273fe				   -	       rol	temp2
   4389  273fe				   -	       dex
   4390  273fe				   -	       bne	div16_1
   4391  273fe				   -	       sta	temp1
   4392  273fe				   -	       lda	temp2
   4393  273fe				   -	       rts
   4394  273fe					       endif		; .calledfunction_div16
   4395  273fe
   4396  273fe					       ifconst	bankswitchmode
   4397  273fe				    BS_jsr
   4398  273fe				   -	       ifconst	dumpbankswitch
   4399  273fe				   -	       sta	dumpbankswitch
   4400  273fe					       endif
   4401  273fe				   -	       ifconst	MCPDEVCART
   4402  273fe				   -	       ora	#$18
   4403  273fe				   -	       sta	$3000
   4404  273fe					       else
   4405  273fe			8d 00 80	       sta	$8000
   4406  27401					       endif
   4407  27401			68		       pla
   4408  27402			aa		       tax
   4409  27403			68		       pla
   4410  27404			60		       rts
   4411  27405
   4412  27405				    BS_return
   4413  27405			68		       pla		; bankswitch bank
   4414  27406				   -	       ifconst	dumpbankswitch
   4415  27406				   -	       sta	dumpbankswitch
   4416  27406					       endif
   4417  27406				   -	       ifconst	BANKRAM
   4418  27406				   -	       sta	currentbank
   4419  27406				   -	       ora	currentrambank
   4420  27406					       endif
   4421  27406				   -	       ifconst	MCPDEVCART
   4422  27406				   -	       ora	#$18
   4423  27406				   -	       sta	$3000
   4424  27406					       else
   4425  27406			8d 00 80	       sta	$8000
   4426  27409					       endif
   4427  27409			68		       pla		; bankswitch $0 flag
   4428  2740a			60		       rts
   4429  2740b					       endif
   4430  2740b
   4431  2740b				    checkselectswitch
   4432  2740b			ad 82 02	       lda	SWCHB	; check the real select switch...
   4433  2740e			29 02		       and	#%00000010
   4434  27410				    checkselectswitchreturn
   4435  27410			60		       rts
   4436  27411
   4437  27411				    checkresetswitch
   4438  27411			ad 82 02	       lda	SWCHB	; check the real reset switch...
   4439  27414			29 01		       and	#%00000001
   4440  27416			60		       rts
   4441  27417
   4442  27417				   -	       ifconst	FINESCROLLENABLED
   4443  27417				   -finescrolldlls
   4444  27417				   -	       ldx	temp1	; first DLL index x3
   4445  27417				   -	       lda	DLLMEM,x
   4446  27417				   -	       and	#%11110000
   4447  27417				   -	       ora	finescrolly
   4448  27417				   -	       sta	DLLMEM,x
   4449  27417				   -
   4450  27417				   -	       ldx	temp2	; last DLL index x3
   4451  27417				   -	       lda	DLLMEM,x
   4452  27417				   -	       and	#%11110000
   4453  27417				   -	       ora	finescrolly
   4454  27417				   -	       eor	#(WZONEHEIGHT-1)
   4455  27417				   -	       sta	DLLMEM,x
   4456  27417				   -	       rts
   4457  27417					       endif		; FINESCROLLENABLED
   4458  27417
   4459  27417				   -	       ifconst	USED_ADJUSTVISIBLE
   4460  27417				   -adjustvisible
   4461  27417				   -			; called with temp1=first visible zone *3, temp2=last visible zone *3
   4462  27417				   -	       jsr	waitforvblankstart	; ensure vblank just started
   4463  27417				   -	       ldx	visibleDLLstart
   4464  27417				   -findfirstinterrupt
   4465  27417				   -	       lda	DLLMEM,x
   4466  27417				   -	       bmi	foundfirstinterrupt
   4467  27417				   -	       inx
   4468  27417				   -	       inx
   4469  27417				   -	       inx
   4470  27417				   -	       bne	findfirstinterrupt
   4471  27417				   -foundfirstinterrupt
   4472  27417				   -	       and	#%01111111	; clear the interrupt bit
   4473  27417				   -	       sta	DLLMEM,x
   4474  27417				   -	       ifconst	DOUBLEBUFFER
   4475  27417				   -	       sta	DLLMEM+DBOFFSET,x
   4476  27417				   -	       endif		; DOUBLEBUFFER
   4477  27417				   -	       ldx	overscanDLLstart
   4478  27417				   -findlastinterrupt
   4479  27417				   -	       lda	DLLMEM,x
   4480  27417				   -	       bmi	foundlastinterrupt
   4481  27417				   -	       dex
   4482  27417				   -	       dex
   4483  27417				   -	       dex
   4484  27417				   -	       bne	findlastinterrupt
   4485  27417				   -foundlastinterrupt
   4486  27417				   -	       and	#%01111111	; clear the interrupt bit
   4487  27417				   -	       sta	DLLMEM,x
   4488  27417				   -	       ifconst	DOUBLEBUFFER
   4489  27417				   -	       sta	DLLMEM+DBOFFSET,x
   4490  27417				   -	       endif		; DOUBLEBUFFER
   4491  27417				   -			;now we need to set the new interrupts
   4492  27417				   -	       clc
   4493  27417				   -	       lda	temp1
   4494  27417				   -	       adc	visibleDLLstart
   4495  27417				   -	       tax
   4496  27417				   -	       lda	DLLMEM,x
   4497  27417				   -	       ora	#%10000000
   4498  27417				   -	       sta	DLLMEM,x
   4499  27417				   -	       ifconst	DOUBLEBUFFER
   4500  27417				   -	       sta	DLLMEM+DBOFFSET,x
   4501  27417				   -	       endif		; DOUBLEBUFFER
   4502  27417				   -	       clc
   4503  27417				   -	       lda	temp2
   4504  27417				   -	       adc	visibleDLLstart
   4505  27417				   -	       tax
   4506  27417				   -	       lda	DLLMEM,x
   4507  27417				   -	       ora	#%10000000
   4508  27417				   -	       sta	DLLMEM,x
   4509  27417				   -	       ifconst	DOUBLEBUFFER
   4510  27417				   -	       sta	DLLMEM+DBOFFSET,x
   4511  27417				   -	       endif		; DOUBLEBUFFER
   4512  27417				   -	       jsr	vblankresync
   4513  27417				   -	       rts
   4514  27417					       endif		; USED_ADJUSTVISIBLE
   4515  27417
   4516  27417				    vblankresync
   4517  27417			20 87 f4	       jsr	waitforvblankstart	; ensure vblank just started
   4518  2741a			a9 00		       lda	#0
   4519  2741c			85 4d		       sta	visibleover
   4520  2741e			a9 03		       lda	#3
   4521  27420			8d b2 01	       sta	interruptindex
   4522  27423			60		       rts
   4523  27424
   4524  27424				    createallgamedlls
   4525  27424			a0 3c		       ldy	#(DLLLUTEND-DLLLUT)
   4526  27426				    createallgamedllsloop
   4527  27426			88		       dey
   4528  27427			b9 4b f4	       lda	DLLLUT,y
   4529  2742a			99 00 18	       sta	DLLMEM,y
   4530  2742d				   -	       ifconst	DOUBLEBUFFER
   4531  2742d				   -	       sta	DLLMEM+DBOFFSET,y
   4532  2742d					       endif		; DOUBLEBUFFER
   4533  2742d			c0 00		       cpy	#0
   4534  2742f			d0 f5		       bne	createallgamedllsloop
   4535  27431
   4536  27431				   -	       ifconst	DOUBLEBUFFER
   4537  27431				   -	       ldy	#(DLLLUTNONVISSTART-DLLLUTVISSTART)
   4538  27431				   -fixdoublebuffer
   4539  27431				   -	       dey
   4540  27431				   -	       lda	DLLMEM+DBOFFSET+DLLLUTVISSTART-DLLLUT,y
   4541  27431				   -	       clc
   4542  27431				   -	       adc	#DOUBLEBUFFEROFFSET
   4543  27431				   -	       sta	DLLMEM+DBOFFSET+DLLLUTVISSTART-DLLLUT,y
   4544  27431				   -	       dey
   4545  27431				   -	       lda	DLLMEM+DBOFFSET+DLLLUTVISSTART-DLLLUT,y
   4546  27431				   -	       adc	#0
   4547  27431				   -	       sta	DLLMEM+DBOFFSET+DLLLUTVISSTART-DLLLUT,y
   4548  27431				   -	       dey
   4549  27431				   -	       bne	fixdoublebuffer
   4550  27431					       endif
   4551  27431
   4552  27431				   -	       ifconst	BANKSET_DL_IN_CARTRAM
   4553  27431				   -			; N.B. banksets doesn't in-fact allow DL in cart-ram, so this conditional
   4554  27431				   -			; is always skipped. This is here in case some day the limitation is
   4555  27431				   -			; worked around, but it's untested. 
   4556  27431				   -
   4557  27431				   -			; With bankset cart ram, we added $8000 to the DL address so plot 
   4558  27431				   -			; functions would hit the cart-ram write-address. We need to subtract $80
   4559  27431				   -			; so Maria will read from the cart-ram read-address.
   4560  27431				   -	       ldy	#(DLLLUTNONVISSTART-DLLLUTVISSTART)
   4561  27431				   -fixbanksetaddresses
   4562  27431				   -	       dey
   4563  27431				   -	       dey
   4564  27431				   -	       lda	DLLMEM+DLLLUTVISSTART-DLLLUT,y
   4565  27431				   -	       and	#%01111111
   4566  27431				   -	       sta	DLLMEM+DLLLUTVISSTART-DLLLUT,y
   4567  27431				   -	       ifconst	DOUBLEBUFFER
   4568  27431				   -	       lda	DLLMEM+DBOFFSET+DLLLUTVISSTART-DLLLUT,y
   4569  27431				   -	       and	#%01111111
   4570  27431				   -	       sta	DLLMEM+DBOFFSET+DLLLUTVISSTART-DLLLUT,y
   4571  27431				   -	       endif		; DOUBLEBUFFER
   4572  27431				   -	       dey
   4573  27431				   -	       bne	fixbanksetaddresses
   4574  27431					       endif		; BANKSET_DL_IN_CARTRAM
   4575  27431
   4576  27431			ad 09 21	       lda	paldetected
   4577  27434			f0 0a		       beq	skippaladjust
   4578  27436			a9 4f		       lda	#($0F|(WZONEHEIGHT*4))	; +15 lines
   4579  27438			8d 06 18	       sta	DLLMEM+6
   4580  2743b				   -	       ifconst	DOUBLEBUFFER
   4581  2743b				   -	       sta	DLLMEM+DBOFFSET+6
   4582  2743b					       endif
   4583  2743b					       if	WSCREENHEIGHT = 192
   4584  2743b			a9 4d		       lda	#($0D|(WZONEHEIGHT*4))	; +6 lines
   4585  2743d				   -	       else
   4586  2743d				   -	       lda	#($07|(WZONEHEIGHT*4))	; +6 lines
   4587  2743d					       endif		; 
   4588  2743d			8d 03 18	       sta	DLLMEM+3
   4589  27440				   -	       ifconst	DOUBLEBUFFER
   4590  27440				   -	       sta	DLLMEM+DBOFFSET+3
   4591  27440					       endif		; DOUBLEBUFFER
   4592  27440
   4593  27440				    skippaladjust
   4594  27440
   4595  27440							; save the DL markers...
   4596  27440			a9 09		       lda	#(DLLLUTVISSTART-DLLLUT)
   4597  27442			8d 3c 21	       sta	visibleDLLstart
   4598  27445			a9 2d		       lda	#(DLLLUTNONVISSTART-DLLLUT)
   4599  27447			8d 3d 21	       sta	overscanDLLstart
   4600  2744a			60		       rts
   4601  2744b
   4602  2744b							; N.B. max DLL length is 112 bytes (for double-buffered)
   4603  2744b
   4604  2744b				    DLLLUT
   4605  2744b					       if	WSCREENHEIGHT = 192
   4606  2744b			4f 21 00	       .byte.b	($0F|(WZONEHEIGHT*4)),$21,$00	; 16 blank lines
   4607  2744e			47 21 00	       .byte.b	($07|(WZONEHEIGHT*4)),$21,$00	;  8 blank lines
   4608  27451			40 21 00	       .byte.b	($00|(WZONEHEIGHT*4)),$21,$00	;  1 blank lines 
   4609  27454							;=25 blank lines
   4610  27454					       endif		; WSCREENHEIGHT = 192
   4611  27454				   -	       if	WSCREENHEIGHT = 208
   4612  27454				   -	       .byte	($0E|(WZONEHEIGHT*4)),$21,$00	; 15 blank lines
   4613  27454				   -	       .byte	($00|(WZONEHEIGHT*4)),$21,$00	;  1 blank lines
   4614  27454				   -	       .byte	($00|(WZONEHEIGHT*4)),$21,$00	;  1 blank lines 
   4615  27454				   -			;=17 blank lines
   4616  27454					       endif		; WSCREENHEIGHT = 208
   4617  27454				   -	       if	WSCREENHEIGHT = 224
   4618  27454				   -	       .byte	($06|(WZONEHEIGHT*4)),$21,$00	;  7 blank lines
   4619  27454				   -	       .byte	($00|(WZONEHEIGHT*4)),$21,$00	;  1 blank lines
   4620  27454				   -	       .byte	($00|(WZONEHEIGHT*4)),$21,$00	;  1 blank lines 
   4621  27454				   -			;= 9 blank lines
   4622  27454					       endif		; WSCREENHEIGHT = 224
   4623  27454
   4624  27454				    DLLLUTVISSTART
   4625  27454			cf 18 80	       .byte.b	($80|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE0ADDRESS,<ZONE0ADDRESS
   4626  27457							;	 ^--NMI 1: start of visible
   4627  27457			4f 19 20	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE1ADDRESS,<ZONE1ADDRESS
   4628  2745a			4f 19 c0	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE2ADDRESS,<ZONE2ADDRESS
   4629  2745d			4f 1a 60	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE3ADDRESS,<ZONE3ADDRESS
   4630  27460			4f 1b 00	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE4ADDRESS,<ZONE4ADDRESS
   4631  27463			4f 1b a0	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE5ADDRESS,<ZONE5ADDRESS
   4632  27466			4f 1c 40	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE6ADDRESS,<ZONE6ADDRESS
   4633  27469			4f 1c e0	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE7ADDRESS,<ZONE7ADDRESS
   4634  2746c			4f 1d 80	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE8ADDRESS,<ZONE8ADDRESS
   4635  2746f			4f 1e 20	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE9ADDRESS,<ZONE9ADDRESS
   4636  27472			4f 1e c0	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE10ADDRESS,<ZONE10ADDRESS
   4637  27475			4f 1f 60	       .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE11ADDRESS,<ZONE11ADDRESS
   4638  27478				   -	       ifconst	ZONE12ADDRESS
   4639  27478				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE12ADDRESS,<ZONE12ADDRESS
   4640  27478					       endif
   4641  27478				   -	       ifconst	ZONE13ADDRESS
   4642  27478				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE13ADDRESS,<ZONE13ADDRESS
   4643  27478					       endif
   4644  27478				   -	       ifconst	ZONE14ADDRESS
   4645  27478				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE14ADDRESS,<ZONE14ADDRESS
   4646  27478					       endif
   4647  27478				   -	       ifconst	ZONE15ADDRESS
   4648  27478				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE15ADDRESS,<ZONE15ADDRESS
   4649  27478					       endif
   4650  27478				   -	       ifconst	ZONE16ADDRESS
   4651  27478				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE16ADDRESS,<ZONE16ADDRESS
   4652  27478					       endif
   4653  27478				   -	       ifconst	ZONE17ADDRESS
   4654  27478				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE17ADDRESS,<ZONE17ADDRESS
   4655  27478					       endif
   4656  27478				   -	       ifconst	ZONE18ADDRESS
   4657  27478				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE18ADDRESS,<ZONE18ADDRESS
   4658  27478					       endif
   4659  27478				   -	       ifconst	ZONE19ADDRESS
   4660  27478				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE19ADDRESS,<ZONE19ADDRESS
   4661  27478					       endif
   4662  27478				   -	       ifconst	ZONE20ADDRESS
   4663  27478				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE20ADDRESS,<ZONE20ADDRESS
   4664  27478					       endif
   4665  27478				   -	       ifconst	ZONE21ADDRESS
   4666  27478				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE21ADDRESS,<ZONE21ADDRESS
   4667  27478					       endif
   4668  27478				   -	       ifconst	ZONE22ADDRESS
   4669  27478				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE22ADDRESS,<ZONE22ADDRESS
   4670  27478					       endif
   4671  27478				   -	       ifconst	ZONE23ADDRESS
   4672  27478				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE23ADDRESS,<ZONE23ADDRESS
   4673  27478					       endif
   4674  27478				   -	       ifconst	ZONE24ADDRESS
   4675  27478				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE24ADDRESS,<ZONE24ADDRESS
   4676  27478					       endif
   4677  27478				   -	       ifconst	ZONE25ADDRESS
   4678  27478				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE25ADDRESS,<ZONE25ADDRESS
   4679  27478					       endif
   4680  27478				   -	       ifconst	ZONE26ADDRESS
   4681  27478				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE26ADDRESS,<ZONE26ADDRESS
   4682  27478					       endif
   4683  27478				   -	       ifconst	ZONE27ADDRESS
   4684  27478				   -	       .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE27ADDRESS,<ZONE27ADDRESS
   4685  27478					       endif
   4686  27478				    DLLLUTNONVISSTART
   4687  27478			c3 21 00	       .byte.b	($83|(WZONEHEIGHT*4)),$21,$00	;  4 blank lines
   4688  2747b							;	 ^--NMI 2: start of non-visible
   4689  2747b			cf 21 00	       .byte.b	($8F|(WZONEHEIGHT*4)),$21,$00	; 16 blank lines
   4690  2747e							;	 ^--NMI 3: start of overscan
   4691  2747e			4f 21 00	       .byte.b	($0F|(WZONEHEIGHT*4)),$21,$00	; 16 blank lines
   4692  27481			4f 21 00	       .byte.b	($0F|(WZONEHEIGHT*4)),$21,$00	; 16 blank lines
   4693  27484			4f 21 00	       .byte.b	($0F|(WZONEHEIGHT*4)),$21,$00	; 16 blank lines
   4694  27487				    DLLLUTEND
   4695  27487							;echo "DLL size: ",[(DLLLUTEND-DLLLUT)]d,"bytes"
   4696  27487							;echo "DLL code size: ",[(DLLLUTEND-createallgamedlls)]d,"bytes"
   4697  27487
   4698  27487				    waitforvblankstart
   4699  27487				    vblankendwait
   4700  27487			24 28		       BIT	MSTAT
   4701  27489			30 fc		       bmi	vblankendwait
   4702  2748b				    vblankstartwait
   4703  2748b			24 28		       BIT	MSTAT
   4704  2748d			10 fc		       bpl	vblankstartwait
   4705  2748f			60		       rts
   4706  27490
   4707  27490				   -	       ifconst	DOUBLEBUFFER
   4708  27490				   -flipdisplaybufferreturn
   4709  27490				   -	       rts
   4710  27490				   -flipdisplaybuffer
   4711  27490				   -	       ifconst	interrupthold
   4712  27490				   -	       lda	#$FF
   4713  27490				   -	       sta	interrupthold
   4714  27490				   -	       endif
   4715  27490				   -	       lda	doublebufferstate
   4716  27490				   -	       beq	flipdisplaybufferreturn	; exit if we're not in double-buffer
   4717  27490				   -
   4718  27490				   -	       jsr	terminatedisplaybuffer	; terminate the working buffer before we flip
   4719  27490				   -
   4720  27490				   -			; ensure we don't flip mid-display. otherwise the displayed DL will be the one the game is working on.
   4721  27490				   -
   4722  27490				   -flipdisplaybufferwait1
   4723  27490				   -	       lda	visibleover
   4724  27490				   -	       beq	flipdisplaybufferwait1
   4725  27490				   -
   4726  27490				   -flipdisplaybufferwait
   4727  27490				   -	       lda	visibleover
   4728  27490				   -	       bne	flipdisplaybufferwait
   4729  27490				   -
   4730  27490				   -quickbufferflip
   4731  27490				   -	       lda	doublebufferstate
   4732  27490				   -	       lsr		; /2, so we'll see 0 or 1, rather than 1 or 3
   4733  27490				   -	       tax
   4734  27490				   -
   4735  27490				   -	       lda	doublebufferminimumframetarget
   4736  27490				   -	       beq	skipminimumframecode
   4737  27490				   -	       lda	doublebufferminimumframeindex
   4738  27490				   -	       bne	flipdisplaybufferwait1
   4739  27490				   -	       lda	doublebufferminimumframetarget
   4740  27490				   -	       sta	doublebufferminimumframeindex
   4741  27490				   -skipminimumframecode
   4742  27490				   -
   4743  27490				   -	       lda	DLLMEMLutHi,x
   4744  27490				   -	       sta	DPPH
   4745  27490				   -	       lda	DLLMEMLutLo,x
   4746  27490				   -	       sta	DPPL
   4747  27490				   -
   4748  27490				   -	       lda	NewPageflipstate,x
   4749  27490				   -	       sta	doublebufferstate
   4750  27490				   -	       lda	NewPageflipoffset,x
   4751  27490				   -	       sta	doublebufferdloffset
   4752  27490				   -
   4753  27490				   -	       ifnconst	BANKSET_DL_IN_CARTRAM
   4754  27490				   -	       lda	doublebufferbufferdirty
   4755  27490				   -	       beq	flipdisplaybufferreturn
   4756  27490				   -
   4757  27490				   -			; The doublebuffer buffer is dirty, so the game code must have issued a savescreen recently.
   4758  27490				   -			; To make savescreen work with the new working buffer, we need to copy over the saved objects
   4759  27490				   -			; from the displayed buffer to the working buffer...
   4760  27490				   -
   4761  27490				   -	       lda	doublebufferdloffset
   4762  27490				   -	       eor	#DOUBLEBUFFEROFFSET
   4763  27490				   -	       sta	temp6	; make temp6 the anti-doublebufferdloffset variable
   4764  27490				   -
   4765  27490				   -	       ldx	#(WZONECOUNT-1)
   4766  27490				   -copybufferzoneloop
   4767  27490				   -
   4768  27490				   -	       lda	DLPOINTL,x
   4769  27490				   -	       clc
   4770  27490				   -	       adc	doublebufferdloffset
   4771  27490				   -	       sta	temp1
   4772  27490				   -	       lda	DLPOINTH,x
   4773  27490				   -	       adc	#0
   4774  27490				   -	       sta	temp2
   4775  27490				   -
   4776  27490				   -	       lda	DLPOINTL,x
   4777  27490				   -	       clc
   4778  27490				   -	       adc	temp6
   4779  27490				   -	       sta	temp3
   4780  27490				   -	       lda	DLPOINTH,x
   4781  27490				   -	       adc	#0
   4782  27490				   -	       sta	temp4
   4783  27490				   -
   4784  27490				   -	       lda	dlendsave,x
   4785  27490				   -	       tay
   4786  27490				   -copybuffercharsloop
   4787  27490				   -	       lda	(temp3),y
   4788  27490				   -	       sta	(temp1),y
   4789  27490				   -	       dey
   4790  27490				   -	       bpl	copybuffercharsloop
   4791  27490				   -	       dex
   4792  27490				   -	       bpl	copybufferzoneloop
   4793  27490				   -	       lda	#0
   4794  27490				   -	       sta	doublebufferbufferdirty
   4795  27490				   -	       endif		; ! BANKSET_DL_IN_CARTRAM
   4796  27490				   -	       rts
   4797  27490				   -
   4798  27490				   -doublebufferoff
   4799  27490				   -	       lda	#1
   4800  27490				   -	       sta	doublebufferstate
   4801  27490				   -	       jsr	flipdisplaybuffer
   4802  27490				   -	       lda	#0
   4803  27490				   -	       sta	doublebufferstate
   4804  27490				   -	       sta	doublebufferdloffset
   4805  27490				   -	       rts
   4806  27490				   -
   4807  27490				   -DLLMEMLutLo
   4808  27490				   -	       .byte	<DLLMEM,<(DLLMEM+DBOFFSET)
   4809  27490				   -DLLMEMLutHi
   4810  27490				   -	       .byte	>DLLMEM,>(DLLMEM+DBOFFSET)
   4811  27490				   -NewPageflipstate
   4812  27490				   -	       .byte	3,1
   4813  27490				   -NewPageflipoffset
   4814  27490				   -	       .byte	DOUBLEBUFFEROFFSET,0
   4815  27490				   -
   4816  27490					       endif		; DOUBLEBUFFER
   4817  27490
   4818  27490				   -	       ifconst	MOUSESUPPORT
   4819  27490				   -
   4820  27490				   -rotationalcompare
   4821  27490				   -			; old = 00 01 10 11
   4822  27490				   -	       .byte	$00, $01, $ff, $00	; new=00
   4823  27490				   -	       .byte	$ff, $00, $00, $01	; new=01
   4824  27490				   -	       .byte	$01, $00, $00, $ff	; new=10
   4825  27490				   -	       .byte	$00, $ff, $01, $00	; new=11
   4826  27490				   -
   4827  27490				   -			; 0000YyXx st mouse
   4828  27490				   -
   4829  27490				   -			; 0000xyXY amiga mouse
   4830  27490				   -
   4831  27490				   -	       ifconst	MOUSEXONLY
   4832  27490				   -amigatoataribits		; swap bits 1 and 4...
   4833  27490				   -	       .byte	%0000, %0000, %0010, %0010
   4834  27490				   -	       .byte	%0000, %0000, %0010, %0010
   4835  27490				   -	       .byte	%0001, %0001, %0011, %0011
   4836  27490				   -	       .byte	%0001, %0001, %0011, %0011
   4837  27490				   -
   4838  27490				   -			; null change bits
   4839  27490				   -	       .byte	%0000, %0001, %0010, %0011
   4840  27490				   -	       .byte	%0000, %0001, %0010, %0011
   4841  27490				   -	       .byte	%0000, %0001, %0010, %0011
   4842  27490				   -	       .byte	%0000, %0001, %0010, %0011
   4843  27490				   -
   4844  27490				   -	       else		; !MOUSEXONLY
   4845  27490				   -
   4846  27490				   -amigatoataribits		; swap bits 1 and 4...
   4847  27490				   -	       .byte	%0000, %1000, %0010, %1010
   4848  27490				   -	       .byte	%0100, %1100, %0110, %1110
   4849  27490				   -	       .byte	%0001, %1001, %0011, %1011
   4850  27490				   -	       .byte	%0101, %1101, %0111, %1111
   4851  27490				   -			; null change bits
   4852  27490				   -	       .byte	%0000, %0001, %0010, %0011
   4853  27490				   -	       .byte	%0100, %0101, %0110, %0111
   4854  27490				   -	       .byte	%1000, %1001, %1010, %1011
   4855  27490				   -	       .byte	%1100, %1101, %1110, %1111
   4856  27490				   -	       endif		; !MOUSEXONLY
   4857  27490				   -
   4858  27490					       endif		; MOUSESUPPORT
   4859  27490
   4860  27490				    mouse0update
   4861  27490				   -	       ifconst	MOUSE0SUPPORT
   4862  27490				   -
   4863  27490				   -mousetableselect =	inttemp2
   4864  27490				   -mousexdelta =	inttemp3
   4865  27490				   -mouseydelta =	inttemp4
   4866  27490				   -lastSWCHA  =	inttemp6
   4867  27490				   -
   4868  27490				   -			; 0000YyXx st mouse
   4869  27490				   -			; 0000xyXY amiga mouse
   4870  27490				   -
   4871  27490				   -	       lda	#$ff
   4872  27490				   -	       sta	lastSWCHA
   4873  27490				   -
   4874  27490				   -	       ldy	port0control
   4875  27490				   -
   4876  27490				   -	       lda	#%00010000
   4877  27490				   -	       cpy	#9	; AMIGA?
   4878  27490				   -	       bne	skipamigabitsfix0
   4879  27490				   -	       lda	#0
   4880  27490				   -skipamigabitsfix0
   4881  27490				   -	       sta	mousetableselect
   4882  27490				   -	       ifconst	DRIVINGBOOST
   4883  27490				   -	       cpy	#6	; DRIVING?
   4884  27490				   -	       bne	skipdriving0setup
   4885  27490				   -			; swap mousex0 and mousey0. mousex seen by the 7800basic program
   4886  27490				   -			; trails the actual mousex0, so we can smoothly interpolate toward
   4887  27490				   -			; the actual position. This actual position is stored in mousey0 
   4888  27490				   -			; after the driver has run.
   4889  27490				   -	       ldx	mousex0
   4890  27490				   -	       lda	mousey0
   4891  27490				   -	       stx	mousey0
   4892  27490				   -	       sta	mousex0
   4893  27490				   -skipdriving0setup
   4894  27490				   -	       endif		; DRIVINGBOOST
   4895  27490				   -
   4896  27490				   -	       lda	#0
   4897  27490				   -	       sta	mousexdelta
   4898  27490				   -	       sta	mouseydelta
   4899  27490				   -
   4900  27490				   -	       ifnconst	MOUSETIME
   4901  27490				   -	       ifnconst	MOUSEXONLY
   4902  27490				   -	       lda	#180	; minimum for x+y
   4903  27490				   -	       else
   4904  27490				   -	       lda	#100	; minimum for just x
   4905  27490				   -	       endif
   4906  27490				   -	       else
   4907  27490				   -	       lda	#MOUSETIME
   4908  27490				   -	       endif
   4909  27490				   -	       jsr	SETTIM64T	; INTIM is in Y
   4910  27490				   -
   4911  27490				   -mouse0updateloop
   4912  27490				   -	       lda	SWCHA
   4913  27490				   -	       asr	#%11110000	; Undocumented. A = A & #IMM, then LSR A.
   4914  27490				   -	       cmp	lastSWCHA
   4915  27490				   -	       beq	mouse0loopcondition
   4916  27490				   -	       sta	lastSWCHA
   4917  27490				   -	       lsr
   4918  27490				   -	       lsr
   4919  27490				   -	       lsr
   4920  27490				   -
   4921  27490				   -	       ora	mousetableselect	; atari/amiga decoding table selection
   4922  27490				   -
   4923  27490				   -			; st mice encode on different bits/joystick-lines than amiga mice...
   4924  27490				   -			; 0000YyXx st mouse
   4925  27490				   -			; 0000xyXY amiga mouse
   4926  27490				   -			; ...so can shuffle the amiga bits to reuse the st driver.
   4927  27490				   -	       tay
   4928  27490				   -	       lax	amigatoataribits,y
   4929  27490				   -
   4930  27490				   -	       ifnconst	MOUSEXONLY
   4931  27490				   -			; first the Y...
   4932  27490				   -	       and	#%00001100
   4933  27490				   -	       ora	mousecodey0
   4934  27490				   -	       tay
   4935  27490				   -	       lda	rotationalcompare,y
   4936  27490				   -	       clc
   4937  27490				   -	       adc	mouseydelta
   4938  27490				   -	       sta	mouseydelta
   4939  27490				   -	       tya
   4940  27490				   -	       lsr
   4941  27490				   -	       lsr
   4942  27490				   -	       sta	mousecodey0
   4943  27490				   -	       txa
   4944  27490				   -			; ...then the X...
   4945  27490				   -	       and	#%00000011
   4946  27490				   -	       tax
   4947  27490				   -	       endif		; !MOUSEXONLY
   4948  27490				   -
   4949  27490				   -	       asl
   4950  27490				   -	       asl
   4951  27490				   -	       ora	mousecodex0
   4952  27490				   -	       tay
   4953  27490				   -	       lda	rotationalcompare,y
   4954  27490				   -	       adc	mousexdelta	; carry was clear by previous ASL
   4955  27490				   -	       sta	mousexdelta
   4956  27490				   -	       stx	mousecodex0
   4957  27490				   -mouse0loopcondition
   4958  27490				   -	       lda	TIMINT
   4959  27490				   -	       bpl	mouse0updateloop
   4960  27490				   -
   4961  27490				   -			; *** adapt to selected device resolution. 
   4962  27490				   -	       ldx	port0control
   4963  27490				   -
   4964  27490				   -	       ifconst	PRECISIONMOUSING
   4965  27490				   -	       ldy	port0resolution
   4966  27490				   -	       bne	mouse0halveddone
   4967  27490				   -	       cpx	#6	; half-resolution is no good for driving wheels
   4968  27490				   -	       beq	mouse0halveddone
   4969  27490				   -			; resolution=0 is half mouse resolution, necessary for precision 
   4970  27490				   -			; mousing on a 160x240 screen with a 1000 dpi mouse.
   4971  27490				   -
   4972  27490				   -	       lda	mousexdelta
   4973  27490				   -	       cmp	#$80
   4974  27490				   -	       ror		; do a signed divide by 2.
   4975  27490				   -	       clc
   4976  27490				   -	       adc	mousex0
   4977  27490				   -	       sta	mousex0
   4978  27490				   -	       ifnconst	MOUSEXONLY
   4979  27490				   -	       lda	mouseydelta
   4980  27490				   -	       clc
   4981  27490				   -	       adc	mousey0
   4982  27490				   -	       sta	mousey0
   4983  27490				   -	       endif
   4984  27490				   -			; at half resolution we just exit after updating x and y
   4985  27490				   -	       jmp	LLRET0
   4986  27490				   -mouse0halveddone
   4987  27490				   -	       endif		; PRECISIONMOUSING
   4988  27490				   -
   4989  27490				   -	       ifnconst	MOUSEXONLY
   4990  27490				   -	       asl	mouseydelta	; *2 because Y resolution is finer
   4991  27490				   -	       ldy	port0resolution
   4992  27490				   -	       dey
   4993  27490				   -	       lda	#0
   4994  27490				   -mousey0resolutionfix
   4995  27490				   -	       clc
   4996  27490				   -	       adc	mouseydelta
   4997  27490				   -	       dey
   4998  27490				   -	       bpl	mousey0resolutionfix
   4999  27490				   -	       clc
   5000  27490				   -	       adc	mousey0
   5001  27490				   -	       sta	mousey0
   5002  27490				   -	       endif		; MOUSEXONLY
   5003  27490				   -
   5004  27490				   -	       ldy	port0resolution
   5005  27490				   -	       dey
   5006  27490				   -	       lda	#0
   5007  27490				   -mousex0resolutionfix
   5008  27490				   -	       clc
   5009  27490				   -	       adc	mousexdelta
   5010  27490				   -	       dey
   5011  27490				   -	       bpl	mousex0resolutionfix
   5012  27490				   -	       ifnconst	DRIVINGBOOST
   5013  27490				   -	       clc
   5014  27490				   -	       adc	mousex0
   5015  27490				   -	       sta	mousex0
   5016  27490				   -	       else
   5017  27490				   -	       cpx	#6
   5018  27490				   -	       beq	carryonmouse0boost
   5019  27490				   -	       clc
   5020  27490				   -	       adc	mousex0
   5021  27490				   -	       sta	mousex0
   5022  27490				   -	       jmp	LLRET0
   5023  27490				   -carryonmouse0boost
   5024  27490				   -	       sta	mousexdelta
   5025  27490				   -	       clc
   5026  27490				   -	       adc	mousecodey0
   5027  27490				   -	       sta	mousecodey0
   5028  27490				   -	       clc
   5029  27490				   -	       adc	mousex0
   5030  27490				   -	       tay		; save the target X
   5031  27490				   -	       adc	mousey0	; average in the smoothly-trailing X
   5032  27490				   -	       ror
   5033  27490				   -	       sta	mousex0	; mousex0 now has the smoothly trailing X
   5034  27490				   -	       sty	mousey0	; and mousey0 has the the target X
   5035  27490				   -
   5036  27490				   -			; check to see if the coordinate wrapped. If so, undo the averaging code.
   5037  27490				   -			; A has mousex0, the smoothly trailing X
   5038  27490				   -	       sbc	mousey0	; less the target X
   5039  27490				   -	       bpl	skipabsolutedrive0
   5040  27490				   -	       eor	#$ff
   5041  27490				   -skipabsolutedrive0
   5042  27490				   -	       cmp	#64	; just an unreasonably large change
   5043  27490				   -	       bcc	skipdrivewrapfix0
   5044  27490				   -	       sty	mousex0	; if X wrapped, we catch the trailing X up to the target X
   5045  27490				   -skipdrivewrapfix0
   5046  27490				   -
   5047  27490				   -			; get rid of the tweening if the distance travelled was very small
   5048  27490				   -	       lda	mousexdelta
   5049  27490				   -	       cmp	port0resolution
   5050  27490				   -	       bcs	skipbetweenfix0
   5051  27490				   -	       lda	mousex0
   5052  27490				   -	       sta	mousey0
   5053  27490				   -skipbetweenfix0
   5054  27490				   -
   5055  27490				   -drivingboostreductioncheck0
   5056  27490				   -			; The below code amounts to mousecodey0=mousecodey0-(mousecodey0/8)
   5057  27490				   -			; +ve mousecodey0 is converted to -ve to do the calculation, and then
   5058  27490				   -			; negated again because truncation during BCD math results in 
   5059  27490				   -			; differing magnitudes, depending if the value is +ve or -ve.
   5060  27490				   -driving0fix
   5061  27490				   -	       lax	mousecodey0
   5062  27490				   -	       cmp	#$80
   5063  27490				   -	       bcs	driving0skipnegate1
   5064  27490				   -	       eor	#$FF
   5065  27490				   -	       adc	#1
   5066  27490				   -	       sta	mousecodey0
   5067  27490				   -driving0skipnegate1
   5068  27490				   -	       cmp	#$80
   5069  27490				   -	       ror
   5070  27490				   -	       cmp	#$80
   5071  27490				   -	       ror
   5072  27490				   -	       cmp	#$80
   5073  27490				   -	       ror
   5074  27490				   -	       sta	inttemp1
   5075  27490				   -	       lda	mousecodey0
   5076  27490				   -	       sec
   5077  27490				   -	       sbc	inttemp1
   5078  27490				   -	       cpx	#$80
   5079  27490				   -	       bcs	driving0skipnegate2
   5080  27490				   -	       eor	#$FF
   5081  27490				   -	       adc	#1
   5082  27490				   -driving0skipnegate2
   5083  27490				   -	       sta	mousecodey0
   5084  27490				   -drivingboostdone0
   5085  27490				   -	       endif		; DRIVINGBOOST
   5086  27490				   -
   5087  27490				   -	       jmp	LLRET0
   5088  27490				   -
   5089  27490					       endif		; MOUSE0SUPPORT
   5090  27490
   5091  27490				    mouse1update
   5092  27490				   -	       ifconst	MOUSE1SUPPORT
   5093  27490				   -
   5094  27490				   -mousetableselect =	inttemp2
   5095  27490				   -mousexdelta =	inttemp3
   5096  27490				   -mouseydelta =	inttemp4
   5097  27490				   -lastSWCHA  =	inttemp6
   5098  27490				   -
   5099  27490				   -			; 0000YyXx st mouse
   5100  27490				   -			; 0000xyXY amiga mouse
   5101  27490				   -
   5102  27490				   -	       lda	#$ff
   5103  27490				   -	       sta	lastSWCHA
   5104  27490				   -
   5105  27490				   -	       ldy	port1control
   5106  27490				   -
   5107  27490				   -	       lda	#%00010000
   5108  27490				   -	       cpy	#9	; AMIGA?
   5109  27490				   -	       bne	skipamigabitsfix1
   5110  27490				   -	       lda	#0
   5111  27490				   -skipamigabitsfix1
   5112  27490				   -	       sta	mousetableselect
   5113  27490				   -	       ifconst	DRIVINGBOOST
   5114  27490				   -	       cpy	#6	; DRIVING?
   5115  27490				   -	       bne	skipdriving1setup
   5116  27490				   -			; swap mousex1 and mousey1. mousex seen by the 7800basic program
   5117  27490				   -			; trails the actual mousex1, so we can smoothly interpolate toward
   5118  27490				   -			; the actual position. This actual position is stored in mousey1 
   5119  27490				   -			; after the driver has run.
   5120  27490				   -	       ldx	mousex1
   5121  27490				   -	       lda	mousey1
   5122  27490				   -	       stx	mousey1
   5123  27490				   -	       sta	mousex1
   5124  27490				   -skipdriving1setup
   5125  27490				   -	       endif		; DRIVINGBOOST
   5126  27490				   -
   5127  27490				   -	       lda	#0
   5128  27490				   -	       sta	mousexdelta
   5129  27490				   -	       sta	mouseydelta
   5130  27490				   -
   5131  27490				   -	       ifnconst	MOUSETIME
   5132  27490				   -	       ifnconst	MOUSEXONLY
   5133  27490				   -	       lda	#180	; minimum for x+y
   5134  27490				   -	       else
   5135  27490				   -	       lda	#100	; minimum for just x
   5136  27490				   -	       endif
   5137  27490				   -	       else
   5138  27490				   -	       lda	#MOUSETIME
   5139  27490				   -	       endif
   5140  27490				   -	       jsr	SETTIM64T	; INTIM is in Y
   5141  27490				   -
   5142  27490				   -mouse1updateloop
   5143  27490				   -	       lda	SWCHA
   5144  27490				   -	       and	#%00001111
   5145  27490				   -	       cmp	lastSWCHA
   5146  27490				   -	       beq	mouse1loopcondition
   5147  27490				   -	       sta	lastSWCHA
   5148  27490				   -
   5149  27490				   -	       ora	mousetableselect	; atari/amiga decoding table selection
   5150  27490				   -
   5151  27490				   -			; st mice encode on different bits/joystick-lines than amiga mice...
   5152  27490				   -			; 0000YyXx st mouse
   5153  27490				   -			; 0000xyXY amiga mouse
   5154  27490				   -			; ...so can shuffle the amiga bits to reuse the st driver.
   5155  27490				   -	       tay
   5156  27490				   -	       lax	amigatoataribits,y
   5157  27490				   -
   5158  27490				   -	       ifnconst	MOUSEXONLY
   5159  27490				   -			; first the Y...
   5160  27490				   -	       and	#%00001100
   5161  27490				   -	       ora	mousecodey1
   5162  27490				   -	       tay
   5163  27490				   -	       lda	rotationalcompare,y
   5164  27490				   -	       clc
   5165  27490				   -	       adc	mouseydelta
   5166  27490				   -	       sta	mouseydelta
   5167  27490				   -	       tya
   5168  27490				   -	       lsr
   5169  27490				   -	       lsr
   5170  27490				   -	       sta	mousecodey1
   5171  27490				   -	       txa
   5172  27490				   -			; ...then the X...
   5173  27490				   -	       and	#%00000011
   5174  27490				   -	       tax
   5175  27490				   -	       endif		; !MOUSEXONLY
   5176  27490				   -
   5177  27490				   -	       asl
   5178  27490				   -	       asl
   5179  27490				   -	       ora	mousecodex1
   5180  27490				   -	       tay
   5181  27490				   -	       lda	rotationalcompare,y
   5182  27490				   -	       adc	mousexdelta	; carry was clear by previous ASL
   5183  27490				   -	       sta	mousexdelta
   5184  27490				   -	       stx	mousecodex1
   5185  27490				   -mouse1loopcondition
   5186  27490				   -	       lda	TIMINT
   5187  27490				   -	       bpl	mouse1updateloop
   5188  27490				   -
   5189  27490				   -			; *** adapt to selected device resolution. 
   5190  27490				   -	       ldx	port1control
   5191  27490				   -
   5192  27490				   -	       ifconst	PRECISIONMOUSING
   5193  27490				   -	       ldy	port1resolution
   5194  27490				   -	       bne	mouse1halveddone
   5195  27490				   -	       cpx	#6	; half-resolution is no good for driving wheels
   5196  27490				   -	       beq	mouse1halveddone
   5197  27490				   -			; resolution=0 is half mouse resolution, necessary for precision 
   5198  27490				   -			; mousing on a 160x240 screen with a 1000 dpi mouse.
   5199  27490				   -
   5200  27490				   -	       lda	mousexdelta
   5201  27490				   -	       cmp	#$80
   5202  27490				   -	       ror		; do a signed divide by 2.
   5203  27490				   -	       clc
   5204  27490				   -	       adc	mousex1
   5205  27490				   -	       sta	mousex1
   5206  27490				   -	       ifnconst	MOUSEXONLY
   5207  27490				   -	       lda	mouseydelta
   5208  27490				   -	       clc
   5209  27490				   -	       adc	mousey1
   5210  27490				   -	       sta	mousey1
   5211  27490				   -	       endif
   5212  27490				   -			; at half resolution we just exit after updating x and y
   5213  27490				   -	       jmp	LLRET1
   5214  27490				   -mouse1halveddone
   5215  27490				   -	       endif		; PRECISIONMOUSING
   5216  27490				   -
   5217  27490				   -	       ifnconst	MOUSEXONLY
   5218  27490				   -	       asl	mouseydelta	; *2 because Y resolution is finer
   5219  27490				   -	       ldy	port1resolution
   5220  27490				   -	       dey
   5221  27490				   -	       lda	#0
   5222  27490				   -mousey1resolutionfix
   5223  27490				   -	       clc
   5224  27490				   -	       adc	mouseydelta
   5225  27490				   -	       dey
   5226  27490				   -	       bpl	mousey1resolutionfix
   5227  27490				   -	       clc
   5228  27490				   -	       adc	mousey1
   5229  27490				   -	       sta	mousey1
   5230  27490				   -	       endif		; MOUSEXONLY
   5231  27490				   -
   5232  27490				   -	       ldy	port1resolution
   5233  27490				   -	       dey
   5234  27490				   -	       lda	#0
   5235  27490				   -mousex1resolutionfix
   5236  27490				   -	       clc
   5237  27490				   -	       adc	mousexdelta
   5238  27490				   -	       dey
   5239  27490				   -	       bpl	mousex1resolutionfix
   5240  27490				   -	       ifnconst	DRIVINGBOOST
   5241  27490				   -	       clc
   5242  27490				   -	       adc	mousex1
   5243  27490				   -	       sta	mousex1
   5244  27490				   -	       else
   5245  27490				   -	       cpx	#6
   5246  27490				   -	       beq	carryonmouse1boost
   5247  27490				   -	       clc
   5248  27490				   -	       adc	mousex1
   5249  27490				   -	       sta	mousex1
   5250  27490				   -	       jmp	LLRET1
   5251  27490				   -carryonmouse1boost
   5252  27490				   -	       sta	mousexdelta
   5253  27490				   -	       clc
   5254  27490				   -	       adc	mousecodey1
   5255  27490				   -	       sta	mousecodey1
   5256  27490				   -	       clc
   5257  27490				   -	       adc	mousex1
   5258  27490				   -	       tay		; save the target X
   5259  27490				   -	       adc	mousey1	; average in the smoothly-trailing X
   5260  27490				   -	       ror
   5261  27490				   -	       sta	mousex1	; mousex0 now has the smoothly trailing X
   5262  27490				   -	       sty	mousey1	; and mousey0 has the the target X
   5263  27490				   -
   5264  27490				   -			; check to see if the coordinate wrapped. If so, undo the averaging code.
   5265  27490				   -			; A has mousex1, the smoothly trailing X
   5266  27490				   -	       sbc	mousey1	; less the target X
   5267  27490				   -	       bpl	skipabsolutedrive1
   5268  27490				   -	       eor	#$ff
   5269  27490				   -skipabsolutedrive1
   5270  27490				   -	       cmp	#64	; just an unreasonably large change
   5271  27490				   -	       bcc	skipdrivewrapfix1
   5272  27490				   -	       sty	mousex1	; if X wrapped, we catch the trailing X up to the target X
   5273  27490				   -skipdrivewrapfix1
   5274  27490				   -
   5275  27490				   -			; get rid of the tweening if the distance travelled was very small
   5276  27490				   -	       lda	mousexdelta
   5277  27490				   -	       cmp	port1resolution
   5278  27490				   -	       bcs	skipbetweenfix1
   5279  27490				   -	       lda	mousex1
   5280  27490				   -	       sta	mousey1
   5281  27490				   -skipbetweenfix1
   5282  27490				   -
   5283  27490				   -drivingboostreductioncheck1
   5284  27490				   -			; The below code amounts to mousecodey0=mousecodey0-(mousecodey0/8)
   5285  27490				   -			; +ve mousecodey0 is converted to -ve to do the calculation, and then
   5286  27490				   -			; negated again because truncation during BCD math results in 
   5287  27490				   -			; differing magnitudes, depending if the value is +ve or -ve.
   5288  27490				   -driving1fix
   5289  27490				   -	       lax	mousecodey1
   5290  27490				   -	       cmp	#$80
   5291  27490				   -	       bcs	driving0skipnegate1
   5292  27490				   -	       eor	#$FF
   5293  27490				   -	       adc	#1
   5294  27490				   -	       sta	mousecodey1
   5295  27490				   -driving0skipnegate1
   5296  27490				   -	       cmp	#$80
   5297  27490				   -	       ror
   5298  27490				   -	       cmp	#$80
   5299  27490				   -	       ror
   5300  27490				   -	       cmp	#$80
   5301  27490				   -	       ror
   5302  27490				   -	       sta	inttemp1
   5303  27490				   -	       lda	mousecodey1
   5304  27490				   -	       sec
   5305  27490				   -	       sbc	inttemp1
   5306  27490				   -	       cpx	#$80
   5307  27490				   -	       bcs	driving1skipnegate2
   5308  27490				   -	       eor	#$FF
   5309  27490				   -	       adc	#1
   5310  27490				   -driving1skipnegate2
   5311  27490				   -	       sta	mousecodey1
   5312  27490				   -drivingboostdone1
   5313  27490				   -	       endif		; DRIVINGBOOST
   5314  27490				   -
   5315  27490				   -	       jmp	LLRET1
   5316  27490				   -
   5317  27490					       endif		; MOUSE1SUPPORT
   5318  27490
   5319  27490
   5320  27490				    trakball0update
   5321  27490				   -	       ifconst	TRAKBALL0SUPPORT
   5322  27490				   -	       ifnconst	TRAKTIME
   5323  27490				   -	       ifnconst	TRAKXONLY
   5324  27490				   -	       lda	#180	; minimum for x+y
   5325  27490				   -	       else		; !TRAKXONLY
   5326  27490				   -	       lda	#100	; minimum for just x
   5327  27490				   -	       endif		; !TRAKXONLY
   5328  27490				   -	       else		; !TRAKTIME
   5329  27490				   -	       lda	#TRAKTIME
   5330  27490				   -	       endif		; !TRAKTIME
   5331  27490				   -	       jsr	SETTIM64T	; INTIM is in Y
   5332  27490				   -	       ldx	#0
   5333  27490				   -	       ifnconst	TRAKXONLY
   5334  27490				   -	       ldy	#0
   5335  27490				   -	       endif		; TRAKXONLY
   5336  27490				   -trakball0updateloop
   5337  27490				   -	       lda	SWCHA
   5338  27490				   -	       and	#%00110000
   5339  27490				   -	       cmp	trakballcodex0
   5340  27490				   -	       sta	trakballcodex0
   5341  27490				   -	       beq	trakball0movementXdone
   5342  27490				   -	       and	#%00010000
   5343  27490				   -	       beq	trakball0negativeX
   5344  27490				   -trakball0positiveX
   5345  27490				   -			;(2 from beq)
   5346  27490				   -	       inx		; 2
   5347  27490				   -	       jmp	trakball0movementXdone	; 3
   5348  27490				   -trakball0negativeX
   5349  27490				   -			;(3 from beq)
   5350  27490				   -	       dex		; 2
   5351  27490				   -	       nop		; 2
   5352  27490				   -trakball0movementXdone
   5353  27490				   -
   5354  27490				   -	       ifnconst	TRAKXONLY
   5355  27490				   -	       lda	SWCHA
   5356  27490				   -	       and	#%11000000
   5357  27490				   -	       cmp	trakballcodey0
   5358  27490				   -	       sta	trakballcodey0
   5359  27490				   -	       beq	trakball0movementYdone
   5360  27490				   -	       and	#%01000000
   5361  27490				   -	       beq	trakball0negativeY
   5362  27490				   -trakball0positiveY
   5363  27490				   -			;(2 from beq)
   5364  27490				   -	       iny		; 2
   5365  27490				   -	       jmp	trakball0movementYdone	; 3
   5366  27490				   -trakball0negativeY
   5367  27490				   -			;(3 from beq)
   5368  27490				   -	       dey		; 2
   5369  27490				   -	       nop		; 2
   5370  27490				   -trakball0movementYdone
   5371  27490				   -	       endif		; !TRAKXONLY
   5372  27490				   -
   5373  27490				   -	       lda	TIMINT
   5374  27490				   -	       bpl	trakball0updateloop
   5375  27490				   -	       lda	#0
   5376  27490				   -	       cpx	#0
   5377  27490				   -	       beq	trakball0skipXadjust
   5378  27490				   -	       clc
   5379  27490				   -trakball0Xloop
   5380  27490				   -	       adc	port0resolution
   5381  27490				   -	       dex
   5382  27490				   -	       bne	trakball0Xloop
   5383  27490				   -	       clc
   5384  27490				   -	       adc	trakballx0
   5385  27490				   -	       sta	trakballx0
   5386  27490				   -trakball0skipXadjust
   5387  27490				   -	       ifnconst	TRAKXONLY
   5388  27490				   -	       lda	#0
   5389  27490				   -	       cpy	#0
   5390  27490				   -	       beq	trakball0skipYadjust
   5391  27490				   -	       clc
   5392  27490				   -trakball0yloop
   5393  27490				   -	       adc	port0resolution
   5394  27490				   -	       dey
   5395  27490				   -	       bne	trakball0yloop
   5396  27490				   -	       clc
   5397  27490				   -	       adc	trakbally0
   5398  27490				   -	       sta	trakbally0
   5399  27490				   -trakball0skipYadjust
   5400  27490				   -	       endif		; !TRAKXONLY
   5401  27490				   -
   5402  27490				   -	       jmp	LLRET0
   5403  27490					       endif
   5404  27490
   5405  27490
   5406  27490
   5407  27490				    trakball1update
   5408  27490				   -	       ifconst	TRAKBALL1SUPPORT
   5409  27490				   -	       ifnconst	TRAKTIME
   5410  27490				   -	       ifnconst	TRAKXONLY
   5411  27490				   -	       lda	#180	; minimum for x+y
   5412  27490				   -	       else		; !TRAKXONLY
   5413  27490				   -	       lda	#100	; minimum for just x
   5414  27490				   -	       endif		; !TRAKXONLY
   5415  27490				   -	       else		; !TRAKTIME
   5416  27490				   -	       lda	#TRAKTIME
   5417  27490				   -	       endif		; !TRAKTIME
   5418  27490				   -	       jsr	SETTIM64T	; INTIM is in Y
   5419  27490				   -	       ldx	#0
   5420  27490				   -	       ifnconst	TRAKXONLY
   5421  27490				   -	       ldy	#0
   5422  27490				   -	       endif		; TRAKXONLY
   5423  27490				   -trakball1updateloop
   5424  27490				   -	       lda	SWCHA
   5425  27490				   -	       and	#%00000011
   5426  27490				   -	       cmp	trakballcodex1
   5427  27490				   -	       sta	trakballcodex1
   5428  27490				   -	       beq	trakball1movementXdone
   5429  27490				   -	       and	#%00000001
   5430  27490				   -	       beq	trakball1negativeX
   5431  27490				   -trakball1positiveX
   5432  27490				   -			;(2 from beq)
   5433  27490				   -	       inx		; 2
   5434  27490				   -	       jmp	trakball1movementXdone	; 3
   5435  27490				   -trakball1negativeX
   5436  27490				   -			;(3 from beq)
   5437  27490				   -	       dex		; 2
   5438  27490				   -	       nop		; 2
   5439  27490				   -trakball1movementXdone
   5440  27490				   -
   5441  27490				   -	       ifnconst	TRAKXONLY
   5442  27490				   -	       lda	SWCHA
   5443  27490				   -	       and	#%00001100
   5444  27490				   -	       cmp	trakballcodey1
   5445  27490				   -	       sta	trakballcodey1
   5446  27490				   -	       beq	trakball1movementYdone
   5447  27490				   -	       and	#%00000100
   5448  27490				   -	       beq	trakball1negativeY
   5449  27490				   -trakball1positiveY
   5450  27490				   -			;(2 from beq)
   5451  27490				   -	       iny		; 2
   5452  27490				   -	       jmp	trakball1movementYdone	; 3
   5453  27490				   -trakball1negativeY
   5454  27490				   -			;(3 from beq)
   5455  27490				   -	       dey		; 2
   5456  27490				   -	       nop		; 2
   5457  27490				   -trakball1movementYdone
   5458  27490				   -	       endif		; !TRAKXONLY
   5459  27490				   -
   5460  27490				   -	       lda	TIMINT
   5461  27490				   -	       bpl	trakball1updateloop
   5462  27490				   -	       lda	#0
   5463  27490				   -	       cpx	#0
   5464  27490				   -	       beq	trakball1skipXadjust
   5465  27490				   -	       clc
   5466  27490				   -trakball1Xloop
   5467  27490				   -	       adc	port1resolution
   5468  27490				   -	       dex
   5469  27490				   -	       bne	trakball1Xloop
   5470  27490				   -	       clc
   5471  27490				   -	       adc	trakballx1
   5472  27490				   -	       sta	trakballx1
   5473  27490				   -trakball1skipXadjust
   5474  27490				   -	       ifnconst	TRAKXONLY
   5475  27490				   -	       lda	#0
   5476  27490				   -	       cpy	#0
   5477  27490				   -	       beq	trakball1skipYadjust
   5478  27490				   -	       clc
   5479  27490				   -trakball1yloop
   5480  27490				   -	       adc	port1resolution
   5481  27490				   -	       dey
   5482  27490				   -	       bne	trakball1yloop
   5483  27490				   -	       clc
   5484  27490				   -	       adc	trakbally1
   5485  27490				   -	       sta	trakbally1
   5486  27490				   -trakball1skipYadjust
   5487  27490				   -	       endif		; !TRAKXONLY
   5488  27490				   -
   5489  27490				   -	       jmp	LLRET1
   5490  27490					       endif
   5491  27490
   5492  27490
   5493  27490				    paddleport0update
   5494  27490				   -	       ifconst	PADDLE0SUPPORT
   5495  27490				   -	       lda	#6
   5496  27490				   -	       sta	VBLANK	; start charging the paddle caps
   5497  27490				   -	       lda	#0	; use PADDLE timing
   5498  27490				   -	       jsr	SETTIM64T	; INTIM is in Y
   5499  27490				   -
   5500  27490				   -paddleport0updateloop
   5501  27490				   -	       lda	INPT0
   5502  27490				   -	       bmi	skippaddle0setposition
   5503  27490				   -	       sty	paddleposition0
   5504  27490				   -skippaddle0setposition
   5505  27490				   -	       ifconst	TWOPADDLESUPPORT
   5506  27490				   -	       lda	INPT1
   5507  27490				   -	       bmi	skippaddle1setposition
   5508  27490				   -	       sty	paddleposition1
   5509  27490				   -skippaddle1setposition
   5510  27490				   -	       endif
   5511  27490				   -	       ldy	INTIM
   5512  27490				   -	       cpy	#TIMEOFFSET
   5513  27490				   -	       bcs	paddleport0updateloop
   5514  27490				   -
   5515  27490				   -	       lda	#%10000110
   5516  27490				   -	       sta	VBLANK	; dump paddles to ground... this may not be great for genesis controllers
   5517  27490				   -	       sec
   5518  27490				   -	       lda	paddleposition0
   5519  27490				   -	       sbc	#TIMEOFFSET
   5520  27490				   -	       ifconst	PADDLESCALEX2
   5521  27490				   -	       asl
   5522  27490				   -	       endif
   5523  27490				   -
   5524  27490				   -	       ifnconst	PADDLESMOOTHINGOFF
   5525  27490				   -	       clc
   5526  27490				   -	       adc	paddleprevious0
   5527  27490				   -	       ror
   5528  27490				   -	       sta	paddleprevious0
   5529  27490				   -	       endif
   5530  27490				   -
   5531  27490				   -	       sta	paddleposition0
   5532  27490				   -
   5533  27490				   -	       ifconst	TWOPADDLESUPPORT
   5534  27490				   -	       sec
   5535  27490				   -	       lda	paddleposition1
   5536  27490				   -	       sbc	#TIMEOFFSET
   5537  27490				   -	       ifconst	PADDLESCALEX2
   5538  27490				   -	       asl
   5539  27490				   -	       endif
   5540  27490				   -
   5541  27490				   -	       ifnconst	PADDLESMOOTHINGOFF
   5542  27490				   -	       clc
   5543  27490				   -	       adc	paddleprevious1
   5544  27490				   -	       ror
   5545  27490				   -	       sta	paddleprevious1
   5546  27490				   -	       endif
   5547  27490				   -	       sta	paddleposition1
   5548  27490				   -	       endif		; TWOPADDLESUPPORT
   5549  27490				   -
   5550  27490				   -	       jmp	LLRET0
   5551  27490					       endif
   5552  27490
   5553  27490				    paddleport1update
   5554  27490				   -	       ifconst	PADDLE1SUPPORT
   5555  27490				   -	       lda	#6
   5556  27490				   -	       sta	VBLANK	; start charging the paddle caps
   5557  27490				   -
   5558  27490				   -	       lda	#0	; use PADDLE timing
   5559  27490				   -	       jsr	SETTIM64T	; INTIM is in Y
   5560  27490				   -
   5561  27490				   -paddleport1updateloop
   5562  27490				   -	       lda	INPT2
   5563  27490				   -	       bmi	skippaddle2setposition
   5564  27490				   -	       sty	paddleposition2
   5565  27490				   -skippaddle2setposition
   5566  27490				   -	       ifconst	TWOPADDLESUPPORT
   5567  27490				   -	       lda	INPT3
   5568  27490				   -	       bmi	skippaddle3setposition
   5569  27490				   -	       sty	paddleposition3
   5570  27490				   -skippaddle3setposition
   5571  27490				   -	       endif
   5572  27490				   -	       ldy	INTIM
   5573  27490				   -	       cpy	#TIMEOFFSET
   5574  27490				   -	       bcs	paddleport1updateloop
   5575  27490				   -
   5576  27490				   -	       lda	#%10000110
   5577  27490				   -	       sta	VBLANK	; dump paddles to ground... this may not be great for genesis controllers
   5578  27490				   -	       sec
   5579  27490				   -	       lda	paddleposition2
   5580  27490				   -	       sbc	#TIMEOFFSET
   5581  27490				   -	       ifconst	PADDLESCALEX2
   5582  27490				   -	       asl
   5583  27490				   -	       endif
   5584  27490				   -
   5585  27490				   -	       ifnconst	PADDLESMOOTHINGOFF
   5586  27490				   -	       clc
   5587  27490				   -	       adc	paddleprevious2
   5588  27490				   -	       ror
   5589  27490				   -	       sta	paddleprevious2
   5590  27490				   -	       endif
   5591  27490				   -
   5592  27490				   -	       sta	paddleposition2
   5593  27490				   -
   5594  27490				   -	       ifconst	TWOPADDLESUPPORT
   5595  27490				   -	       sec
   5596  27490				   -	       lda	paddleposition3
   5597  27490				   -	       sbc	#TIMEOFFSET
   5598  27490				   -	       ifconst	PADDLESCALEX2
   5599  27490				   -	       asl
   5600  27490				   -	       endif
   5601  27490				   -
   5602  27490				   -	       ifnconst	PADDLESMOOTHINGOFF
   5603  27490				   -	       clc
   5604  27490				   -	       adc	paddleprevious3
   5605  27490				   -	       ror
   5606  27490				   -	       sta	paddleprevious3
   5607  27490				   -	       endif
   5608  27490				   -	       sta	paddleposition3
   5609  27490				   -	       endif		; TWOPADDLESUPPORT
   5610  27490				   -
   5611  27490				   -	       jmp	LLRET1
   5612  27490					       endif
   5613  27490
   5614  27490
   5615  27490				    paddlebuttonhandler 		; outside of conditional, for button-handler LUT
   5616  27490				   -	       ifconst	PADDLESUPPORT
   5617  27490				   -			; x=0|1 for port, rather than paddle #. 
   5618  27490				   -			; Only the first paddle button will integrate into "joy0fire" testing. If the
   5619  27490				   -			; game wants to support 2 paddles, up to the game to instead test the 
   5620  27490				   -			; joystick right+left directions instead.
   5621  27490				   -	       lda	SWCHA	; top of nibble is first paddle button
   5622  27490				   -	       cpx	#0	; port 0?
   5623  27490				   -	       beq	skippaddleport2shift
   5624  27490				   -	       asl		; shift second port to upper nibble
   5625  27490				   -	       asl
   5626  27490				   -	       asl
   5627  27490				   -	       asl
   5628  27490				   -skippaddleport2shift
   5629  27490				   -	       and	#%11000000
   5630  27490				   -	       eor	#%11000000	; invert
   5631  27490				   -	       sta	sINPT1,x
   5632  27490				   -	       jmp	buttonreadloopreturn
   5633  27490					       endif		; PADDLESUPPORT
   5634  27490
   5635  27490				    mousebuttonhandler		; outside of conditional, for button-handler LUT
   5636  27490				   -	       ifconst	MOUSESUPPORT
   5637  27490				   -			; stick the mouse buttons in the correct shadow register...
   5638  27490				   -	       txa
   5639  27490				   -	       asl
   5640  27490				   -	       tay		; y=x*2
   5641  27490				   -	       lda	INPT4,x
   5642  27490				   -	       eor	#%10000000
   5643  27490				   -	       lsr
   5644  27490				   -	       sta	sINPT1,x
   5645  27490				   -
   5646  27490				   -	       lda	INPT1,y
   5647  27490				   -	       and	#%10000000
   5648  27490				   -	       eor	#%10000000
   5649  27490				   -	       ora	sINPT1,x
   5650  27490				   -	       sta	sINPT1,x
   5651  27490				   -	       jmp	buttonreadloopreturn
   5652  27490					       endif		; MOUSESUPPORT
   5653  27490
   5654  27490				   -	       ifconst	KEYPADSUPPORT
   5655  27490				   -			; ** select keypad rows 0 to 3 over 4 frames...
   5656  27490				   -keypadrowselect
   5657  27490				   -	       inc	keypadcounter
   5658  27490				   -	       ldy	#0
   5659  27490				   -	       lda	port0control
   5660  27490				   -	       cmp	#7
   5661  27490				   -	       bne	skipport0val
   5662  27490				   -	       iny		; y=y+1
   5663  27490				   -skipport0val
   5664  27490				   -	       lda	port1control
   5665  27490				   -	       cmp	#7
   5666  27490				   -	       bne	skipport1val
   5667  27490				   -	       iny
   5668  27490				   -	       iny		; y=y+2
   5669  27490				   -skipport1val
   5670  27490				   -	       cpy	#0
   5671  27490				   -	       beq	exitkeypadrowselect
   5672  27490				   -	       lda	keyrowdirectionmask,y
   5673  27490				   -	       sta	CTLSWA
   5674  27490				   -	       tya
   5675  27490				   -	       asl
   5676  27490				   -	       asl
   5677  27490				   -	       sta	inttemp1
   5678  27490				   -	       lda	keypadcounter
   5679  27490				   -	       and	#3
   5680  27490				   -	       ora	inttemp1
   5681  27490				   -	       tax
   5682  27490				   -	       lda	keyrowselectvalue,x
   5683  27490				   -	       sta	SWCHA
   5684  27490				   -exitkeypadrowselect
   5685  27490				   -	       rts
   5686  27490				   -
   5687  27490				   -keyrowdirectionmask
   5688  27490				   -	       .byte	#%00000000	; 0 : port0=input port1=input
   5689  27490				   -	       .byte	#%11110000	; 1 : port0=output port1=input
   5690  27490				   -	       .byte	#%00001111	; 2 : port0=input port1=output
   5691  27490				   -	       .byte	#%11111111	; 3 : port0=output port1=output
   5692  27490				   -
   5693  27490				   -keyrowselectvalue
   5694  27490				   -	       .byte	#%00000000, #%00000000, #%00000000, #%00000000	; no row selected, all pins high, always
   5695  27490				   -	       .byte	#%11100000, #%11010000, #%10110000, #%01110000	; p0 keypad in
   5696  27490				   -	       .byte	#%00001110, #%00001101, #%00001011, #%00000111	; p1 keypad in
   5697  27490				   -	       .byte	#%11101110, #%11011101, #%10111011, #%01110111	; p0+p1 keypads in
   5698  27490					       endif		; KEYPADSUPPORT
   5699  27490
   5700  27490				   -	       ifconst	KEYPADSUPPORT
   5701  27490				   -			; TODO - split into compile-time KEYPAD0SUPPORT and KEYPAD1SUPPORT
   5702  27490				   -keypadcolumnread
   5703  27490				   -	       lda	port0control
   5704  27490				   -	       cmp	#7
   5705  27490				   -	       bne	skipkeypadcolumnread0
   5706  27490				   -	       lda	keypadcounter
   5707  27490				   -	       and	#3
   5708  27490				   -	       asl		; x2 because keypad variables are interleaved
   5709  27490				   -	       tax
   5710  27490				   -	       lda	#0
   5711  27490				   -	       sta	keypadmatrix0a,x
   5712  27490				   -	       lda	INPT0
   5713  27490				   -	       cmp	#$80
   5714  27490				   -	       rol	keypadmatrix0a,x
   5715  27490				   -	       lda	INPT1
   5716  27490				   -	       cmp	#$80
   5717  27490				   -	       rol	keypadmatrix0a,x
   5718  27490				   -	       lda	INPT4
   5719  27490				   -	       cmp	#$80
   5720  27490				   -	       rol	keypadmatrix0a,x
   5721  27490				   -	       lda	keypadmatrix0a,x
   5722  27490				   -	       eor	#%00000111
   5723  27490				   -	       sta	keypadmatrix0a,x
   5724  27490				   -skipkeypadcolumnread0
   5725  27490				   -
   5726  27490				   -	       lda	port1control
   5727  27490				   -	       cmp	#7
   5728  27490				   -	       bne	skipkeypadcolumnread1
   5729  27490				   -	       lda	keypadcounter
   5730  27490				   -	       and	#3
   5731  27490				   -	       asl		; x2 because keypad variables are interleaved
   5732  27490				   -	       tax
   5733  27490				   -	       lda	#0
   5734  27490				   -	       sta	keypadmatrix1a,x
   5735  27490				   -	       rol	keypadmatrix1a,x
   5736  27490				   -	       lda	INPT2
   5737  27490				   -	       cmp	#$80
   5738  27490				   -	       rol	keypadmatrix1a,x
   5739  27490				   -	       lda	INPT3
   5740  27490				   -	       cmp	#$80
   5741  27490				   -	       rol	keypadmatrix1a,x
   5742  27490				   -	       lda	INPT5
   5743  27490				   -	       cmp	#$80
   5744  27490				   -	       rol	keypadmatrix1a,x
   5745  27490				   -	       lda	keypadmatrix1a,x
   5746  27490				   -	       eor	#%00000111
   5747  27490				   -	       sta	keypadmatrix1a,x
   5748  27490				   -skipkeypadcolumnread1
   5749  27490				   -	       rts
   5750  27490					       endif		; KEYPADSUPPORT
   5751  27490
   5752  27490				    setportforinput
   5753  27490			ad 81 02	       lda	CTLSWA
   5754  27493			3d c2 f1	       and	SWCHA_DIRMASK,x
   5755  27496			8d 81 02	       sta	CTLSWA
   5756  27499			60		       rts
   5757  2749a
   5758  2749a				    setonebuttonmode
   5759  2749a			a9 06		       lda	#6	; in case we're in unlocked-bios mode
   5760  2749c			85 01		       sta	VBLANK	; if we were on paddles, the line is grounded out.
   5761  2749e			a9 14		       lda	#$14
   5762  274a0			8d 83 02	       sta	CTLSWB
   5763  274a3			ad 82 02	       lda	SWCHB
   5764  274a6			1d c0 f4	       ora	thisjoy2buttonbit,x	; disable: write 1 to the 2-button bit
   5765  274a9			8d 82 02	       sta	SWCHB
   5766  274ac			60		       rts
   5767  274ad
   5768  274ad				    settwobuttonmode
   5769  274ad			a9 06		       lda	#6	; in case we're in unlocked-bios mode
   5770  274af			85 01		       sta	VBLANK	; if we were on paddles, the line is grounded out.
   5771  274b1			a9 14		       lda	#$14
   5772  274b3			8d 83 02	       sta	CTLSWB
   5773  274b6			ad 82 02	       lda	SWCHB
   5774  274b9			3d c1 f4	       and	thisjoy2buttonbit+1,x	; enable: write 0 to the 2-button bit
   5775  274bc			8d 82 02	       sta	SWCHB
   5776  274bf			60		       rts
   5777  274c0
   5778  274c0				    thisjoy2buttonbit
   5779  274c0							; p0	p1   p0
   5780  274c0			04 10 04	       .byte.b	$04, $10, $04
   5781  274c3
   5782  274c3				   -	       ifconst	CHANGEDMAHOLES
   5783  274c3				   -removedmaholes
   5784  274c3				   -	       ldx	#0
   5785  274c3				   -removedllholesloop
   5786  274c3				   -	       lda	DLLMEM,x
   5787  274c3				   -	       and	#%10001111
   5788  274c3				   -	       sta	DLLMEM,x
   5789  274c3				   -	       ifconst	DOUBLEBUFFER
   5790  274c3				   -	       sta	DLLMEM+DBOFFSET,x
   5791  274c3				   -	       endif
   5792  274c3				   -	       inx
   5793  274c3				   -	       inx
   5794  274c3				   -	       inx
   5795  274c3				   -	       ifconst	DOUBLEBUFFER
   5796  274c3				   -	       cpx	#DBOFFSET
   5797  274c3				   -	       bcc	removedllholesloop
   5798  274c3				   -	       else
   5799  274c3				   -	       bpl	removedllholesloop
   5800  274c3				   -	       endif
   5801  274c3				   -	       rts
   5802  274c3				   -
   5803  274c3				   -createdmaholes
   5804  274c3				   -	       ldx	#0
   5805  274c3				   -createdllholesloop
   5806  274c3				   -	       lda	DLLMEM,x
   5807  274c3				   -	       ora	#(WZONEHEIGHT*4)
   5808  274c3				   -	       sta	DLLMEM,x
   5809  274c3				   -	       ifconst	DOUBLEBUFFER
   5810  274c3				   -	       sta	DLLMEM+DBOFFSET,x
   5811  274c3				   -	       endif
   5812  274c3				   -	       inx
   5813  274c3				   -	       inx
   5814  274c3				   -	       inx
   5815  274c3				   -	       ifconst	DOUBLEBUFFER
   5816  274c3				   -	       cpx	#DBOFFSET
   5817  274c3				   -	       bcc	createdllholesloop
   5818  274c3				   -	       else
   5819  274c3				   -	       bpl	createdllholesloop
   5820  274c3				   -	       endif
   5821  274c3				   -	       rts
   5822  274c3					       endif
   5823  274c3
   5824  274c3							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5825  274c3
   5826  274c3				    START
   5827  274c3				    start
   5828  274c3
   5829  274c3							;******** more or less the Atari recommended startup procedure
   5830  274c3
   5831  274c3			78		       sei
   5832  274c4			d8		       cld
   5833  274c5
   5834  274c5					       ifnconst	NOTIALOCK
   5835  274c5			a9 07		       lda	#$07
   5836  274c7				   -	       else
   5837  274c7				   -	       lda	#$06
   5838  274c7					       endif
   5839  274c7			85 01		       sta	INPTCTRL	;lock 7800 into 7800 mode
   5840  274c9			a9 7f		       lda	#$7F
   5841  274cb			85 3c		       sta	CTRL	;disable DMA
   5842  274cd			a9 00		       lda	#$00
   5843  274cf			85 38		       sta	OFFSET
   5844  274d1					       ifnconst	NOTIALOCK
   5845  274d1			85 01		       sta	INPTCTRL
   5846  274d3			85 20		       sta	BACKGRND	; black default, in case a flash cart is using something else
   5847  274d5					       endif
   5848  274d5			a2 ff		       ldx	#$FF
   5849  274d7			9a		       txs
   5850  274d8
   5851  274d8							;************** Clear Memory
   5852  274d8
   5853  274d8							; ** Clear 1800-27FF, pg0+pg1 memory.
   5854  274d8				    ClearMemPages
   5855  274d8			a9 00		       lda	#0
   5856  274da			a8		       tay		; y=0
   5857  274db			85 80		       sta	$80
   5858  274dd			a2 18		       ldx	#$18
   5859  274df				    ClearMemPagesLoop
   5860  274df			86 81		       stx	$81	; needed for when we step on ZP memory
   5861  274e1			91 80		       sta	($80),y	;Store data
   5862  274e3			c8		       iny		;Next byte
   5863  274e4			d0 f9		       bne	ClearMemPagesLoop
   5864  274e6			e8		       inx
   5865  274e7			e0 28		       cpx	#$28
   5866  274e9			d0 f4		       bne	ClearMemPagesLoop
   5867  274eb			85 81		       sta	$81
   5868  274ed
   5869  274ed							;seed random number with hopefully-random timer value
   5870  274ed			a9 01		       lda	#1
   5871  274ef			0d 84 02	       ora	INTIM
   5872  274f2			85 40		       sta	rand
   5873  274f4
   5874  274f4							; detect the console type...
   5875  274f4				    pndetectvblankstart
   5876  274f4			a5 28		       lda	MSTAT
   5877  274f6			10 fc		       bpl	pndetectvblankstart	; if we're not in VBLANK, wait for it to start 
   5878  274f8				    pndetectvblankover
   5879  274f8			a5 28		       lda	MSTAT
   5880  274fa			30 fc		       bmi	pndetectvblankover	; then wait for it to be over
   5881  274fc			a0 00		       ldy	#$00
   5882  274fe			a2 00		       ldx	#$00
   5883  27500				    pndetectvblankhappening
   5884  27500			a5 28		       lda	MSTAT
   5885  27502			30 07		       bmi	pndetectinvblank	; if VBLANK starts, exit our counting loop 
   5886  27504			85 24		       sta	WSYNC
   5887  27506			85 24		       sta	WSYNC
   5888  27508			e8		       inx
   5889  27509			d0 f5		       bne	pndetectvblankhappening
   5890  2750b				    pndetectinvblank
   5891  2750b			e0 7d		       cpx	#125
   5892  2750d			90 02		       bcc	pndetecispal
   5893  2750f			a0 01		       ldy	#$01
   5894  27511				    pndetecispal
   5895  27511			8c 09 21	       sty	paldetected
   5896  27514
   5897  27514			20 24 f4	       jsr	createallgamedlls
   5898  27517
   5899  27517			a9 18		       lda	#>DLLMEM
   5900  27519			85 2c		       sta	DPPH
   5901  2751b			a9 00		       lda	#<DLLMEM
   5902  2751d			85 30		       sta	DPPL
   5903  2751f
   5904  2751f				   -	       ifconst	pokeysupport
   5905  2751f				   -			; pokey support is compiled in, so try to detect it...
   5906  2751f				   -	       jsr	detectpokeylocation
   5907  2751f					       endif
   5908  2751f
   5909  2751f			a9 01		       lda	#1	; default for port 0 and 1 is a regular joystick
   5910  27521			8d b8 01	       sta	port0control
   5911  27524			8d b9 01	       sta	port1control
   5912  27527
   5913  27527							;Setup port A to read mode
   5914  27527							;lda #$00
   5915  27527							;sta SWCHA
   5916  27527							;sta CTLSWA
   5917  27527
   5918  27527				   -	       ifconst	HSSUPPORT
   5919  27527				   -	       ifconst	bankswitchmode
   5920  27527				   -	       ifconst	included.hiscore.asm.bank
   5921  27527				   -	       ifconst	MCPDEVCART
   5922  27527				   -	       lda	#($18 | included.hiscore.asm.bank)
   5923  27527				   -	       ifconst	dumpbankswitch
   5924  27527				   -	       sta	dumpbankswitch
   5925  27527				   -	       endif
   5926  27527				   -	       sta	$3000
   5927  27527				   -	       else
   5928  27527				   -	       lda	#(included.hiscore.asm.bank)
   5929  27527				   -	       ifconst	dumpbankswitch
   5930  27527				   -	       sta	dumpbankswitch
   5931  27527				   -	       endif
   5932  27527				   -	       sta	$8000
   5933  27527				   -	       endif
   5934  27527				   -	       endif		; included.hiscore.asm.bank
   5935  27527				   -	       endif		; bankswitchmode
   5936  27527				   -			; try to detect HSC
   5937  27527				   -	       jsr	detecthsc
   5938  27527				   -	       and	#1
   5939  27527				   -	       sta	hsdevice
   5940  27527				   -skipHSCdetect
   5941  27527				   -			; try to detect AtariVox eeprom
   5942  27527				   -	       jsr	detectatarivoxeeprom
   5943  27527				   -	       and	#2
   5944  27527				   -	       ora	hsdevice
   5945  27527				   -	       cmp	#3
   5946  27527				   -	       bne	storeAinhsdevice
   5947  27527				   -			; For now, we tie break by giving HSC priority over AtariVox.
   5948  27527				   -			; Later we should check each device's priority byte if set, instead, 
   5949  27527				   -	       lda	#2
   5950  27527				   -storeAinhsdevice
   5951  27527				   -	       sta	hsdevice
   5952  27527				   -	       lda	#$ff
   5953  27527				   -	       sta	hsdifficulty
   5954  27527				   -	       sta	hsgameslot
   5955  27527				   -	       sta	hsnewscoreline
   5956  27527					       endif		; HSSUPPORT
   5957  27527
   5958  27527				   -	       ifconst	AVOXVOICE
   5959  27527				   -	       jsr	silenceavoxvoice
   5960  27527					       endif
   5961  27527
   5962  27527				   -	       ifconst	RMT
   5963  27527				   -	       ifconst	RMTVOLUME
   5964  27527				   -	       lda	#$F0	; default to full RMT volume
   5965  27527				   -	       sta	rmtvolume
   5966  27527				   -	       ifconst	TIAVOLUME
   5967  27527				   -	       sta	tiavolume
   5968  27527				   -	       endif		; TIAVOLUME
   5969  27527				   -	       endif		; RMTVOLUME
   5970  27527					       else		; !RMT
   5971  27527				   -	       ifconst	TIAVOLUME
   5972  27527				   -	       lda	#$F0	; default to full TIA volume
   5973  27527				   -	       sta	tiavolume
   5974  27527					       endif		; TIAVOLUME
   5975  27527					       endif		; RMT
   5976  27527
   5977  27527					       ifconst	bankswitchmode
   5978  27527							; we need to switch to the first bank as a default. this needs to
   5979  27527							; happen before DMA, in case there's a topscreenroutine in bank 0
   5980  27527				   -	       ifconst	MCPDEVCART
   5981  27527				   -	       lda	#$18	; xxx11nnn - switch to bank 0
   5982  27527				   -	       ifconst	dumpbankswitch
   5983  27527				   -	       sta	dumpbankswitch
   5984  27527				   -	       endif
   5985  27527				   -	       sta	$3000
   5986  27527					       else
   5987  27527			a9 00		       lda	#0
   5988  27529				   -	       ifconst	dumpbankswitch
   5989  27529				   -	       sta	dumpbankswitch
   5990  27529					       endif
   5991  27529			8d 00 80	       sta	$8000
   5992  2752c					       endif
   5993  2752c					       endif
   5994  2752c
   5995  2752c							; CTRL 76543210
   5996  2752c							; 7 colorburst kill
   5997  2752c							; 6,5 dma ctrl 2=normal DMA, 3=no DMA
   5998  2752c							; 4 character width 1=2 byte chars, 0=1 byte chars
   5999  2752c							; 3 border control 0=background color border, 1=black border
   6000  2752c							; 2 kangaroo mode 0=transparency, 1=kangaroo
   6001  2752c							; 1,0 read mode 0=160x2/160x4 1=N/A 2=320B/320D 3=320A/320C
   6002  2752c
   6003  2752c				   -	       ifconst	DOUBLEWIDE
   6004  2752c				   -	       lda	#%01010000	;Enable DMA, mode=160x2/160x4, 2x character width
   6005  2752c					       else
   6006  2752c			a9 40		       lda	#%01000000	;Enable DMA, mode=160x2/160x4
   6007  2752e					       endif
   6008  2752e
   6009  2752e			20 87 f4	       jsr	waitforvblankstart	; give the some vblank time to minimally update the display
   6010  27531
   6011  27531			85 3c		       sta	CTRL
   6012  27533			8d 07 21	       sta	sCTRL
   6013  27536
   6014  27536			20 17 f4	       jsr	vblankresync
   6015  27539
   6016  27539			a2 01		       ldx	#1
   6017  2753b			20 ad f4	       jsr	settwobuttonmode
   6018  2753e			a2 00		       ldx	#0
   6019  27540			20 ad f4	       jsr	settwobuttonmode
   6020  27543
   6021  27543					       ifnconst	.altgamestart
   6022  27543			4c 00 80	       jmp	game
   6023  27546				   -	       else
   6024  27546				   -	       jmp	.altgamestart
   6025  27546					       endif
   6026  27546
   6027  27546							; Provided under the CC0 license. See the included LICENSE.txt for details.
   6028  27546
   6029  27546							; A tunable parameter, to claim some memory back from DL usage
   6030  27546			00 00	    MEMSKIP    =	$00
   6031  27546
   6032  27546							;************** Setup DLL entries
   6033  27546
   6034  27546							; setup some working definitions, to avoid ifnconst mess elsewhere...
   6035  27546					       ifnconst	SCREENHEIGHT
   6036  27546			00 c0	    WSCREENHEIGHT =	192
   6037  27546				   -	       else
   6038  27546				   -WSCREENHEIGHT =	SCREENHEIGHT
   6039  27546					       endif
   6040  27546
   6041  27546				   -	       ifnconst	ZONEHEIGHT
   6042  27546				   -WZONEHEIGHT =	16
   6043  27546					       else
   6044  27546			00 10	    WZONEHEIGHT =	ZONEHEIGHT
   6045  27546					       endif
   6046  27546
   6047  27546					       ifnconst	ZONECOUNT
   6048  27546				   -	       ifconst	VSCROLL
   6049  27546				   -WZONECOUNT =	((WSCREENHEIGHT/WZONEHEIGHT)+1)
   6050  27546					       else		; !VSCROLL
   6051  27546			00 0c	    WZONECOUNT =	(WSCREENHEIGHT/WZONEHEIGHT)
   6052  27546					       endif		; !VSCROLL
   6053  27546				   -	       else
   6054  27546				   -	       ifconst	VSCROLL
   6055  27546				   -WZONECOUNT =	(ZONECOUNT+1)
   6056  27546				   -	       else		; !VSCROLL
   6057  27546				   -WZONECOUNT =	ZONECOUNT
   6058  27546				   -	       endif		; !VSCROLL
   6059  27546					       endif
   6060  27546
   6061  27546							; top of the frame, non-visible lines. this is based on NTSC,
   6062  27546							; but we add in extra NV lines at the end of the display to ensure
   6063  27546							; our PAL friends can play the game without it crashing.
   6064  27546			00 19	    NVLINES    =	((243-WSCREENHEIGHT)/2)
   6065  27546
   6066  27546					       ifnconst	DLMEMSTART
   6067  27546					       ifnconst	DOUBLEBUFFER
   6068  27546				    WDLMEMSTART SET	$1880
   6069  27546				   -	       else
   6070  27546				   -WDLMEMSTART SET	$18E0
   6071  27546					       endif		; DOUBLEBUFFER
   6072  27546				   -	       else
   6073  27546				   -WDLMEMSTART SET	DLMEMSTART
   6074  27546					       endif
   6075  27546
   6076  27546				   -	       if	MEMSKIP > 0
   6077  27546				   -	       echo	"   ",[WDLMEMSTART],"to",[WDLMEMSTART+MEMSKIP-1],"was freed for game usage with MEMSKIP."
   6078  27546				   -WDLMEMSTART SET	(WDLMEMSTART + MEMSKIP)
   6079  27546					       endif		; MEMSKIP > 0
   6080  27546
   6081  27546					       ifnconst	DLMEMEND
   6082  27546				   -	       ifconst	EXTRADLMEMORY
   6083  27546				   -WDLMEMEND  =	$23FF
   6084  27546					       else
   6085  27546			1f ff	    WDLMEMEND  =	$1FFF
   6086  27546					       endif
   6087  27546				   -	       else
   6088  27546				   -WDLMEMEND  =	DLMEMEND
   6089  27546					       endif
   6090  27546
   6091  27546
   6092  27546				    WMEMSIZE   SET	(WDLMEMEND-WDLMEMSTART+1)
   6093  27546
   6094  27546				   -	       ifconst	VSCROLL
   6095  27546				   -	       ifnconst	DOUBLEBUFFER
   6096  27546				   -			; give the last zone extra ram for the dma mask objects...
   6097  27546				   -WMEMSIZE   SET	(WMEMSIZE-(maskscrollspriteend-maskscrollsprite))
   6098  27546				   -	       endif		; DOUBLEBUFFER
   6099  27546					       endif		; VSCROLL
   6100  27546
   6101  27546					       ifnconst	DOUBLEBUFFER
   6102  27546			00 9b	    DLLASTOBJ  =	((((WMEMSIZE/WZONECOUNT)-2)/5)*5)	; -2 to always ensure we have 1x double-byte terminator
   6103  27546				   -	       else
   6104  27546				   -DLLASTOBJ  =	((((WMEMSIZE/WZONECOUNT)-4)/10)*5)	; -4 to always ensure we have 2x double-byte terminators
   6105  27546					       endif
   6106  27546
   6107  27546			00 9d	    TDOUBLEBUFFEROFFSET =	(DLLASTOBJ+2)	; offset between DL buffers. ie. half the real DL
   6108  27546				   -	       if	TDOUBLEBUFFEROFFSET > 255
   6109  27546				   -DOUBLEBUFFEROFFSET =	255
   6110  27546					       else
   6111  27546			00 9d	    DOUBLEBUFFEROFFSET =	(DLLASTOBJ+2)
   6112  27546					       endif
   6113  27546
   6114  27546				   -	       ifconst	EXTRADLMEMORY
   6115  27546				   -SECONDDLHALFSTART SET	$2300
   6116  27546					       endif
   6117  27546
   6118  27546				    DLPOINTH
   6119  27546				    DLINDEX    SET	0
   6120  27546					       REPEAT	WZONECOUNT
   6121  27546				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6122  27546				   -	       ifconst	EXTRADLMEMORY
   6123  27546				   -	       if	TMPMEMADDRESS > $1FFF
   6124  27546				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6125  27546				   -	       else
   6126  27546				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6127  27546				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6128  27546				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6129  27546				   -	       endif
   6130  27546				   -	       endif		; TMPMEMADDRESS > $1FFF
   6131  27546					       endif		; EXTRADLMEMORY
   6132  27546							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6133  27546			18		       .byte.b	>TMPMEMADDRESS
   6134  27546				    DLINDEX    SET	DLINDEX + 1
   6120  27546					       REPEND
   6121  27546				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6122  27547				   -	       ifconst	EXTRADLMEMORY
   6123  27547				   -	       if	TMPMEMADDRESS > $1FFF
   6124  27547				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6125  27547				   -	       else
   6126  27547				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6127  27547				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6128  27547				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6129  27547				   -	       endif
   6130  27547				   -	       endif		; TMPMEMADDRESS > $1FFF
   6131  27547					       endif		; EXTRADLMEMORY
   6132  27547							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6133  27547			19		       .byte.b	>TMPMEMADDRESS
   6134  27547				    DLINDEX    SET	DLINDEX + 1
   6120  27547					       REPEND
   6121  27547				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6122  27548				   -	       ifconst	EXTRADLMEMORY
   6123  27548				   -	       if	TMPMEMADDRESS > $1FFF
   6124  27548				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6125  27548				   -	       else
   6126  27548				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6127  27548				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6128  27548				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6129  27548				   -	       endif
   6130  27548				   -	       endif		; TMPMEMADDRESS > $1FFF
   6131  27548					       endif		; EXTRADLMEMORY
   6132  27548							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6133  27548			19		       .byte.b	>TMPMEMADDRESS
   6134  27548				    DLINDEX    SET	DLINDEX + 1
   6120  27548					       REPEND
   6121  27548				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6122  27549				   -	       ifconst	EXTRADLMEMORY
   6123  27549				   -	       if	TMPMEMADDRESS > $1FFF
   6124  27549				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6125  27549				   -	       else
   6126  27549				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6127  27549				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6128  27549				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6129  27549				   -	       endif
   6130  27549				   -	       endif		; TMPMEMADDRESS > $1FFF
   6131  27549					       endif		; EXTRADLMEMORY
   6132  27549							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6133  27549			1a		       .byte.b	>TMPMEMADDRESS
   6134  27549				    DLINDEX    SET	DLINDEX + 1
   6120  27549					       REPEND
   6121  27549				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6122  2754a				   -	       ifconst	EXTRADLMEMORY
   6123  2754a				   -	       if	TMPMEMADDRESS > $1FFF
   6124  2754a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6125  2754a				   -	       else
   6126  2754a				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6127  2754a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6128  2754a				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6129  2754a				   -	       endif
   6130  2754a				   -	       endif		; TMPMEMADDRESS > $1FFF
   6131  2754a					       endif		; EXTRADLMEMORY
   6132  2754a							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6133  2754a			1b		       .byte.b	>TMPMEMADDRESS
   6134  2754a				    DLINDEX    SET	DLINDEX + 1
   6120  2754a					       REPEND
   6121  2754a				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6122  2754b				   -	       ifconst	EXTRADLMEMORY
   6123  2754b				   -	       if	TMPMEMADDRESS > $1FFF
   6124  2754b				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6125  2754b				   -	       else
   6126  2754b				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6127  2754b				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6128  2754b				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6129  2754b				   -	       endif
   6130  2754b				   -	       endif		; TMPMEMADDRESS > $1FFF
   6131  2754b					       endif		; EXTRADLMEMORY
   6132  2754b							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6133  2754b			1b		       .byte.b	>TMPMEMADDRESS
   6134  2754b				    DLINDEX    SET	DLINDEX + 1
   6120  2754b					       REPEND
   6121  2754b				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6122  2754c				   -	       ifconst	EXTRADLMEMORY
   6123  2754c				   -	       if	TMPMEMADDRESS > $1FFF
   6124  2754c				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6125  2754c				   -	       else
   6126  2754c				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6127  2754c				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6128  2754c				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6129  2754c				   -	       endif
   6130  2754c				   -	       endif		; TMPMEMADDRESS > $1FFF
   6131  2754c					       endif		; EXTRADLMEMORY
   6132  2754c							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6133  2754c			1c		       .byte.b	>TMPMEMADDRESS
   6134  2754c				    DLINDEX    SET	DLINDEX + 1
   6120  2754c					       REPEND
   6121  2754c				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6122  2754d				   -	       ifconst	EXTRADLMEMORY
   6123  2754d				   -	       if	TMPMEMADDRESS > $1FFF
   6124  2754d				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6125  2754d				   -	       else
   6126  2754d				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6127  2754d				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6128  2754d				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6129  2754d				   -	       endif
   6130  2754d				   -	       endif		; TMPMEMADDRESS > $1FFF
   6131  2754d					       endif		; EXTRADLMEMORY
   6132  2754d							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6133  2754d			1c		       .byte.b	>TMPMEMADDRESS
   6134  2754d				    DLINDEX    SET	DLINDEX + 1
   6120  2754d					       REPEND
   6121  2754d				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6122  2754e				   -	       ifconst	EXTRADLMEMORY
   6123  2754e				   -	       if	TMPMEMADDRESS > $1FFF
   6124  2754e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6125  2754e				   -	       else
   6126  2754e				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6127  2754e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6128  2754e				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6129  2754e				   -	       endif
   6130  2754e				   -	       endif		; TMPMEMADDRESS > $1FFF
   6131  2754e					       endif		; EXTRADLMEMORY
   6132  2754e							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6133  2754e			1d		       .byte.b	>TMPMEMADDRESS
   6134  2754e				    DLINDEX    SET	DLINDEX + 1
   6120  2754e					       REPEND
   6121  2754e				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6122  2754f				   -	       ifconst	EXTRADLMEMORY
   6123  2754f				   -	       if	TMPMEMADDRESS > $1FFF
   6124  2754f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6125  2754f				   -	       else
   6126  2754f				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6127  2754f				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6128  2754f				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6129  2754f				   -	       endif
   6130  2754f				   -	       endif		; TMPMEMADDRESS > $1FFF
   6131  2754f					       endif		; EXTRADLMEMORY
   6132  2754f							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6133  2754f			1e		       .byte.b	>TMPMEMADDRESS
   6134  2754f				    DLINDEX    SET	DLINDEX + 1
   6120  2754f					       REPEND
   6121  2754f				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6122  27550				   -	       ifconst	EXTRADLMEMORY
   6123  27550				   -	       if	TMPMEMADDRESS > $1FFF
   6124  27550				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6125  27550				   -	       else
   6126  27550				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6127  27550				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6128  27550				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6129  27550				   -	       endif
   6130  27550				   -	       endif		; TMPMEMADDRESS > $1FFF
   6131  27550					       endif		; EXTRADLMEMORY
   6132  27550							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6133  27550			1e		       .byte.b	>TMPMEMADDRESS
   6134  27550				    DLINDEX    SET	DLINDEX + 1
   6120  27550					       REPEND
   6121  27550				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6122  27551				   -	       ifconst	EXTRADLMEMORY
   6123  27551				   -	       if	TMPMEMADDRESS > $1FFF
   6124  27551				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6125  27551				   -	       else
   6126  27551				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6127  27551				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6128  27551				   -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6129  27551				   -	       endif
   6130  27551				   -	       endif		; TMPMEMADDRESS > $1FFF
   6131  27551					       endif		; EXTRADLMEMORY
   6132  27551							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6133  27551			1f		       .byte.b	>TMPMEMADDRESS
   6134  27551				    DLINDEX    SET	DLINDEX + 1
   6135  27552					       REPEND
   6136  27552
   6137  27552				   -	       ifconst	EXTRADLMEMORY
   6138  27552				   -	       echo	"   ",[SECONDDLHALFSTART],"to",[$27FF],"was claimed as extra DL memory."
   6139  27552					       endif
   6140  27552
   6141  27552
   6142  27552				    DLPOINTL
   6143  27552				    DLINDEX    SET	0
   6144  27552					       REPEAT	WZONECOUNT
   6145  27552				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6146  27552				   -	       ifconst	EXTRADLMEMORY
   6147  27552				   -	       if	TMPMEMADDRESS > $1FFF
   6148  27552				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6149  27552				   -	       else
   6150  27552				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6151  27552				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6152  27552				   -	       endif
   6153  27552				   -	       endif		; TMPMEMADDRESS > $1FFF
   6154  27552					       endif		; EXTRADLMEMORY
   6155  27552			80		       .byte.b	<TMPMEMADDRESS
   6156  27552				    DLINDEX    SET	DLINDEX + 1
   6144  27552					       REPEND
   6145  27552				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6146  27553				   -	       ifconst	EXTRADLMEMORY
   6147  27553				   -	       if	TMPMEMADDRESS > $1FFF
   6148  27553				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6149  27553				   -	       else
   6150  27553				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6151  27553				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6152  27553				   -	       endif
   6153  27553				   -	       endif		; TMPMEMADDRESS > $1FFF
   6154  27553					       endif		; EXTRADLMEMORY
   6155  27553			20		       .byte.b	<TMPMEMADDRESS
   6156  27553				    DLINDEX    SET	DLINDEX + 1
   6144  27553					       REPEND
   6145  27553				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6146  27554				   -	       ifconst	EXTRADLMEMORY
   6147  27554				   -	       if	TMPMEMADDRESS > $1FFF
   6148  27554				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6149  27554				   -	       else
   6150  27554				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6151  27554				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6152  27554				   -	       endif
   6153  27554				   -	       endif		; TMPMEMADDRESS > $1FFF
   6154  27554					       endif		; EXTRADLMEMORY
   6155  27554			c0		       .byte.b	<TMPMEMADDRESS
   6156  27554				    DLINDEX    SET	DLINDEX + 1
   6144  27554					       REPEND
   6145  27554				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6146  27555				   -	       ifconst	EXTRADLMEMORY
   6147  27555				   -	       if	TMPMEMADDRESS > $1FFF
   6148  27555				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6149  27555				   -	       else
   6150  27555				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6151  27555				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6152  27555				   -	       endif
   6153  27555				   -	       endif		; TMPMEMADDRESS > $1FFF
   6154  27555					       endif		; EXTRADLMEMORY
   6155  27555			60		       .byte.b	<TMPMEMADDRESS
   6156  27555				    DLINDEX    SET	DLINDEX + 1
   6144  27555					       REPEND
   6145  27555				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6146  27556				   -	       ifconst	EXTRADLMEMORY
   6147  27556				   -	       if	TMPMEMADDRESS > $1FFF
   6148  27556				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6149  27556				   -	       else
   6150  27556				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6151  27556				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6152  27556				   -	       endif
   6153  27556				   -	       endif		; TMPMEMADDRESS > $1FFF
   6154  27556					       endif		; EXTRADLMEMORY
   6155  27556			00		       .byte.b	<TMPMEMADDRESS
   6156  27556				    DLINDEX    SET	DLINDEX + 1
   6144  27556					       REPEND
   6145  27556				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6146  27557				   -	       ifconst	EXTRADLMEMORY
   6147  27557				   -	       if	TMPMEMADDRESS > $1FFF
   6148  27557				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6149  27557				   -	       else
   6150  27557				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6151  27557				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6152  27557				   -	       endif
   6153  27557				   -	       endif		; TMPMEMADDRESS > $1FFF
   6154  27557					       endif		; EXTRADLMEMORY
   6155  27557			a0		       .byte.b	<TMPMEMADDRESS
   6156  27557				    DLINDEX    SET	DLINDEX + 1
   6144  27557					       REPEND
   6145  27557				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6146  27558				   -	       ifconst	EXTRADLMEMORY
   6147  27558				   -	       if	TMPMEMADDRESS > $1FFF
   6148  27558				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6149  27558				   -	       else
   6150  27558				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6151  27558				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6152  27558				   -	       endif
   6153  27558				   -	       endif		; TMPMEMADDRESS > $1FFF
   6154  27558					       endif		; EXTRADLMEMORY
   6155  27558			40		       .byte.b	<TMPMEMADDRESS
   6156  27558				    DLINDEX    SET	DLINDEX + 1
   6144  27558					       REPEND
   6145  27558				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6146  27559				   -	       ifconst	EXTRADLMEMORY
   6147  27559				   -	       if	TMPMEMADDRESS > $1FFF
   6148  27559				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6149  27559				   -	       else
   6150  27559				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6151  27559				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6152  27559				   -	       endif
   6153  27559				   -	       endif		; TMPMEMADDRESS > $1FFF
   6154  27559					       endif		; EXTRADLMEMORY
   6155  27559			e0		       .byte.b	<TMPMEMADDRESS
   6156  27559				    DLINDEX    SET	DLINDEX + 1
   6144  27559					       REPEND
   6145  27559				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6146  2755a				   -	       ifconst	EXTRADLMEMORY
   6147  2755a				   -	       if	TMPMEMADDRESS > $1FFF
   6148  2755a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6149  2755a				   -	       else
   6150  2755a				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6151  2755a				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6152  2755a				   -	       endif
   6153  2755a				   -	       endif		; TMPMEMADDRESS > $1FFF
   6154  2755a					       endif		; EXTRADLMEMORY
   6155  2755a			80		       .byte.b	<TMPMEMADDRESS
   6156  2755a				    DLINDEX    SET	DLINDEX + 1
   6144  2755a					       REPEND
   6145  2755a				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6146  2755b				   -	       ifconst	EXTRADLMEMORY
   6147  2755b				   -	       if	TMPMEMADDRESS > $1FFF
   6148  2755b				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6149  2755b				   -	       else
   6150  2755b				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6151  2755b				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6152  2755b				   -	       endif
   6153  2755b				   -	       endif		; TMPMEMADDRESS > $1FFF
   6154  2755b					       endif		; EXTRADLMEMORY
   6155  2755b			20		       .byte.b	<TMPMEMADDRESS
   6156  2755b				    DLINDEX    SET	DLINDEX + 1
   6144  2755b					       REPEND
   6145  2755b				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6146  2755c				   -	       ifconst	EXTRADLMEMORY
   6147  2755c				   -	       if	TMPMEMADDRESS > $1FFF
   6148  2755c				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6149  2755c				   -	       else
   6150  2755c				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6151  2755c				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6152  2755c				   -	       endif
   6153  2755c				   -	       endif		; TMPMEMADDRESS > $1FFF
   6154  2755c					       endif		; EXTRADLMEMORY
   6155  2755c			c0		       .byte.b	<TMPMEMADDRESS
   6156  2755c				    DLINDEX    SET	DLINDEX + 1
   6144  2755c					       REPEND
   6145  2755c				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6146  2755d				   -	       ifconst	EXTRADLMEMORY
   6147  2755d				   -	       if	TMPMEMADDRESS > $1FFF
   6148  2755d				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6149  2755d				   -	       else
   6150  2755d				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6151  2755d				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6152  2755d				   -	       endif
   6153  2755d				   -	       endif		; TMPMEMADDRESS > $1FFF
   6154  2755d					       endif		; EXTRADLMEMORY
   6155  2755d			60		       .byte.b	<TMPMEMADDRESS
   6156  2755d				    DLINDEX    SET	DLINDEX + 1
   6157  2755e					       REPEND
   6158  2755e
   6159  2755e
   6160  2755e				    DLINDEX    SET	0
   6161  2755e					       REPEAT	WZONECOUNT
   6162  2755e				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6163  2755e				   -	       ifconst	EXTRADLMEMORY
   6164  2755e				   -	       if	TMPMEMADDRESS > $1FFF
   6165  2755e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6166  2755e				   -	       else
   6167  2755e				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6168  2755e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6169  2755e				   -	       endif
   6170  2755e				   -	       endif		; TMPMEMADDRESS > $1FFF
   6171  2755e					       endif		; EXTRADLMEMORY
   6172  2755e
   6173  2755e			18 80	    ZONE0ADDRESS =	TMPMEMADDRESS
   6174  2755e				    LASTZONEADDRESS SET	TMPMEMADDRESS
   6175  2755e
   6176  2755e				    DLINDEX    SET	DLINDEX + 1
   6161  2755e					       REPEND
   6162  2755e				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6163  2755e				   -	       ifconst	EXTRADLMEMORY
   6164  2755e				   -	       if	TMPMEMADDRESS > $1FFF
   6165  2755e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6166  2755e				   -	       else
   6167  2755e				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6168  2755e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6169  2755e				   -	       endif
   6170  2755e				   -	       endif		; TMPMEMADDRESS > $1FFF
   6171  2755e					       endif		; EXTRADLMEMORY
   6172  2755e
   6173  2755e			19 20	    ZONE1ADDRESS =	TMPMEMADDRESS
   6174  2755e				    LASTZONEADDRESS SET	TMPMEMADDRESS
   6175  2755e
   6176  2755e				    DLINDEX    SET	DLINDEX + 1
   6161  2755e					       REPEND
   6162  2755e				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6163  2755e				   -	       ifconst	EXTRADLMEMORY
   6164  2755e				   -	       if	TMPMEMADDRESS > $1FFF
   6165  2755e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6166  2755e				   -	       else
   6167  2755e				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6168  2755e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6169  2755e				   -	       endif
   6170  2755e				   -	       endif		; TMPMEMADDRESS > $1FFF
   6171  2755e					       endif		; EXTRADLMEMORY
   6172  2755e
   6173  2755e			19 c0	    ZONE2ADDRESS =	TMPMEMADDRESS
   6174  2755e				    LASTZONEADDRESS SET	TMPMEMADDRESS
   6175  2755e
   6176  2755e				    DLINDEX    SET	DLINDEX + 1
   6161  2755e					       REPEND
   6162  2755e				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6163  2755e				   -	       ifconst	EXTRADLMEMORY
   6164  2755e				   -	       if	TMPMEMADDRESS > $1FFF
   6165  2755e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6166  2755e				   -	       else
   6167  2755e				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6168  2755e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6169  2755e				   -	       endif
   6170  2755e				   -	       endif		; TMPMEMADDRESS > $1FFF
   6171  2755e					       endif		; EXTRADLMEMORY
   6172  2755e
   6173  2755e			1a 60	    ZONE3ADDRESS =	TMPMEMADDRESS
   6174  2755e				    LASTZONEADDRESS SET	TMPMEMADDRESS
   6175  2755e
   6176  2755e				    DLINDEX    SET	DLINDEX + 1
   6161  2755e					       REPEND
   6162  2755e				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6163  2755e				   -	       ifconst	EXTRADLMEMORY
   6164  2755e				   -	       if	TMPMEMADDRESS > $1FFF
   6165  2755e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6166  2755e				   -	       else
   6167  2755e				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6168  2755e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6169  2755e				   -	       endif
   6170  2755e				   -	       endif		; TMPMEMADDRESS > $1FFF
   6171  2755e					       endif		; EXTRADLMEMORY
   6172  2755e
   6173  2755e			1b 00	    ZONE4ADDRESS =	TMPMEMADDRESS
   6174  2755e				    LASTZONEADDRESS SET	TMPMEMADDRESS
   6175  2755e
   6176  2755e				    DLINDEX    SET	DLINDEX + 1
   6161  2755e					       REPEND
   6162  2755e				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6163  2755e				   -	       ifconst	EXTRADLMEMORY
   6164  2755e				   -	       if	TMPMEMADDRESS > $1FFF
   6165  2755e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6166  2755e				   -	       else
   6167  2755e				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6168  2755e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6169  2755e				   -	       endif
   6170  2755e				   -	       endif		; TMPMEMADDRESS > $1FFF
   6171  2755e					       endif		; EXTRADLMEMORY
   6172  2755e
   6173  2755e			1b a0	    ZONE5ADDRESS =	TMPMEMADDRESS
   6174  2755e				    LASTZONEADDRESS SET	TMPMEMADDRESS
   6175  2755e
   6176  2755e				    DLINDEX    SET	DLINDEX + 1
   6161  2755e					       REPEND
   6162  2755e				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6163  2755e				   -	       ifconst	EXTRADLMEMORY
   6164  2755e				   -	       if	TMPMEMADDRESS > $1FFF
   6165  2755e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6166  2755e				   -	       else
   6167  2755e				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6168  2755e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6169  2755e				   -	       endif
   6170  2755e				   -	       endif		; TMPMEMADDRESS > $1FFF
   6171  2755e					       endif		; EXTRADLMEMORY
   6172  2755e
   6173  2755e			1c 40	    ZONE6ADDRESS =	TMPMEMADDRESS
   6174  2755e				    LASTZONEADDRESS SET	TMPMEMADDRESS
   6175  2755e
   6176  2755e				    DLINDEX    SET	DLINDEX + 1
   6161  2755e					       REPEND
   6162  2755e				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6163  2755e				   -	       ifconst	EXTRADLMEMORY
   6164  2755e				   -	       if	TMPMEMADDRESS > $1FFF
   6165  2755e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6166  2755e				   -	       else
   6167  2755e				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6168  2755e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6169  2755e				   -	       endif
   6170  2755e				   -	       endif		; TMPMEMADDRESS > $1FFF
   6171  2755e					       endif		; EXTRADLMEMORY
   6172  2755e
   6173  2755e			1c e0	    ZONE7ADDRESS =	TMPMEMADDRESS
   6174  2755e				    LASTZONEADDRESS SET	TMPMEMADDRESS
   6175  2755e
   6176  2755e				    DLINDEX    SET	DLINDEX + 1
   6161  2755e					       REPEND
   6162  2755e				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6163  2755e				   -	       ifconst	EXTRADLMEMORY
   6164  2755e				   -	       if	TMPMEMADDRESS > $1FFF
   6165  2755e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6166  2755e				   -	       else
   6167  2755e				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6168  2755e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6169  2755e				   -	       endif
   6170  2755e				   -	       endif		; TMPMEMADDRESS > $1FFF
   6171  2755e					       endif		; EXTRADLMEMORY
   6172  2755e
   6173  2755e			1d 80	    ZONE8ADDRESS =	TMPMEMADDRESS
   6174  2755e				    LASTZONEADDRESS SET	TMPMEMADDRESS
   6175  2755e
   6176  2755e				    DLINDEX    SET	DLINDEX + 1
   6161  2755e					       REPEND
   6162  2755e				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6163  2755e				   -	       ifconst	EXTRADLMEMORY
   6164  2755e				   -	       if	TMPMEMADDRESS > $1FFF
   6165  2755e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6166  2755e				   -	       else
   6167  2755e				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6168  2755e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6169  2755e				   -	       endif
   6170  2755e				   -	       endif		; TMPMEMADDRESS > $1FFF
   6171  2755e					       endif		; EXTRADLMEMORY
   6172  2755e
   6173  2755e			1e 20	    ZONE9ADDRESS =	TMPMEMADDRESS
   6174  2755e				    LASTZONEADDRESS SET	TMPMEMADDRESS
   6175  2755e
   6176  2755e				    DLINDEX    SET	DLINDEX + 1
   6161  2755e					       REPEND
   6162  2755e				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6163  2755e				   -	       ifconst	EXTRADLMEMORY
   6164  2755e				   -	       if	TMPMEMADDRESS > $1FFF
   6165  2755e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6166  2755e				   -	       else
   6167  2755e				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6168  2755e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6169  2755e				   -	       endif
   6170  2755e				   -	       endif		; TMPMEMADDRESS > $1FFF
   6171  2755e					       endif		; EXTRADLMEMORY
   6172  2755e
   6173  2755e			1e c0	    ZONE10ADDRESS =	TMPMEMADDRESS
   6174  2755e				    LASTZONEADDRESS SET	TMPMEMADDRESS
   6175  2755e
   6176  2755e				    DLINDEX    SET	DLINDEX + 1
   6161  2755e					       REPEND
   6162  2755e				    TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6163  2755e				   -	       ifconst	EXTRADLMEMORY
   6164  2755e				   -	       if	TMPMEMADDRESS > $1FFF
   6165  2755e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6166  2755e				   -	       else
   6167  2755e				   -	       if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6168  2755e				   -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6169  2755e				   -	       endif
   6170  2755e				   -	       endif		; TMPMEMADDRESS > $1FFF
   6171  2755e					       endif		; EXTRADLMEMORY
   6172  2755e
   6173  2755e			1f 60	    ZONE11ADDRESS =	TMPMEMADDRESS
   6174  2755e				    LASTZONEADDRESS SET	TMPMEMADDRESS
   6175  2755e
   6176  2755e				    DLINDEX    SET	DLINDEX + 1
   6177  2755e					       REPEND
   6178  2755e
   6179  2755e
     $1880 to $1fff used as zone memory, allowing 31 display objects per zone.
   6180  2755e					       echo	"   ",[WDLMEMSTART],"to",[WDLMEMEND],"used as zone memory, allowing",[(DLLASTOBJ/5)]d,"display objects per zone."
   6181  2755e
   6182  2755e				    DLHEIGHT
   6183  2755e					       REPEAT	WZONECOUNT
   6184  2755e			0f		       .byte.b	(WZONEHEIGHT-1)
   6183  2755e					       REPEND
   6184  2755f			0f		       .byte.b	(WZONEHEIGHT-1)
   6183  2755f					       REPEND
   6184  27560			0f		       .byte.b	(WZONEHEIGHT-1)
   6183  27560					       REPEND
   6184  27561			0f		       .byte.b	(WZONEHEIGHT-1)
   6183  27561					       REPEND
   6184  27562			0f		       .byte.b	(WZONEHEIGHT-1)
   6183  27562					       REPEND
   6184  27563			0f		       .byte.b	(WZONEHEIGHT-1)
   6183  27563					       REPEND
   6184  27564			0f		       .byte.b	(WZONEHEIGHT-1)
   6183  27564					       REPEND
   6184  27565			0f		       .byte.b	(WZONEHEIGHT-1)
   6183  27565					       REPEND
   6184  27566			0f		       .byte.b	(WZONEHEIGHT-1)
   6183  27566					       REPEND
   6184  27567			0f		       .byte.b	(WZONEHEIGHT-1)
   6183  27567					       REPEND
   6184  27568			0f		       .byte.b	(WZONEHEIGHT-1)
   6183  27568					       REPEND
   6184  27569			0f		       .byte.b	(WZONEHEIGHT-1)
   6185  2756a					       REPEND
   6186  2756a
   6187  2756a							; Provided under the CC0 license. See the included LICENSE.txt for details.
   6188  2756a
   6189  2756a							; a simple guard, than ensures the 7800basic code hasn't
   6190  2756a							; spilled into the encryption area...
     2580 bytes left in the 7800basic reserved area.
   6191  2756a					       echo	"   ",($FF7E-*)d,"bytes left in the 7800basic reserved area."
   6192  2756a				   -	       if	(*>$FF7D)
   6193  2756a				   -	       echo
   6194  2756a				   -	       echo	"***************************"
   6195  2756a				   -	       echo	"*** Abort: ROM Overflow ***"
   6196  2756a				   -	       echo	"***************************"
   6197  2756a				   -	       ERR		; abort the assembly
   6198  2756a					       endif
   6199  2756a
   6200  2756a							; throw a compile
   6201  2756a				   -	       ifconst	RMT
   6202  2756a				   -	       ifnconst	pokeysupport
   6203  2756a				   -	       echo
   6204  2756a				   -	       echo	"************************************************************"
   6205  2756a				   -	       echo	"*** ABORT: RMT Tracker requires 'set pokeysupport $xxxx' ***"
   6206  2756a				   -	       echo	"************************************************************"
   6207  2756a				   -	       ERR		; abort
   6208  2756a				   -	       endif		; pokeysupport
   6209  2756a				   -	       ifnconst	pokeyaddress
   6210  2756a				   -	       echo
   6211  2756a				   -	       echo	"************************************************************"
   6212  2756a				   -	       echo	"*** ABORT: RMT Tracker requires 'set pokeysupport $xxxx' ***"
   6213  2756a				   -	       echo	"************************************************************"
   6214  2756a				   -	       ERR		; abort
   6215  2756a				   -	       endif		; pokeyaddress
   6216  2756a					       endif
   6217  2756a
   6218  2756a							; Provided under the CC0 license. See the included LICENSE.txt for details.
   6219  2756a
   6220  2756a				   -	       ifconst	DEV
   6221  2756a				   -	       ifnconst	ZONEHEIGHT
   6222  2756a				   -	       echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   6223  2756a				   -	       else
   6224  2756a				   -	       if	ZONEHEIGHT = 8
   6225  2756a				   -	       echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   6226  2756a				   -	       else
   6227  2756a				   -	       echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   6228  2756a				   -	       endif
   6229  2756a				   -	       endif
   6230  2756a					       endif
   6231  2756a
   6232  2756a				   -	       if	START_OF_ROM = .
   6233  2756a				   -	       .byte	0
   6234  2756a					       endif
   6235  2756a				    START_OF_ROM SET	0
   6236  2756a
   6237  2756a							; FF7E/FF7F contains the 7800basic crc checksum word
   6238  2756a
   6239  2756a							; FF80 - FFF7 contains the 7800 encryption key 
   6240  2756a
   6241  2756a				   -	       ifnconst	bankswitchmode
   6242  2756a				   -	       ORG	$FFF8
   6243  2756a					       else
   6244  2756a					       ifconst	ROM128K
   6245  27ff8					       ORG	$27FF8
   6246  27ff8					       RORG	$FFF8
   6247  27ff8					       endif
   6248  27ff8				   -	       ifconst	ROM144K
   6249  27ff8				   -	       ORG	$27FF8
   6250  27ff8				   -	       RORG	$FFF8
   6251  27ff8					       endif
   6252  27ff8				   -	       ifconst	ROM256K
   6253  27ff8				   -	       ORG	$47FF8
   6254  27ff8				   -	       RORG	$FFF8
   6255  27ff8					       endif
   6256  27ff8				   -	       ifconst	ROM272K
   6257  27ff8				   -	       ORG	$47FF8
   6258  27ff8				   -	       RORG	$FFF8
   6259  27ff8					       endif
   6260  27ff8				   -	       ifconst	ROM512K
   6261  27ff8				   -	       ORG	$87FF8
   6262  27ff8				   -	       RORG	$FFF8
   6263  27ff8					       endif
   6264  27ff8				   -	       ifconst	ROM528K
   6265  27ff8				   -	       ORG	$87FF8
   6266  27ff8				   -	       RORG	$FFF8
   6267  27ff8					       endif
   6268  27ff8					       endif
   6269  27ff8
   6270  27ff8
   6271  27ff8			ff		       .byte.b	$FF	; region verification. $FF=all regions
   6272  27ff9			f7		       .byte.b	$F7	; high nibble:  encryption check from $N000 to $FF7F. we only hash the last 4k for faster boot.
   6273  27ffa							; low nibble :  N=7 atari rainbow start, N=3 no atari rainbow
   6274  27ffa
   6275  27ffa							;Vectors
   6276  27ffa			00 f0		       .word.w	NMI
   6277  27ffc			c3 f4		       .word.w	START
   6278  27ffe			5f f0		       .word.w	IRQ
   6279  28000
